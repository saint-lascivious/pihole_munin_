#!/bin/sh

#         _  _             _                                     _
#  _ __  (_)| |__    ___  | |  ___      _ __ ___   _   _  _ __  (_) _ __
# | '_ \ | || '_ \  / _ \ | | / _ \    | '_ ` _ \ | | | || '_ \ | || '_ \
# | |_) || || | | || (_) || ||  __/ __ | | | | | || |_| || | | || || | | | __
# | .__/ |_||_| |_| \___/ |_| \___||__||_| |_| |_| \__,_||_| |_||_||_| |_||__|
# |_|

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

###############################################################################
# Contributors
###############################################################################
# - saint-lascivious (Hayden Pearce), 2025
#   https://github.com/saint-lascivious
# - fongd (Derek Fong), 2025
#   https://github.com/fongd
# - Bud, Jae and Tig
# - Major Depression and Sociopathy
###############################################################################

###############################################################################
# With Thanks To
###############################################################################
# - https://github.com/dispo2
###############################################################################

###############################################################################
# Special Thanks To
###############################################################################
# - Karmin Hunt
###############################################################################

###############################################################################
# Acknowledgements
###############################################################################
# - Christchurch Hospital Urology Unit team and staff
# - Christchurch Hospital Medical Imaging team and staff
###############################################################################

###############################################################################
# No Thanks At All To
###############################################################################
# - Cancer
# - My weak-ass stupid punk bitch organs
###############################################################################

###############################################################################
# Initial Setup, Version and Munin Documentation
###############################################################################

set -e

branch="master"
repo_url="github.com/saint-lascivious/pihole_munin_"
raw_repo_url="https://${repo_url}/raw/${branch}/pihole_munin_"

major_version="1"
minor_version="0"
micro_version="0"
version_tag="-master"

pihole_munin_version="${PIHOLE_MUNIN_VERSION:-${major_version}.${minor_version}.${micro_version}${version_tag}}"

: <<=cut
=head1 NAME

pihole_munin_

=head2 VERSION

${pihole_munin_version}

=head1 APPLICABLE SYSTEMS

Pi-hole >= 6.0

=head1 DESCRIPTION

Munin plugins for monitoring various Pi-hole¬Æ ‚â• 6.0 statistics.

=head1 MAGIC MARKERS

  #%# family=manual
  #%# capabilities=suggest

=head1 WILDCARD PLUGIN

This is a wildcard plugin.

=head2 PLUGINS

Plugins with an asterisk (*) are enabled by default.

  cache*: Shows Pi-hole's cache
  cache_by_type*: Shows Pi-hole's cached records by type
  clients: Shows active and total Pi-hole clients
  dnsmasq: Shows various Pi-hole FTLDNS dnsmasq statistics
  domains: Shows the number of domains being blocked by Pi-hole
  frequency*: Shows Pi-hole's query frequency
  gravity: Shows various Pi-hole gravity database statistics
  overview*: Shows an overview of Pi-hole's DNS traffic
  percent*: Shows Pi-hole's blocked query percentage
  privacy: Shows Pi-hole's privacy level
  queries*: Shows Pi-hole's queries
  queries_by_status*: Shows Pi-hole's queries by status
  queries_by_type*: Shows Pi-hole's queries by record type
  replies*: Shows Pi-hole's replies
  replies_by_type*: Shows Pi-hole's replies by record type
  status: Shows Pi-hole's blocking status
  top_clients: Shows Pi-hole's top clients by query count
  top_domains: Shows Pi-hole's top domains by query count
  unique*: Shows the number of unique domains queried by Pi-hole
  upstreams: Shows the query counts for each of Pi-hole's upstream destinations
  version: Shows the version status of Pi-hole components

Specify the plugins to be installed via the command line when using the 'admin' command (recommended).

E.g.

  ./pihole_munin_ admin install cache clients queries

If 'all' is specified as a plugin, all available plugins will be enabled.

E.g.

  ./pihole_munin_ admin install all

Or use the PLUGINS environment variable to govern the plugin list when using the 'admin' command.

E.g.

  PLUGINS="cache clients queries" ./pihole_munin_ admin install

=head1 USAGE

Use the 'admin' command to automatically install pihole_munin_ and enable all plugins.

E.g.

  ./pihole_munin_ admin install

Alternatively, you can install manually and link this plugin to /etc/munin/plugins/ as the desired plugin(s) and restart munin-node.

E.g.

  sudo mv pihole_munin_ /usr/share/munin/plugins/pihole_munin_
  sudo chmod +x /usr/share/munin/plugins/pihole_munin_

then to install the default plugins,

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_cache

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_cache_by_type

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_clients

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_frequency

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_overview

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_percent

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_queries

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_queries_by_status

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_queries_by_type

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_replies

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_replies_by_type

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_unique

additiionally, you can install any of the other plugins if desired, e.g.

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_dnsmasq

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_domains

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_gravity

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_privacy

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_status

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_top_clients

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_top_domains

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_upstreams

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_version

and then,

  sudo systemctl restart munin-node.service

=head1 CONFIGURATION

Example configuration for /etc/munin/plugin-conf.d/pihole_munin_

  [pihole_munin_*]
      ### AUTHENTICATION ###

      #### APPLICATION PASSWORD ####

      # A Pi-hole application password may be used to authenticate with the
      # Pi-hole API, this password differs from the web interface password.

      # Example:
      #   env.app_password APP_PASSWORD_HERE

      #### PI-HOLE PASSWORD ####

      # The Pi-hole password may also, but probably shouldn't, be used.

      # Example:
      #   env.pihole_password PIHOLE_PASSWORD_HERE

      #### CLI PASSWORD ####

      # The path at which Pi-hole's CLI password may be found.

      # If found and readable, this password will be used to authenticate
      # with the Pi-hole API if no other password is provided.
      env.cli_password /etc/pihole/cli_pw

      ### API ###

      # These variables are used to construct the base of the API URL.
      env.proto http
      env.host 127.0.0.1
      env.port 80
      env.api /api

      ### ALERTS ###

      # The following variables are used to set the alert thresholds for
      # various plugins.

      # To attempt to remove ambiguity, all <key> field names are the same
      # as the labels used in the graphs, with underscores (_) instead
      # of spaces ( ). These <key> field names are case-sensitive, so
      # ensure that you use the correct case when setting the alert
      # thresholds.

      # To remove any doubt, you can click on the graph in the Munin
      # interface to see the field names used in the graph, and the
      # corresponding internal name.

      # This should always match the label used in the graph, but just
      # in case it doesn't for some reason and you want to set an alert
      # threshold or any other modification, use the internal name.

      # The format for the variables is:
      #   env.<plugin>_<key>_<alert_type>

      # The plugin is the name of the plugin, e.g. cache, clients, etc.

      # The key is the name of the metric, e.g. evicted, active, etc.

      # The alert_type is either crit or warn, for critical and warning alerts
      # respectively.

      # The format for values is either a single value which represents the
      # maximum value before an alert is triggered, or a range of values 
      # separated by a colon, where an alert will be triggered if the value
      # is outside of the specified range.

      # Only individual default values are provided here, the rest are left
      # to the user to configure if desired.

      # percent
      env.percent_percent_blocked_crit 90
      env.percent_percent_blocked_warn 0:85

      # status
      env.status_blocking_status_crit 0:1
      env.status_blocking_status_warn 1:1

      ### PLUGINS ###

      # Plugins with an asterisk (*) are enabled by default.

      # cache*: Shows Pi-hole's cache
      # cache_by_type*: Shows Pi-hole's cached records by type
      # clients: Shows active and total Pi-hole clients
      # dnsmasq: Shows various Pi-hole FTLDNS dnsmasq statistics
      # domains: Shows the number of domains being blocked by Pi-hole
      # frequency*: Shows Pi-hole's query frequency
      # gravity: Shows various Pi-hole gravity database statistics
      # overview*: Shows an overview of Pi-hole's DNS traffic
      # percent*: Shows Pi-hole's blocked query percentage
      # privacy: Shows Pi-hole's privacy level
      # queries*: Shows Pi-hole's queries
      # queries_by_status*: Shows Pi-hole's queries by status
      # queries_by_type*: Shows Pi-hole's queries by record type
      # replies*: Shows Pi-hole's replies
      # replies_by_type*: Shows Pi-hole's replies by record type
      # status: Shows Pi-hole's blocking status
      # top_clients: Shows Pi-hole's top clients by query count
      # top_domains: Shows Pi-hole's top domains by query count
      # unique*: Shows the number of unique domains queried by Pi-hole
      # upstreams: Shows the query counts for each of Pi-hole's upstream destinations
      # version: Shows the version status of Pi-hole components

      # The top N clients and top N domains shown in the top_clients
      # and top_domains plugins may be configured by setting the
      # global top_n variable, or by setting the top_clients_top_n and
      # or top_domains_top_n variables respectively.

      # The format for the variables is:
      #   env.top_n
      #   env.<plugin>_top_n

      # Plugins: top_clients, top_domains

      # The format for the values is a numerical value representing the
      # number of clients or domains to be shown in the graph.

      # The default value is 25, the maximum and minimum values are 100 and 1
      # respectively.

      # Specify the plugins to be installed via the command line when using the
      # 'admin' command (recommended).

      # Example:
      #   ./pihole_munin_ admin install cache clients queries

      # If 'all' is specified as a plugin, all available plugins will be enabled.

      # Example:
      #   ./pihole_munin_ admin install all

      # Or use the PLUGINS environment variable to govern the plugin list
      # when using the 'admin' command.

      # Example:
      #   PLUGINS="cache clients queries" ./pihole_munin_ admin install

      ### GRAPHS ###

      # The following variables are used to set the graphing options.

      #### GRAPH ####

      # The graph value determines wheter graphs are drawn or not.
      env.graph yes

      # The graph value may be overridden on a per-plugin basis by setting the
      # graph_<plugin> variable to the desired value (yes/no).

      #### GRAPH_ARGS ####

      # The graph_args value determines the arguments passed to Munin's
      # graphing engine.
      env.graph_args --lower-limit 0

      # The default graph arguments are:
      #   cache: --lower-limit 0
      #   cache_by_type: --lower-limit 0
      #   clients: --lower-limit 0
      #   dnsmasq: --lower-limit 0
      #   domains: --lower-limit 0
      #   frequency: --lower-limit 0
      #   gravity: --lower-limit 0
      #   overview: --lower-limit 0
      #   percent: --upper-limit 100 --lower-limit 0
      #   privacy: --upper-limit 3 --lower-limit 0
      #   queries: --lower-limit 0
      #   queries_by_status: --lower-limit 0
      #   queries_by_type: --lower-limit 0
      #   replies: --lower-limit 0
      #   replies_by_type: --lower-limit 0
      #   status: --lower-limit -1 --upper-limit 1
      #   top_clients: --lower-limit 0
      #   top_domains: --lower-limit 0
      #   unique: --lower-limit 0
      #   upstreams: --lower-limit 0
      #   version: --lower-limit -1 --upper-limit 1

      # The default graph arguments may be overridden by setting the
      # graph_args_<plugin> variable to the desired arguments.

      #### GRAPH_CATEGORY ####

      # The graph_category value determines the category in which the
      # pihole_munin_* graphs appear in Munin's interface when drawn.
      env.graph_category dns

      # The default graph category may be overridden on a per-plugin basis
      # by setting the graph_category_<plugin> variable to the desired
      # category.

      #### GRAPH_HEIGHT ####

      # The graph_height value determines the height of the graph in Munin's
      # interface.
      env.graph_height 200

      # The graph height may be overridden on a per-plugin basis by setting the
      # graph_height_<plugin> variable to the desired height.

      #### GRAPH_INFO ####

      # The graph_info_* values determine the information displayed in the
      # graph's tooltip in Munin's interface.

      # The default graph information is:
      #   cache: This graph shows Pi-hole's cache, visit \
      #     https://docs.pi-hole.net/ftldns/dns-cache/ for more information
      #   cache_by_type: This graph shows Pi-hole's cached records by type
      #   clients: This graph shows Pi-hole's active and total clients
      #   dnsmasq: This graph shows various Pi-hole dnsmasq statistics
      #   domains: This graph shows Pi-hole's domains being blocked
      #   frequency: This graph shows Pi-hole's query frequency
      #   gravity: This graph shows Pi-hole's gravity database statistics
      #   overview: This graph shows an overview of Pi-hole's DNS traffic
      #   percent: This graph shows Pi-hole's blocked query percentage
      #   privacy: This graph shows Pi-hole's privacy level, visit \
      #     https://docs.pi-hole.net/ftldns/privacylevels/ for more information
      #   queries: This graph shows Pi-hole's queries
      #   queries_by_status: This graph shows Pi-hole's queries by status
      #   queries_by_type: This graph shows Pi-hole's queries by record type
      #   replies: This graph shows Pi-hole's replies
      #   replies_by_type: This graph shows Pi-hole's replies by record type
      #   status: This graph shows Pi-hole's blocking status
      #   top_clients: This graph shows Pi-hole's top clients by query count \
      #     (max <top_n> clients)
      #   top_domains: This graph shows Pi-hole's top domains by query count \
      #     (max <top_n> domains)
      #   upstreams: This graph shows the query counts for each of Pi-hole's \
      #     upstream destinations
      #   unique: This graph shows the number of unique domains queried
      #   version: This graph shows the version status of Pi-hole components

      # The default graph information may be overidden by setting the
      # graph_info_<plugin> variable to the desired information.

      #### GRAPH_SCALE ####

      # The graph_scale value determines whether the graph is scaled to fit the
      # data in Munin's interface.
      env.graph_scale no

      # The graph scaling may be overridden on a per-plugin basis by setting
      # the graph_scale_<plugin> variable to the desired value (yes/no).

      #### GRAPH_TITLE ####

      # The graph_title_* values determine the title of the graph in Munin's
      # interface.

      # The default graph titles are:
      #   cache: Pi-hole cache
      #   cache_by_type: Pi-hole cache by type
      #   clients: Pi-hole clients
      #   dnsmasq: Pi-hole dnsmasq
      #   domains: Pi-hole domains being blocked
      #   frequency: Pi-hole query frequency
      #   gravity: Pi-hole gravity database
      #   overview: Pi-hole overview
      #   percent: Pi-hole percent blocked
      #   privacy: Pi-hole privacy level
      #   queries: Pi-hole queries
      #   queries_by_status: Pi-hole queries by status
      #   queries_by_type: Pi-hole queries by type
      #   replies: Pi-hole replies
      #   replies_by_type: Pi-hole replies by type
      #   status: Pi-hole status
      #   top_clients: Pi-hole top clients
      #   top_domains: Pi-hole top domains
      #   unique: Pi-hole unique domains
      #   upstreams: Pi-hole upstream DNS servers
      #   version: Pi-hole version status

      # The default graph titles may be overridden by setting the
      # graph_title_<plugin> variable to the desired title.

      #### GRAPH_TOTAL ####

      # The graph_total_* variables determines whether a total line is drawn in
      # the graph's legend in Munin's interface.

      # Attribute: graph_total
      # Value: string
      # Type: optional
      # Description: If set, summarizes all the data sources' values and
      #   reports the results in an extra row in the legend beneath the graph.
      #   The value you set here is used as label for that line.
      #   Note that, since Munin version 2.1, using the special undef keyword
      #   disables it (to override in munin.conf).

      # The format for the variables is:
      #   env.graph_total_<plugin>

      # Plugins: cache_by_type, queries, queries_by_status, queries_by_type
      # replies and replies_by_type

      # The format for the values is a string containing the label to be
      # displayed in the graph's legend in Munin's interface.
      # E.g. "total", "sum", "all", etc.

      #### GRAPH_VLABEL ####

      # The graph_vlabel_* values determine the vertical label of the graph
      # in Munin's interface.

      # The default graph vertical labels are:
      #   cache: resource records / second
      #   cache_by_type: resource records / second
      #   clients: clients
      #   dnsmasq: count
      #   domains: domains being blocked
      #   frequency: queries / second
      #   gravity: count
      #   overview: queries in (-) | replies out (+) / second
      #   percent: percent blocked
      #   privacy: show all / 1 / 2 / anonymous
      #   queries: queries / second
      #   queries_by_status: queries / second
      #   queries_by_type: queries / second
      #   replies: replies / second
      #   replies_by_type: replies / second
      #   status: unknown / disabled / enabled
      #   top_clients: queries / second
      #   top_domains: queries / second
      #   unique: domains / second
      #   upstreams: queries / second
      #   version: unknown / up-to-date / update available

      # The default graph vertical labels may be overridden by setting the
      # graph_vlabel_<plugin> variable to the desired label.

      #### GRAPH_WIDTH ####

      # The graph_width value determines the width of the graph in Munin's
      # interface.
      env.graph_width 400

      # The graph width may be overridden on a per-plugin basis by setting the
      # graph_width_<plugin> variable to the desired width.

      #### GRAPH_ZERO ####

      # The graph_zero value determines whether or not graphs with multiple
      # fields should graph key value pairs with a value of zero.
      env.graph_zero yes

      # Attribute: graph_zero
      # Value: yes|no
      # Type: optional
      # Description: If set to yes, graphs with multiple fields will graph
      #   key value pairs with a value of zero. This is useful for graphs
      #   with multiple fields where some fields may not have data for a
      #   given time period, as it ensures that the graph will still show
      #   the zero value for those fields, rather than leaving a gap in the
      #   graph. If set to no, those fields will not be graphed at all.

      # Graph zeroing may be overridden on a per-plugin basis by setting
      # the graph_zero_<plugin> variable to the desired value (yes/no).

      # The format for the variables is:
      #   env.graph_zero_<plugin>

      # Plugins: cache, cache_by_type, dnsmasq, gravity, overview,
      # queries, queries_by_status, queries_by_type, replies and
      # replies_by_type

      # The format for the values is either yes or no.

      ### FIELDS ###

      # The following variables determine how graphed fields are displayed in
      # Munin's interface.

      #### FIELDNAME.COLOUR ####

      # Attribute: {fieldname}.colour
      # Value: Hexadecimal colour code
      # Type: optional
      # Description: Custom specification of colour for drawing curve.
      #   Available since 1.2.5 and 1.3.3.
      # Default: Selected by order sequence from Munin standard colour set

      # The format for the variables is:
      #   env.<plugin>_<key>_colour

      # The plugin is the name of the plugin, e.g. cache, clients, etc.

      # The key is the name of the metric, e.g. evicted, active, etc.

      # The format for the values is three or six hexadecimal digits
      # with or without a leading hash (#) character.
      # E.g. #FF0000, 00FF00, 0000FF, #F00, F0F, 0F0, 0F00FF, etc.

      #### FIELDNAME.DRAW ####

      # Attribute: {fieldname}.draw
      # Value: AREA, LINE, LINE[n], STACK, AREASTACK, LINESTACK, LINESTACK[n]
      # Type: optional
      # Description: Determines how the data points are displayed in the graph.
      #   The LINE takes an optional width suffix, commonly LINE1, LINE2, etc‚Ä¶

      # The *STACK values are specific to munin and makes the first a LINE,
      # LINE[n] or AREA datasource, and the rest as STACK.
      # Default: LINE1 since Munin version 2.0.

      # The format for the variables is:
      #   env.<plugin>_<key>_draw

      # The format for the values is the draw style to be used.
      # E.g. LINE1, LINE2, AREA, STACK, etc.

      #### FIELDNAME.GRAPH ####

      # Attribute: {fieldname}.graph
      # Value: yes|no
      # Type: optional
      # Description: Determines if the data source should be visible in
      #   the generated graph.
      # Default: yes

      # The format for the variables is:
      #   env.<plugin>_<key>_graph

      # The format for the values is either yes or no.

      #### FIELDNAME.INFO ####

      # Attribute: {fieldname}.info
      # Value: html text
      # Type: optional
      # Description: Explanation on the data source in this field. The Info is
      #   displayed in the field description table on the detail web page of
      #   the graph.

      # The format for the variables is:
      #   env.<plugin>_<key>_info

      # The format for the values is a string containing the information to be
      # displayed in the graph's tooltip in Munin's interface.

      #### FIELDNAME.LABEL ####

      # Attribute: {fieldname}.label
      # Value: anything except # and \
      # Type: required
      # Description: The label used in the legend for the graph on the HTML
      #   page.

      # The format for the variables is:
      #   env.<plugin>_<key>_label

      # The format for the values is a string containing the label to be
      # displayed in the graph's legend in Munin's interface.
      # The label can contain any special characters except hash (#) or
      # or forward slash (\).

      #### FIELDNAME.MAX ####

      # Attribute: {fieldname}.max
      # Value: numerical of same data type as the field it belongs to.
      # Type: optional
      # Description: Sets a maximum value. If the fetched value is above "max",
      #   it will be discarded.

      # The format for the variables is:
      #   env.<plugin>_<key>_max

      # The format for the values is a numerical value.

      #### FIELDNAME.MIN ####

      # Attribute: {fieldname}.min
      # Value: numerical of same data type as the field it belongs to.
      # Type: optional
      # Description: Sets a minimum value. If the fetched value is below "min",
      #   it will be discarded.

      # The format for the variables is:
      #   env.<plugin>_<key>_min

      # The format for the values is a numerical value.

      #### FIELDNAME.TYPE ####

      # Attribute: {fieldname}.type
      # Value: DERIVE|GAUGE|COUNTER|ABSOLUTE
      # Type: optional
      # Description: Sets the RRD Data Source Type for this field.
      #   The values must be written in capitals. The type used may
      #   introduce restrictions for {fieldname.value}.
      # Default: DERIVE or GAUGE, depending on the plugin.

      # The default type is DERIVE for most plugins, and GAUGE for
      # the remainder.

      # The type of the field determines how the data is interpreted
      # by Munin's graphing engine. The type may be one of the following:
      #   DERIVE: A value that can go up and down, but is derived from a
      #     counter, e.g. network traffic, etc.
      #   GAUGE: A value that can go up and down, e.g. temperature, disk
      #     usage, etc.
      #   COUNTER: A value that only goes up, e.g. number of requests, bytes
      #     sent, etc.
      #   ABSOLUTE: A value that is an absolute number, e.g. number of users.

      # The format for the variables is:
      #   env.<plugin>_<key>_type

      # The format for the values is the type of graph to be used.
      # E.g. GAUGE, DERIVE, COUNTER, ABSOLUTE, etc.

      ### MISCELLANEOUS ###

      #### USER AND GROUP ####

      # The user these plugins should run as.
      # The pihole user has access to the CLI password by default.
      user pihole

      # The group these plugins should run as.
      # The pihole group has access to the CLI password by default.
      group pihole

      #### STATEFULNESS ####

      # API responses are cached to reduce the number of requests made to the
      # Pi-hole API. This variable determines the time (in seconds) before
      # cached responses are considered stale.
      env.state_ttl 240

      # The *_state_ttl variables can be used to override the default state_ttl
      # value on a per-plugin basis.

      # The default state ttl may be overridden by setting the
      # <plugin>_state_ttl variable to the desired value.

      # The session_ttl variable determines the time (in seconds) before cached
      # session IDs are considered stale.

      # This variable is only used if session_cache is set to 1 (default 0).
      env.session_ttl 300

      # Persistent session caching is disabled by default, but can be enabled
      # by setting the session_cache variable to 1.
      env.session_cache 0

The plugin can be configured manually, or via the command line using the admin command.

E.g.

  ./pihole_munin_ admin add <var> [<val>]
  ./pihole_munin_ admin remove <var>
  ./pihole_munin_ admin list

Variables SHOULD be entered without the env. prefix, and values SHOULD be without encapsulating quotation.

E.g.

  ./pihole_munin_ admin add graph_category dns
  ./pihole_munin_ admin add clients_active_warn 1:50
  ./pihole_munin_ admin add clients_total_warn 100

Sensitive variables such as the Application or Pi-hole Passwords get a special carve outs in the admin command.

Firstly, if entered without a value, both the 'app_password' and 'pihole_password' variables trigger a prompt to enter (and confirm) the password interactively.

E.g.

  ./pihole_munin_ admin add app_password
  ./pihole_munin_ admin add pihole_password

Secondly, if entered with the value 'nopassword', 'none' or 'null', the 'pihole_password' is set to an empty string (internally).

E.g.

  ./pihole_munin_ admin add pihole_password nopassword
  ./pihole_munin_ admin add pihole_password none
  ./pihole_munin_ admin add pihole_password null

=head1 AUTHOR

saint-lascivious (Hayden Pearce), 2025

=head1 LICENSE

GNU GPLv3
=cut

###############################################################################
# Script Path & Plugin ID Detection
###############################################################################

case "${0}" in
    /*) script_path="${0}" ;;
    *)
        script_path="$(cd "$(dirname "${0}")" && pwd)/$(basename "${0}")"
        ;;
esac

###############################################################################
# Plugin ID Detection
###############################################################################
# Extract the plugin ID from the script name
# E.g. pihole_munin_percent -> percent
# If no plugin ID is found, default to "percent"
#################################################################################

pihole_munin_plugin_id="$(printf "%s" "${script_path}" | sed -e 's/^.*pihole_munin_//')"

if [ -z "${pihole_munin_plugin_id}" ]; then
    pihole_munin_plugin_id="percent"
fi

###############################################################################
# Password & Host Setup
###############################################################################

password_to_use=""
password_set="0"

host="${host:-"127.0.0.1"}"
is_localhost="0"

cli_password="${cli_password:-"/etc/pihole/cli_pw"}"

pihole_munin_user="${SUDO_USER:-${USER}}"
pihole_munin_host="$(hostname)"

###############################################################################
# Colour Output Setup
###############################################################################

use_colour="${USE_COLOUR:-"1"}"

if [ "${use_colour}" = "1" ] && [ -t 1 ] && [ -n "${TERM}" ] && [ "${TERM}" != "dumb" ]; then
    TEXT_WHITE='\033[38;5;15m'
    TEXT_RED='\033[38;5;196m'
    TEXT_ORANGE='\033[38;5;208m'
    TEXT_YELLOW='\033[38;5;226m'
    TEXT_LIGHTGREEN='\033[38;5;46m'
    TEXT_GREEN='\033[38;5;2m'
    TEXT_LIGHTBLUE='\033[38;5;39m'
    TEXT_BLUE='\033[38;5;21m'
    TEXT_INDIGO='\033[38;5;93m'
    TEXT_VIOLET='\033[38;5;201m'
    TEXT_RESET='\033[0m'
else
    TEXT_WHITE=''
    TEXT_RED=''
    TEXT_ORANGE=''
    TEXT_YELLOW=''
    TEXT_LIGHTGREEN=''
    TEXT_GREEN=''
    TEXT_LIGHTBLUE=''
    TEXT_BLUE=''
    TEXT_INDIGO=''
    TEXT_VIOLET=''
    TEXT_RESET=''
fi

###############################################################################
# Terminal Cleanup Helper
###############################################################################
# Usage:
#   pihole_munin_term_cleanup
#
# Description:
#   Restores terminal settings to sane defaults and prints a newline.
#   Typically used after disabling echo/canonical mode for masked input
#   or other interactive prompts to ensure the terminal is left in a usable state.
#
# Logic:
#   - Calls 'stty sane' to reset terminal modes.
#   - Prints a newline for clean output.
#
# Output:
#   - Restores terminal settings and prints a newline.
###############################################################################

pihole_munin_term_cleanup() {
    stty sane
    printf '\n'
}

###############################################################################
# Status Print Helper
###############################################################################
# Usage:
#   pihole_munin_print_status <icon> <message>
#
# Description:
#   Prints a formatted status message to the terminal, prefixed with an icon
#   and optionally a "DRY RUN" indicator if dry run mode is enabled.
#   Supports multi-line messages, optional leading pipe ('|') for indentation,
#   and trims leading whitespace for clean output. The prefix is shown only
#   on the first non-empty line, subsequent lines are indented for readability.
#
# Arguments:
#   $1  status_icon     - Emoji or icon to prefix the message (optional, default: üêà)
#   $2  status_message  - Message string to print (optional, default: "Cat.")
#
# Environment Variables:
#   dry_run             - If set to "1", adds "(DRY RUN)" to the prefix.
#
# Logic:
#   - Determines prefix based on dry_run and icon.
#   - For each line in the message:
#       * If line starts with '|', removes it and prints with prefix.
#       * If line is empty, prints a blank line.
#       * Otherwise, trims leading whitespace and prints with prefix.
#       * Prefix is only shown on the first non-empty line.
#   - Handles multi-line and indented messages for improved readability.
#
# Output:
#   - Prints formatted status messages to stdout, suitable for user feedback,
#     error reporting, and progress indication.
#
# Example:
#   pihole_munin_print_status "‚úÖ" "Operation completed successfully."
#   pihole_munin_print_status "‚ö†Ô∏è" "|   Warning: Something may be wrong."
#   dry_run=1 pihole_munin_print_status "üõ†Ô∏è" "This is a dry run."
#
# Quirks:
#   - This horrible awk creature exists purely because I wanted to have nicely
#     formatted single and multi-line status messages without complex printf
#     invocations everywhere or ugly heredocs.
#
#     Clean code. Clean output. Clean mind.
#
#     Two out of three ain't bad.
#   - The leading pipe ('|') method for indentation is a personal preference.
#     It could be any other character or sequence. It just isn't.
#   - If for some reason someone ever copies this function elsewhere, firstly,
#       * Please reconsider your life choices, and secondly,
#       * Note that the prefix for subsequent lines in a multi-line status is
#         a single space and this needs to be taken into account if you are
#         adding indentation using the leading pipe ('|') method or there will
#         be an 'off by one' effect on the indentation.
#         If you want four spaces of indentation, use 3 spaces after the pipe,
#         if you want eight spaces, use 7 spaces after the pipe, etc.
#   - This infodoc header is long.
###############################################################################

pihole_munin_print_status() {
    dry_run="${dry_run:-"0"}"
    status_icon="${1:-"üêà"}"
    status_message="${2:-"Cat."}"
    printf "\n%b\n" "${status_message}" | awk -v icon="${status_icon}" -v dry_run="${dry_run}" '
    BEGIN {
        prefix = (dry_run == "0") ? " [" icon "] " : " [" icon "] (DRY RUN) "
        first = 1
    }
    {
        if ($0 ~ /^[[:space:]]*\|/) {
            sub(/^[[:space:]]*\|/, "")
            print prefix $0
        } else if ($0 == "") {
            print ""
        } else {
            sub(/^[[:space:]]+/, "")
            print prefix $0
        }
        if (first && $0 != "") {
            prefix = " "
            first = 0
        }
    }'
}

if [ "${PIHOLE_MUNIN_PRIVS_ELEVATED_BY_SUDO:-}" = "1" ]; then
    pihole_munin_print_status "‚úÖ" "Success."
    unset PIHOLE_MUNIN_PRIVS_ELEVATED_BY_SUDO
fi

###############################################################################
# Abort Handler
###############################################################################
# Usage:
#   pihole_munin_abort_handler
#
# Description:
#   Handles script termination on user interrupt (SIGINT/SIGTERM).
#   Cleans up terminal settings, prints an abort message, and exits with code 130.
#
# Logic:
#   - Calls pihole_munin_term_cleanup to restore terminal state.
#   - Prints a formatted abort message to stderr.
#   - Exits with code 130 to indicate script was aborted by user.
#
# Output:
#   - Restores terminal settings.
#   - Prints abort message to stderr.
#   - Exits with code 130.
###############################################################################

pihole_munin_abort_handler() {
    pihole_munin_term_cleanup
    pihole_munin_print_status "‚ùå" "${TEXT_RED}Execution of pihole_munin_ plugin aborted.${TEXT_RESET}" >&2
    exit 130
}

trap pihole_munin_abort_handler INT TERM

###############################################################################
# Lock File Setup
###############################################################################

pihole_munin_plugstate="${PIHOLE_MUNIN_PLUGSTATE:-${MUNIN_PLUGSTATE:-"/tmp"}}"
mkdir -p "${pihole_munin_plugstate}"

pihole_munin_lockfile="${pihole_munin_plugstate}/pihole_munin_${pihole_munin_plugin_id}.lock"

###############################################################################
# Lock Cleanup Helper
###############################################################################
# Usage:
#   pihole_munin_lock_cleanup
#
# Description:
#   Removes the plugin lock file if it exists, allowing subsequent plugin runs.
#   Typically called on script exit or signal to ensure stale locks are cleaned up.
#
# Logic:
#   - Checks if the lock file exists.
#   - Removes the lock file if present.
#
# Output:
#   - Lock file is deleted if it exists.
###############################################################################

pihole_munin_lock_cleanup() {
    [ -f "${pihole_munin_lockfile}" ] && rm -f "${pihole_munin_lockfile}"
}

###############################################################################
# Fuck You Shellcheck
###############################################################################
# Shellcheck seems to just give up parsing traps in arbirarily large scripts
# so we have to do this convince it that the functions are used actually used
#
# Fun Fact:
# Shellcheck will complain about *_lock_cleanup function never being invoked
# unless this list of functions is ordered in precisely this fashion and even
# looking at Shellcheck's source I have absolutely no idea why this happens.
###############################################################################

if [ "${__FUCK_YOU_SHELLCHECK:-}" = "1" ]; then
    pihole_munin_term_cleanup
    pihole_munin_lock_cleanup
    pihole_munin_abort_handler
fi

###############################################################################
# Lock File Mechanism
###############################################################################
# Ensures only one instance of a plugin runs at a time.
# Creates a lock file in the state directory and removes it on exit.
###############################################################################

case "$1" in
    ""|"fetch"|"config"|"autoconf")
        if [ -f "${pihole_munin_lockfile}" ]; then
            lock_pid=$(cat "${pihole_munin_lockfile}")
            if [ -n "${lock_pid}" ] && kill -0 "${lock_pid}" 2>/dev/null; then
                pihole_munin_print_status "‚ùå" "Another instance of the '${pihole_munin_plugin_id}' plugin is already running (PID: ${lock_pid})." >&2
                exit 1
            else
                rm -f "${pihole_munin_lockfile}"
            fi
        fi
        printf "%s\n" "$$" > "${pihole_munin_lockfile}"
        trap pihole_munin_lock_cleanup EXIT INT TERM
        ;;
esac

###############################################################################
# Password Selection Logic
###############################################################################
# Priority: app_password > pihole_password > CLI password file
################################################################################

if [ -n "${app_password+x}" ]; then
    password_to_use="${app_password}"
    password_set="1"
elif [ -n "${pihole_password+set}" ]; then
    case "${pihole_password}" in
        "nopassword"|"none"|"null")
            password_to_use=""
            password_set="1"
            ;;
        "")
            pihole_munin_print_status "‚ùå" "Pi-hole password is blank." >&2
            pihole_munin_print_status "‚ÑπÔ∏è" \
                "Please set the 'pihole_password' variable to a valid password, or set
                it to one of 'nopassword', 'none' or 'null' if your Pi-hole password
                is intentionally blank."
            exit 1
            ;;
        *)
            password_to_use="${pihole_password}"
            password_set="1"
            ;;
    esac
else
    host_normalised=$(printf '%s' "$host" | tr '[:upper:]' '[:lower:]')
    case "${host_normalised}" in
        "127.0.0.1"|"localhost"|"localhost.localdomain"|"::1"|"ip6-localhost"|"ip6-loopback")
            is_localhost="1"
            ;;
    esac
    if [ -r "${cli_password}" ]; then
        if [ -s "${cli_password}" ]; then
            password_to_use=$(cat "${cli_password}")
            password_set="1"
        fi
    fi
fi

###############################################################################
# Munin Field Output Helper
###############################################################################
# Usage:
#   pihole_munin_print <key> <colour> <crit> <draw> <graph> <info> <label> <max> <min> <type> <warn>
#
# Description:
#   Outputs Munin field configuration lines for a single metric key, validating
#   and formatting each attribute as required by Munin's plugin protocol.
#   This function is used to generate the config output for each field in a
#   Munin graph, supporting customisation via environment variables.
#
# Arguments:
#   $1  key_val     - Field name (alphanumeric/underscore, required)
#   $2  colour_val  - Hex colour code (3/6 digits, optional)
#   $3  crit_val    - Critical threshold (number or range, optional)
#   $4  draw_val    - Draw style (LINE[n], AREA, STACK, etc., optional)
#   $5  graph_val   - Graph flag ("yes"/"no", optional)
#   $6  info_val    - Info string (tooltip, optional)
#   $7  label_val   - Label (legend, required, max 19 chars, no '#' or '\')
#   $8  max_val     - Maximum value (number, optional)
#   $9  min_val     - Minimum value (number, optional)
#   $10 type_val    - Data type (DERIVE, GAUGE, COUNTER, ABSOLUTE, optional)
#   $11 warn_val    - Warning threshold (number or range, optional)
#
# Validation:
#   - key_val must match ^[a-zA-Z_][a-zA-Z0-9_]*$
#   - label_val must not be empty, contain '#' or '\', and is truncated to 19 chars
#   - colour_val accepts 3/6 digit hex (with/without '#'), expands 3 digits to 6
#   - crit_val and warn_val accept single value or colon-separated range
#   - draw_val must match Munin draw styles
#   - graph_val must be "yes" or "no"
#   - type_val must be one of DERIVE, GAUGE, COUNTER, ABSOLUTE
#   - max_val and min_val must be numeric
#
# Output:
#   Prints Munin config lines for each valid attribute, e.g.:
#     <key>.colour <hex>
#     <key>.critical <crit>
#     <key>.draw <draw>
#     <key>.graph <yes|no>
#     <key>.info <info>
#     <key>.label <label>
#     <key>.max <max>
#     <key>.min <min>
#     <key>.type <type>
#     <key>.warning <warn>
#
#   Invalid or missing required arguments cause an error and exit.
###############################################################################

pihole_munin_print() {
    key_val="${1}"
    colour_val="${2}"
    crit_val="${3}"
    draw_val="${4}"
    graph_val="${5}"
    info_val="${6}"
    label_val="${7}"
    max_val="${8}"
    min_val="${9}"
    type_val="${10}"
    warn_val="${11}"
    if ! printf %s "${key_val}" | grep -Eq '^[a-zA-Z_][a-zA-Z0-9_]*$'; then
        pihole_munin_print_status "‚ùå" "Invalid or missing key." >&2
        exit 1
    fi
    if [ -z "${label_val}" ] || printf %s "${label_val}" | grep -q '[#\\]'; then
        pihole_munin_print_status "‚ùå" "Invalid or missing label for key '${key_val}'." >&2
        exit 1
    fi
    if [ -n "${colour_val}" ] && [ -n "$(printf '%s' "${colour_val}" | tr -d '[:space:]')" ]; then
        colour_val="${colour_val#\#}"
        if printf %s "${colour_val}" | grep -Eq '^[0-9A-Fa-f]{3}$'; then
            r=$(printf %s "${colour_val}" | cut -c1)
            g=$(printf %s "${colour_val}" | cut -c2)
            b=$(printf %s "${colour_val}" | cut -c3)
            colour_val="${r}${r}${g}${g}${b}${b}"
        fi
        if printf %s "${colour_val}" | grep -Eq '^[0-9A-Fa-f]{6}$'; then
            printf "%s.colour %s\n" "${key_val}" "${colour_val}"
        fi
    fi
    if [ -n "${crit_val}" ] && [ -n "$(printf '%s' "${crit_val}" | tr -d '[:space:]')" ]; then
        if printf %s "${crit_val}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)?(:(-?[0-9]+(\.[0-9]*)?)?)?$|^(-?[0-9]+(\.[0-9]*)?):$'; then
            printf "%s.critical %s\n" "${key_val}" "${crit_val}"
        fi
    fi
    if [ -n "${draw_val}" ] && [ -n "$(printf '%s' "${draw_val}" | tr -d '[:space:]')" ]; then
        if printf %s "${draw_val}" | grep -Eq '^LINE[0-9]*$|^AREA$|^STACK$|^AREASTACK$|^LINESTACK[0-9]*$'; then
            printf "%s.draw %s\n" "${key_val}" "${draw_val}"
        fi
    fi
    if [ -n "${graph_val}" ] && [ -n "$(printf '%s' "${graph_val}" | tr -d '[:space:]')" ]; then
        case "${graph_val}" in
            "yes"|"no") printf "%s.graph %s\n" "${key_val}" "${graph_val}" ;;
        esac
    fi
    if [ -n "${info_val}" ] && [ -n "$(printf '%s' "${info_val}" | tr -d '[:space:]')" ]; then
        printf "%s.info %s\n" "${key_val}" "${info_val}"
    fi
    if [ "${#label_val}" -gt 19 ]; then
        label_val="$(printf "%s" "${label_val}" | cut -c1-16)..."
    fi
    printf "%s.label %s\n" "${key_val}" "${label_val}"
    if [ -n "${max_val}" ] && [ -n "$(printf '%s' "${max_val}" | tr -d '[:space:]')" ]; then
        if printf %s "${max_val}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)$'; then
            printf "%s.max %s\n" "${key_val}" "${max_val}"
        fi
    fi
    if [ -n "${min_val}" ] && [ -n "$(printf '%s' "${min_val}" | tr -d '[:space:]')" ]; then
        if printf %s "${min_val}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)$'; then
            printf "%s.min %s\n" "${key_val}" "${min_val}"
        fi
    fi
    if [ -n "${type_val}" ] && [ -n "$(printf '%s' "${type_val}" | tr -d '[:space:]')" ]; then
        case "${type_val}" in
            "DERIVE"|"GAUGE"|"COUNTER"|"ABSOLUTE")
                printf "%s.type %s\n" "${key_val}" "${type_val}"
                ;;
        esac
    fi
    if [ -n "${warn_val}" ] && [ -n "$(printf '%s' "${warn_val}" | tr -d '[:space:]')" ]; then
        if printf %s "${warn_val}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)?(:(-?[0-9]+(\.[0-9]*)?)?)?$|^(-?[0-9]+(\.[0-9]*)?):$'; then
            printf "%s.warning %s\n" "${key_val}" "${warn_val}"
        fi
    fi
}

###############################################################################
# API Endpoint Setup
###############################################################################

proto="${proto:-"http"}"
port="${port:-"80"}"
api="${api:-"/api"}"

api_target="${proto}://${host}:${port}${api}"
auth_url="${auth_url:-"/auth"}"

if [ -n "${proto+x}" ]; then
    proto_normalised=$(printf '%s' "${proto}" | tr '[:upper:]' '[:lower:]')
    case "${proto_normalised}" in
        "http"|"https") proto="${proto_normalised}" ;;
        *)
            pihole_munin_print_status "‚ùå" "Invalid protocol specified in 'proto' variable: '${proto}'." >&2
            pihole_munin_print_status "‚ÑπÔ∏è" "Please set 'proto' to either 'http' or 'https'."
            exit 1
            ;;
    esac
else
    proto="http"
fi

###############################################################################
# Authentication State Variables
###############################################################################

auth_required="1"
already_authed="0"

###############################################################################
# Session and State Variables
###############################################################################

session_cache="${session_cache:-"0"}"
seconds_timestamp=$(date +%s)

###############################################################################
# Authentication Check Function
###############################################################################
# Usage:
#   pihole_munin_auth_check
#
# Description:
#   Determines if authentication is required for the Pi-hole API by sending a
#   request to the authentication endpoint. Parses the HTTP response code and
#   checks the session validity in the JSON response. Sets the global flags
#   'auth_required' and 'already_authed' accordingly.
#
# Logic:
#   - Sends a GET request to the API authentication endpoint.
#   - Parses the response code:
#       * 200: Checks if '.session.valid == true' in the JSON body.
#              If valid, sets 'auth_required=0' and 'already_authed=1'.
#       * 401: Indicates authentication is required; leaves flags unchanged.
#       * Other: Prints error and exits.
#
# Output:
#   - Sets 'auth_required' and 'already_authed' global variables.
#   - Prints error and exits on unexpected response codes.
###############################################################################

pihole_munin_auth_check() {
    check_response=$(curl --connect-timeout 5 -k -s -S -L -w "%{response_code}" "${api_target}${auth_url}")
    check_json=$(printf "%s" "${check_response}" | head -c -3)
    check_code=$(printf "%s" "${check_response}" | tail -c 3)
    case "${check_code}" in
        "200")
            if printf "%s" "${check_json}" | jq -e '.session.valid == true' >/dev/null 2>&1; then
                auth_required="0"
                already_authed="1"
            fi
            ;;
        "401") : ;;
        *)
            pihole_munin_print_status "‚ùå" "Authentication check failed, response code was '${check_code}'." >&2
            exit 1
            ;;
    esac
}

###############################################################################
# Authentication Check Function
###############################################################################
# Usage:
#   pihole_munin_auth_check
#
# Description:
#   Determines if authentication is required for the Pi-hole API by sending a
#   request to the authentication endpoint. Parses the HTTP response code and
#   checks the session validity in the JSON response. Sets the global flags
#   'auth_required' and 'already_authed' accordingly.
#
# Logic:
#   - Sends a GET request to the API authentication endpoint.
#   - Parses the response code:
#       * 200: Checks if '.session.valid == true' in the JSON body.
#              If valid, sets 'auth_required=0' and 'already_authed=1'.
#       * 401: Indicates authentication is required; leaves flags unchanged.
#       * Other: Prints error and exits.
#
# Output:
#   - Sets 'auth_required' and 'already_authed' global variables.
#   - Prints error and exits on unexpected response codes.
###############################################################################

pihole_munin_auth() {
    pihole_munin_session_file="${pihole_munin_plugstate}/pihole_munin_session.state"
    if [ "${session_cache}" -eq 1 ] && [ -r "${pihole_munin_session_file}" ]; then
        session_time=$(head -n 1 "${pihole_munin_session_file}")
        if [ $((seconds_timestamp - session_time)) -lt "${session_ttl:-"300"}" ]; then
            pihole_munin_session_sid=$(tail -n 1 "${pihole_munin_session_file}")
            return 0
        fi
    fi
    if [ "${password_set}" -ne 1 ]; then
        pihole_munin_print_status "‚ùå" "No password set for API authentication." >&2
        exit 1
    fi
    auth_response=$(curl --connect-timeout 5 -k -s -S -L -o - -w "%{response_code}" "${api_target}${auth_url}" -d "{\"password\":\"${password_to_use}\"}")
    auth_response_json=$(printf "%s" "${auth_response}" | head -c -3)
    auth_response_code=$(printf "%s" "${auth_response}" | tail -c 3)
    if [ "${auth_response_code}" -ne 200 ]; then
        pihole_munin_print_status "‚ùå" "Authentication failed, response code was '${auth_response_code}'." >&2
        exit 1
    fi
    pihole_munin_session_sid=$(printf "%s" "${auth_response_json}" | jq -r '.session.sid')
    if [ -n "${pihole_munin_session_sid}" ] && [ "${session_cache}" -eq 1 ]; then
        { printf "%s\n%s\n" "${seconds_timestamp}" "${pihole_munin_session_sid}"; } > "${pihole_munin_session_file}"
        chmod 600 "${pihole_munin_session_file}"
    fi
}

###############################################################################
# Logout Function
###############################################################################
# Usage:
#   pihole_munin_logout
#
# Description:
#   Logs out the current Pi-hole API session by sending a DELETE request to the
#   authentication endpoint. Skips logout if session caching is enabled or no
#   session is active.
#
# Logic:
#   - If no session ID or session caching is enabled, does nothing.
#   - Sends DELETE request to API to invalidate the session.
#   - Checks response code for success (200/204).
#   - Prints error and exits if logout fails.
#
# Output:
#   - Invalidates the current session if applicable.
#   - Exits with error if logout fails.
###############################################################################

pihole_munin_logout() {
    [ -z "${pihole_munin_session_sid}" ] && return 0
    [ "${session_cache}" -eq 1 ] && return 0
    logout_code=$(curl --connect-timeout 5 -k -s -S -L -o - \
        -w "%{response_code}" \
        -X DELETE "${api_target}${auth_url}" \
        -H "Accept: application/json" \
        -H "sid: ${pihole_munin_session_sid}")
    case "${logout_code}" in
        "200"|"204") : ;;
        *)
            pihole_munin_print_status "‚ùå" "Logout failed, response code was '${logout_code}'." >&2
            exit 1
            ;;
    esac
}

###############################################################################
# Safe Variable Evaluation Helper
###############################################################################
# Usage:
#   pihole_munin_safe_eval <outvar> <prefix> <field> <suffix> <default>
#
# Description:
#   Safely evaluates and sets a variable value from dynamically constructed
#   variable names, supporting plugin-specific overrides and caching.
#   If the constructed variable is unset or invalid, sets the output variable
#   to the provided default value. Caches results for efficiency.
#
# Arguments:
#   $1  outvar   - Name of output variable to set
#   $2  prefix   - Prefix for variable name construction (e.g. "cache_")
#   $3  field    - Main variable key (e.g. "evicted")
#   $4  suffix   - Suffix for variable name construction (e.g. "_crit")
#   $5  default  - Default value if variable is unset or invalid
#
# Logic:
#   - If field is empty or contains invalid characters, sets output to default.
#   - Constructs variable name as <prefix><field><suffix>.
#   - Checks for cached value (_cache_<varname>); uses it if present.
#   - Otherwise, sets output to value of constructed variable or default,
#     and caches the result.
#
# Output:
#   - Sets <outvar> to the resolved value or default.
###############################################################################

pihole_munin_safe_eval() {
    safe_eval_outvar="${1}"
    safe_eval_prefix="${2}"
    safe_eval_field="${3}"
    safe_eval_suffix="${4}"
    safe_eval_default="${5}"
    : "${safe_eval_default:=}"
    case "${safe_eval_field}" in
        ''|*[!a-zA-Z0-9_]*)
            eval "${safe_eval_outvar}=\"\${safe_eval_default}\""
            return
            ;;
    esac
    varname="${safe_eval_prefix}${safe_eval_field}${safe_eval_suffix}"
    cachevar="_cache_${varname}"
    eval "if [ \"\${${cachevar}+x}\" = x ]; then ${safe_eval_outvar}=\"\${${cachevar}}\"; return; fi"
    eval "__pihole_munin_tmp_val__=\"\${${varname}:-\${safe_eval_default}}\""
    eval "${cachevar}=\"\${__pihole_munin_tmp_val__}\""
    eval "${safe_eval_outvar}=\"\${__pihole_munin_tmp_val__}\""
}

###############################################################################
# JSON Validation Helper
###############################################################################
# Usage:
#   pihole_munin_validate_json
#
# Description:
#   Checks if the input from stdin is valid JSON using jq.
#   Returns success (0) if valid, non-zero if invalid.
#
# Logic:
#   - Runs 'jq empty' on stdin, suppressing output.
#   - Returns 0 if input is valid JSON, else non-zero.
#
# Output:
#   - Exit status: 0 if valid JSON, non-zero otherwise.
###############################################################################

pihole_munin_validate_json() {
    jq empty >/dev/null 2>&1
}

###############################################################################
# State Handler
###############################################################################
# Usage:
#   pihole_munin_state_handler <endpoint>
#
# Description:
#   Handles caching of API responses to disk for a given endpoint, reducing
#   redundant API calls and improving efficiency. Validates cached responses
#   as JSON and supports plugin-specific TTL overrides. If the cache is stale
#   or invalid, fetches a fresh response from the API, saves it, and returns it.
#
# Arguments:
#   $1  endpoint   - API endpoint to fetch and cache (e.g. "/info/metrics")
#
# Logic:
#   - Builds a sanitized state file path for the endpoint.
#   - If a valid cache file exists and is within TTL, returns cached JSON.
#   - If cache is stale or invalid, removes it and fetches fresh data.
#   - Handles authentication if required.
#   - Validates API response as JSON before caching.
#   - Saves new response to state file and returns it.
#   - Logs out if authentication was performed and session caching is disabled.
#
# Output:
#   - Prints valid JSON response for the endpoint.
#   - Returns non-zero on error or invalid response.
###############################################################################

pihole_munin_state_handler() {
    pihole_munin_statefile="${pihole_munin_plugstate}/pihole_munin_$(printf "%s" "${1}" \
        | sed -E 's/[^a-zA-Z0-9]+/_/g; s/^_+//; s/_+$//; s/_+/_/g').state"
    if [ -f "${pihole_munin_statefile}" ]; then
        state_time=$(head -n 1 "${pihole_munin_statefile}")
        state_ttl="${state_ttl:-"240"}"
        pihole_munin_safe_eval state_ttl "" "${pihole_munin_plugin_id}_state_ttl" "" "${state_ttl}"
        if [ $((seconds_timestamp - state_time)) -lt "${state_ttl}" ]; then
            cached_response=$(tail -n +2 "${pihole_munin_statefile}")
            if printf "%s" "${cached_response}" | pihole_munin_validate_json; then
                printf "%s\n" "${cached_response}"
                return
            else
                rm -f "${pihole_munin_statefile}"
            fi
        fi
    fi
    did_auth="0"
    pihole_munin_auth_check
    if [ "${auth_required}" -eq 1 ] && [ "${already_authed}" -eq 0 ]; then
        pihole_munin_auth
        did_auth="1"
    fi
    response=$(curl --connect-timeout 5 -G -k -s -L \
                    -H "sid: ${pihole_munin_session_sid}" \
                    "${api_target}${1}") || exit 1
    if ! printf "%s" "${response}" | pihole_munin_validate_json; then
        return 1
    fi
    {
        printf "%s\n" \
            "${seconds_timestamp}" \
            "${response}"
    } | tee "${pihole_munin_statefile}" | tail -n +2
    if [ "${auth_required}" -eq 1 ] && [ "${did_auth}" -eq 1 ] && [ "${session_cache}" -ne 1 ]; then
        pihole_munin_logout
    fi
}

###############################################################################
# API Endpoint Variables
###############################################################################

dns_blocking_url="${dns_blocking_url:-"/dns/blocking"}"
info_ftl_url="${info_ftl_url:-/info/ftl}"
info_metrics_url="${info_metrics_url:-"/info/metrics"}"
info_version_url="${info_version_url:-"/info/version"}"
stats_query_types_url="${stats_query_types_url:-"/stats/query_types"}"
stats_summary_url="${stats_summary_url:-"/stats/summary"}"
stats_top_clients_url="${stats_top_clients_url:-"/stats/top_clients"}"
stats_top_domains_url="${stats_top_domains_url:-"/stats/top_domains"}"
stats_upstreams_url="${stats_upstreams_url:-"/stats/upstreams"}"

###############################################################################
# Graph Configuration Variables
###############################################################################

graph="${graph:-"yes"}"
graph_args="${graph_args:-"--lower-limit 0"}"
graph_category="${graph_category:-"dns"}"
graph_draw="${graph_draw:-"LINE1"}"
graph_height="${graph_height:-"200"}"
graph_scale="${graph_scale:-"no"}"
graph_type="${graph_type:-"DERIVE"}"
graph_width="${graph_width:-"400"}"

###############################################################################
# Graph Zero Helper
###############################################################################
# Usage:
#   pihole_munin_graph_zero <key>
#
# Description:
#   Determines whether zero values should be graphed for a given key in Munin.
#   Checks for a plugin-specific override (graph_zero_<key>), falling back to
#   the global graph_zero setting if not set. Returns success (0) if enabled,
#   otherwise failure (1).
#
# Arguments:
#   $1  key   - The graph key to check for zeroing (e.g. "cache", "clients")
#
# Logic:
#   - Checks for plugin-specific graph_zero override using safe_eval.
#   - If set to "yes", returns 0 (true); otherwise returns 1 (false).
#   - If not set, falls back to global graph_zero variable.
#
# Output:
#   - Returns 0 if zero values should be graphed for the key, else 1.
###############################################################################

pihole_munin_graph_zero() {
    _graph_zero_key="${1}"
    _graph_zero_result=""
    pihole_munin_safe_eval _graph_zero_result "" "graph_zero" "_${_graph_zero_key}" ""
    if [ -n "${_graph_zero_result}" ]; then
        [ "${_graph_zero_result}" = "yes" ] && return 0 || return 1
    fi
    [ "${graph_zero:-"yes"}" = "yes" ]
}

###############################################################################
# Cache Graph Configuration
###############################################################################

pihole_munin_config_cache() {
    graph_type_cache="${graph_type_cache:-"${graph_type}"}"
    if [ "${graph_type_cache}" = "DERIVE" ]; then
        cache_vlabel="resource records / second"
    else
        cache_vlabel="resource records"
    fi
    printf "%s\n" \
        "graph ${graph_cache:-${graph}}" \
        "graph_args ${graph_args_cache:-${graph_args}}" \
        "graph_category ${graph_category_cache:-${graph_category}}" \
        "graph_height ${graph_height_cache:-${graph_height}}" \
        "graph_info ${graph_info_cache:-"pihole-FTL offers an efficient DNS cache that helps speed up your Internet experience. This DNS cache is part of the embedded dnsmasq server. Setting the cache size to zero (dns.cache.size = 0) disables caching. The DNS TTL value is used for determining the caching period. pihole-FTL clears its cache on receiving SIGHUP. The cache is not persistent across restarts. Visit <a href=\"https://docs.pi-hole.net/ftldns/dns-cache/\">https://docs.pi-hole.net/ftldns/dns-cache/</a> for more information"}" \
        "graph_scale ${graph_scale_cache:-${graph_scale}}" \
        "graph_title ${graph_title_cache:-"Pi-hole cache"}" \
        "graph_vlabel ${graph_vlabel_cache:-${cache_vlabel}}" \
        "graph_width ${graph_width_cache:-${graph_width}}"
    cache_response=$(pihole_munin_state_handler "${info_metrics_url}") || exit 1
    for cache_key in "evicted" "expired" "immortal" "inserted"; do
        cache_value=$(printf '%s' "${cache_response}" | jq -r --arg k "${cache_key}" '.metrics.dns.cache[$k] // 0')
        if pihole_munin_graph_zero "cache" || [ "${cache_value}" -ne 0 ]; then
            pihole_munin_safe_eval cache_colour "cache_" "${cache_key}" "_colour" ""
            pihole_munin_safe_eval cache_crit "cache_" "${cache_key}" "_crit" ""
            pihole_munin_safe_eval cache_draw "cache_" "${cache_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval cache_graph "cache_" "${cache_key}" "_graph" "yes"
            pihole_munin_safe_eval cache_type "cache_" "${cache_key}" "_type" "${graph_type_cache}"
            case "${cache_key}" in
                "evicted")
                    cache_doc_info="DNS cache evictions"
                    cache_doc_text="The number of cache entries that had to be \
                    removed although the corresponding entries were not expired. \
                    Old cache entries get removed if the cache is full to make \
                    space for more recent domains. The cache size should be \
                    increased when this number is larger than zero. Optimizing \
                    your cache settings is crucial for maintaining optimal \
                    performance and resource utilization. It is advisable to \
                    regularly check for evictions to ensure your DNS cache \
                    operates effectively. This information may also be queried \
                    using dig +short chaos txt evictions.bind"
                    ;;
                "expired")
                    cache_doc_info="Expired cache entries"
                    cache_doc_text="The number of cache entries that have expired. \
                    These queries may be served from the cache if the query cache \
                    optimizer is enabled and the cache entry is not too old when \
                    the query is made. The number of expired entries is part of \
                    the active cache records if the query optimizer is enabled."
                    ;;
                "immortal")
                    cache_doc_info="Immortal cache entries"
                    cache_doc_text="The number of cache entries that have been \
                    marked as immortal. These entries will never expire. As \
                    such, they are part of the active cache entries. Examples \
                    of immortal cache entries are those coming from the local \
                    hosts file (e.g., /etc/hosts) and local DNS records."
                    ;;
                "inserted")
                    cache_doc_info="Total cache insertions"
                    cache_doc_text="Number of total insertions into the cache. \
                    This number can be substantially larger than DNS cache size \
                    as expiring cache entries naturally make room for new \
                    insertions over time. Each lookup with a non-zero TTL will \
                    be cached. This information may also be queried using dig \
                    +short chaos txt insertions.bind"
                    ;;
            esac
            if [ "${graph_type_cache:-${cache_type}}" = "DERIVE" ]; then
                plural="records"
                if [ "${cache_value}" -eq 1 ]; then
                    plural="record"
                fi
                cache_info="$(printf "%s" "${cache_doc_info} (${cache_value} ${plural}) ${cache_doc_text}" | tr '\n' ' ' | sed 's/  */ /g')"
            else
                pihole_munin_safe_eval cache_info "cache_" "${cache_key}" "_info" "$(printf "%s" "${cache_doc_info} ${cache_doc_text}" | tr '\n' ' ' | sed 's/  */ /g')"
            fi
            pihole_munin_safe_eval cache_label "cache_" "${cache_key}" "_label" "${cache_key}"
            pihole_munin_safe_eval cache_max "cache_" "${cache_key}" "_max" ""
            pihole_munin_safe_eval cache_min "cache_" "${cache_key}" "_min" "0"
            pihole_munin_safe_eval cache_warn "cache_" "${cache_key}" "_warn" ""
            pihole_munin_print \
                "${cache_key}" \
                "${cache_colour:-}" \
                "${cache_crit:-}" \
                "${cache_draw:-}" \
                "${cache_graph:-}" \
                "${cache_info:-}" \
                "${cache_label:-}" \
                "${cache_max:-}" \
                "${cache_min:-}" \
                "${cache_type:-}" \
                "${cache_warn:-}"
        fi
    done
}

###############################################################################
# Cache by Type Graph Configuration
###############################################################################

pihole_munin_config_cache_by_type() {
    graph_type_cache_by_type="${graph_type_cache_by_type:-"${graph_type}"}"
    if [ "${graph_type_cache_by_type}" = "DERIVE" ]; then
        cache_by_type_vlabel="resource records / second"
    else
        cache_by_type_vlabel="resource records"
    fi
    cache_by_type_response=$(pihole_munin_state_handler "${info_metrics_url}") || exit 1
    cache_by_type_fields_output="$(
        printf "%s" "${cache_by_type_response}" | jq -c '.metrics.dns.cache.content[]' \
        | while read -r cache_by_type_entry; do
            cache_by_type_name=$(printf '%s' "${cache_by_type_entry}" | jq -r '.name')
            cache_by_type_valid=$(printf '%s' "${cache_by_type_entry}" | jq -r '.count.valid')
            cache_by_type_stale=$(printf '%s' "${cache_by_type_entry}" | jq -r '.count.stale')
            for cache_by_type_entry in "valid" "stale"; do
                case "${cache_by_type_entry}" in
                    "valid")
                        cache_by_type_key="${cache_by_type_name}"
                        cache_by_type_default_label="${cache_by_type_name}"
                        cache_by_type_value="${cache_by_type_valid}"
                        ;;
                    "stale")
                        cache_by_type_key="${cache_by_type_name}_STALE"
                        cache_by_type_default_label="${cache_by_type_name} (stale)"
                        cache_by_type_value="${cache_by_type_stale}"
                        ;;
                esac
                if pihole_munin_graph_zero "cache_by_type" || [ "${cache_by_type_value}" -ne 0 ]; then
                    pihole_munin_safe_eval cache_by_type_colour "cache_by_type_" "${cache_by_type_key}" "_colour" ""
                    pihole_munin_safe_eval cache_by_type_crit "cache_by_type_" "${cache_by_type_key}" "_crit" ""
                    pihole_munin_safe_eval cache_by_type_draw "cache_by_type_" "${cache_by_type_key}" "_draw" "${graph_draw}"
                    pihole_munin_safe_eval cache_by_type_graph "cache_by_type_" "${cache_by_type_key}" "_graph" "yes"
                    pihole_munin_safe_eval cache_by_type_type "cache_by_type_" "${cache_by_type_key}" "_type" "${graph_type_cache_by_type}"
                    if [ "${graph_type_cache_by_type:-${cache_by_type_type}}" = "DERIVE" ]; then
                        plural="records"
                        if [ "${cache_by_type_value}" -eq 1 ]; then
                            plural="record"
                        fi
                        cache_by_type_info="Pi-hole cache type ${cache_by_type_default_label} (${cache_by_type_value} ${plural})"
                    else
                        pihole_munin_safe_eval cache_by_type_info "cache_by_type_" "${cache_by_type_key}" "_info" "Pi-hole cache type ${cache_by_type_default_label}"
                    fi
                    pihole_munin_safe_eval cache_by_type_label "cache_by_type_" "${cache_by_type_key}" "_label" "${cache_by_type_default_label}"
                    pihole_munin_safe_eval cache_by_type_max "cache_by_type_" "${cache_by_type_key}" "_max" ""
                    pihole_munin_safe_eval cache_by_type_min "cache_by_type_" "${cache_by_type_key}" "_min" "0"
                    pihole_munin_safe_eval cache_by_type_warn "cache_by_type_" "${cache_by_type_key}" "_warn" ""
                    pihole_munin_print \
                        "${cache_by_type_key}" \
                        "${cache_by_type_colour:-}" \
                        "${cache_by_type_crit:-}" \
                        "${cache_by_type_draw:-}" \
                        "${cache_by_type_graph:-}" \
                        "${cache_by_type_info:-}" \
                        "${cache_by_type_label:-}" \
                        "${cache_by_type_max:-}" \
                        "${cache_by_type_min:-}" \
                        "${cache_by_type_type:-}" \
                        "${cache_by_type_warn:-}"
                fi
            done
        done || true
    )"
    num_fields=$(printf "%s\n" "${cache_by_type_fields_output}" | grep -c '\.label ')
    if [ "${graph_total_cache_by_type:-"total"}" != "undef" ] && [ "${num_fields}" -ge 2 ]; then
        print_total_line="graph_total ${graph_total_cache_by_type:-"total"}"
    else
        print_total_line=""
    fi
    printf "%s\n" \
        "graph ${graph_cache_by_type:-${graph}}" \
        "graph_args ${graph_args_cache_by_type:-${graph_args}}" \
        "graph_category ${graph_category_cache_by_type:-${graph_category}}" \
        "graph_height ${graph_height_cache_by_type:-${graph_height}}" \
        "graph_info ${graph_info_cache_by_type:-"This graph shows Pi-hole's cached records by type"}" \
        "graph_scale ${graph_scale_cache_by_type:-${graph_scale}}" \
        "graph_title ${graph_title_cache_by_type:-"Pi-hole cache by type"}" \
        "${print_total_line}" \
        "graph_vlabel ${graph_vlabel_cache_by_type:-${cache_by_type_vlabel}}" \
        "graph_width ${graph_width_cache_by_type:-${graph_width}}"
    if [ -n "${cache_by_type_fields_output}" ]; then
        printf "%s\n" "${cache_by_type_fields_output}"
    else
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No cache types" \
            "none" \
            "" \
            "0" \
            "${graph_type_cache_by_type}" \
            ""
    fi
}

###############################################################################
# Top N Limit Enforcement
###############################################################################
# Enforce sensible limits on number of top clients/domains to fetch and display
# (default: 25, min: 1, max: 100)
################################################################################

top_n="${top_n:-"25"}"
if [ "${top_n}" -gt 100 ]; then
    top_n="100";
elif [ "${top_n}" -lt 1 ]; then
    top_n="1";
fi

top_clients_n="${top_clients_top_n:-${top_n}}"
if [ "${top_clients_n}" -gt 100 ]; then
    top_clients_n="100";
elif [ "${top_clients_n}" -lt 1 ]; then
    top_clients_n="1";
fi

top_domains_n="${top_domains_top_n:-${top_n}}"
if [ "${top_domains_n}" -gt 100 ]; then
    top_domains_n="100";
elif [ "${top_domains_n}" -lt 1 ]; then
    top_domains_n="1";
fi

###############################################################################
# Clients Graph Configuration
###############################################################################

pihole_munin_config_clients() {
    printf "%s\n" \
        "graph ${graph_clients:-${graph}}" \
        "graph_args ${graph_args_clients:-${graph_args}}" \
        "graph_category ${graph_category_clients:-${graph_category}}" \
        "graph_height ${graph_height_clients:-${graph_height}}" \
        "graph_info ${graph_info_clients:-"This graph shows Pi-hole's active and total clients"}" \
        "graph_scale ${graph_scale_clients:-${graph_scale}}" \
        "graph_title ${graph_title_clients:-"Pi-hole clients"}" \
        "graph_vlabel ${graph_vlabel_clients:-"clients"}" \
        "graph_width ${graph_width_clients:-${graph_width}}"
    clients_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    printf "%s" "${clients_response}" | jq -r '.clients | to_entries[] | "\(.key) \(.value)"' \
    | while read -r clients_key clients_value; do
        if pihole_munin_graph_zero "clients" || [ "${clients_value}" -ne 0 ]; then
            case "${clients_key}" in
                "active")
                    pihole_munin_print \
                        "${clients_key}" \
                        "${clients_active_colour:-}" \
                        "${clients_active_crit:-}" \
                        "${clients_active_draw:-${graph_draw}}" \
                        "${clients_active_graph:-"yes"}" \
                        "${clients_active_info:-"Pi-hole active clients"}" \
                        "${clients_active_label:-"${clients_key}"}" \
                        "${clients_active_max:-""}" \
                        "${clients_active_min:-"0"}" \
                        "${clients_active_type:-"GAUGE"}" \
                        "${clients_active_warn:-}"
                    ;;
                "total")
                    pihole_munin_print \
                        "${clients_key}" \
                        "${clients_total_colour:-}" \
                        "${clients_total_crit:-}" \
                        "${clients_total_draw:-${graph_draw}}" \
                        "${clients_total_graph:-"yes"}" \
                        "${clients_total_info:-"Pi-hole total clients"}" \
                        "${clients_total_label:-"${clients_key}"}" \
                        "${clients_total_max:-""}" \
                        "${clients_total_min:-"0"}" \
                        "${clients_total_type:-"GAUGE"}" \
                        "${clients_total_warn:-}"
                    ;;
            esac
        fi
    done
}

###############################################################################
# Dnsmasq Graph Configuration
###############################################################################

pihole_munin_config_dnsmasq() {
    printf "%s\n" \
        "graph ${graph_dnsmasq:-${graph}}" \
        "graph_args ${graph_args_dnsmasq:-${graph_args}}" \
        "graph_category ${graph_category_dnsmasq:-${graph_category}}" \
        "graph_height ${graph_height_dnsmasq:-${graph_height}}" \
        "graph_info ${graph_info_dnsmasq:-"This graph shows various Pi-hole dnsmasq statistics"}" \
        "graph_scale ${graph_scale_dnsmasq:-${graph_scale}}" \
        "graph_title ${graph_title_dnsmasq:-"Pi-hole dnsmasq"}" \
        "graph_vlabel ${graph_vlabel_dnsmasq:-"count"}" \
        "graph_width ${graph_width_dnsmasq:-${graph_width}}"
    dnsmasq_response=$(pihole_munin_state_handler "${info_ftl_url}") || exit 1
    printf "%s" "${dnsmasq_response}" | jq -r '.ftl.dnsmasq | to_entries[] | "\(.key) \(.value)"' \
    | while read -r dnsmasq_key dnsmasq_value; do
        default_label=$(printf "%s" "${dnsmasq_key}" | sed 's/_/ /g')
        if pihole_munin_graph_zero "dnsmasq" || [ "${dnsmasq_value}" -ne 0 ]; then
            pihole_munin_safe_eval dnsmasq_colour "dnsmasq_" "${dnsmasq_key}" "_colour" ""
            pihole_munin_safe_eval dnsmasq_crit "dnsmasq_" "${dnsmasq_key}" "_crit" ""
            pihole_munin_safe_eval dnsmasq_draw "dnsmasq_" "${dnsmasq_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval dnsmasq_graph "dnsmasq_" "${dnsmasq_key}" "_graph" "yes"
            pihole_munin_safe_eval dnsmasq_info "dnsmasq_" "${dnsmasq_key}" "_info" "Pi-hole dnsmasq ${default_label}"
            pihole_munin_safe_eval dnsmasq_label "dnsmasq_" "${dnsmasq_key}" "_label" "${default_label}"
            pihole_munin_safe_eval dnsmasq_max "dnsmasq_" "${dnsmasq_key}" "_max" ""
            pihole_munin_safe_eval dnsmasq_min "dnsmasq_" "${dnsmasq_key}" "_min" "0"
            pihole_munin_safe_eval dnsmasq_type "dnsmasq_" "${dnsmasq_key}" "_type" "${graph_type}"
            pihole_munin_safe_eval dnsmasq_warn "dnsmasq_" "${dnsmasq_key}" "_warn" ""
            pihole_munin_print \
                "${dnsmasq_key}" \
                "${dnsmasq_colour:-}" \
                "${dnsmasq_crit:-}" \
                "${dnsmasq_draw:-}" \
                "${dnsmasq_graph:-}" \
                "${dnsmasq_info:-}" \
                "${dnsmasq_label:-}" \
                "${dnsmasq_max:-}" \
                "${dnsmasq_min:-}" \
                "${dnsmasq_type:-}" \
                "${dnsmasq_warn:-}"
        fi
    done
}

###############################################################################
# Domains Graph Configuration
###############################################################################

pihole_munin_config_domains() {
    printf "%s\n" \
        "graph ${graph_domains:-${graph}}" \
        "graph_args ${graph_args_domains:-${graph_args}}" \
        "graph_category ${graph_category_domains:-${graph_category}}" \
        "graph_height ${graph_height_domains:-${graph_height}}" \
        "graph_info ${graph_info_domains:-"This graph shows Pi-hole's domains being blocked"}" \
        "graph_scale ${graph_scale_domains:-${graph_scale}}" \
        "graph_title ${graph_title_domains:-"Pi-hole domains being blocked"}" \
        "graph_vlabel ${graph_vlabel_domains:-"domains being blocked"}" \
        "graph_width ${graph_width_domains:-${graph_width}}"
    pihole_munin_print \
        "domains_being_blocked" \
        "${domains_domains_being_blocked_colour:-}" \
        "${domains_domains_being_blocked_crit:-}" \
        "${domains_domains_being_blocked_draw:-${graph_draw}}" \
        "${domains_domains_being_blocked_graph:-"yes"}" \
        "${domains_domains_being_blocked_info:-"Pi-hole domains being blocked"}" \
        "${domains_domains_being_blocked_label:-"domains being blocked"}" \
        "${domains_domains_being_blocked_max:-""}" \
        "${domains_domains_being_blocked_min:-"0"}" \
        "${domains_domains_being_blocked_type:-"GAUGE"}" \
        "${domains_domains_being_blocked_warn:-}"
}

###############################################################################
# Query Frequency Graph Configuration
###############################################################################

pihole_munin_config_frequency() {
    printf "%s\n" \
        "graph ${graph_frequency:-${graph}}" \
        "graph_args ${graph_args_frequency:-${graph_args}}" \
        "graph_category ${graph_category_frequency:-${graph_category}}" \
        "graph_height ${graph_height_frequency:-${graph_height}}" \
        "graph_info ${graph_info_frequency:-"This graph shows Pi-hole's query frequency"}" \
        "graph_scale ${graph_scale_frequency:-${graph_scale}}" \
        "graph_title ${graph_title_frequency:-"Pi-hole query frequency"}" \
        "graph_vlabel ${graph_vlabel_frequency:-"queries / second"}" \
        "graph_width ${graph_width_frequency:-${graph_width}}"
    pihole_munin_print \
        "frequency" \
        "${frequency_frequency_colour:-}" \
        "${frequency_frequency_crit:-}" \
        "${frequency_frequency_draw:-${graph_draw}}" \
        "${frequency_frequency_graph:-"yes"}" \
        "${frequency_frequency_info:-"Pi-hole query frequency (queries / second)"}" \
        "${frequency_frequency_label:-"frequency"}" \
        "${frequency_frequency_max:-}" \
        "${frequency_frequency_min:-"0"}" \
        "${frequency_frequency_type:-"GAUGE"}" \
        "${frequency_frequency_warn:-}"
}

###############################################################################
# Gravity Database Graph Configuration
###############################################################################

pihole_munin_config_gravity() {
    printf "%s\n" \
        "graph ${graph_gravity:-${graph}}" \
        "graph_args ${graph_args_gravity:-${graph_args}}" \
        "graph_category ${graph_category_gravity:-${graph_category}}" \
        "graph_height ${graph_height_gravity:-${graph_height}}" \
        "graph_info ${graph_info_gravity:-"This graph shows Pi-hole's gravity database statistics"}" \
        "graph_scale ${graph_scale_gravity:-${graph_scale}}" \
        "graph_title ${graph_title_gravity:-"Pi-hole gravity database"}" \
        "graph_vlabel ${graph_vlabel_gravity:-"count"}" \
        "graph_width ${graph_width_gravity:-${graph_width}}"
    gravity_response=$(pihole_munin_state_handler "${info_ftl_url}") || exit 1
    for gravity_key in \
        "domains_allowed" \
        "domains_denied" \
        "groups" \
        "lists" \
        "regex_allowed" \
        "regex_denied"; do
        default_label=$(printf '%s\n' "${gravity_key}" | sed 's/_/ /g')
        case "${gravity_key}" in
            "domains_"*) gravity_jq_key=".ftl.database.domains.${gravity_key#domains_}" ;;
            "regex_"*)   gravity_jq_key=".ftl.database.regex.${gravity_key#regex_}" ;;
            *)           gravity_jq_key=".ftl.database.${gravity_key}" ;;
        esac
        gravity_value=$(printf '%s' "${gravity_response}" | jq -r "${gravity_jq_key} // 0")
        if pihole_munin_graph_zero "gravity" || [ "${gravity_value}" -ne 0 ]; then
            pihole_munin_safe_eval gravity_colour "gravity_" "${gravity_key}" "_colour" ""
            pihole_munin_safe_eval gravity_crit "gravity_" "${gravity_key}" "_crit" ""
            pihole_munin_safe_eval gravity_draw "gravity_" "${gravity_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval gravity_graph "gravity_" "${gravity_key}" "_graph" "yes"
            pihole_munin_safe_eval gravity_info "gravity_" "${gravity_key}" "_info" "Pi-hole gravity ${default_label}"
            pihole_munin_safe_eval gravity_label "gravity_" "${gravity_key}" "_label" "${default_label}"
            pihole_munin_safe_eval gravity_max "gravity_" "${gravity_key}" "_max" ""
            pihole_munin_safe_eval gravity_min "gravity_" "${gravity_key}" "_min" "0"
            pihole_munin_safe_eval gravity_type "gravity_" "${gravity_key}" "_type" "GAUGE"
            pihole_munin_safe_eval gravity_warn "gravity_" "${gravity_key}" "_warn" ""
            pihole_munin_print \
                "${gravity_key}" \
                "${gravity_colour:-}" \
                "${gravity_crit:-}" \
                "${gravity_draw:-}" \
                "${gravity_graph:-}" \
                "${gravity_info:-}" \
                "${gravity_label:-}" \
                "${gravity_max:-}" \
                "${gravity_min:-}" \
                "${gravity_type:-}" \
                "${gravity_warn:-}"
        fi
    done
}

###############################################################################
# Overview Graph Configuration
###############################################################################

pihole_munin_config_overview() {
    graph_type_overview="${graph_type_overview:-"${graph_type}"}"
    if [ "${graph_type_overview}" = "DERIVE" ]; then
        overview_vlabel="queries in (-) | replies out (+) / second"
    else
        overview_vlabel="queries in (-) | replies out (+)"
    fi
    printf "%s\n" \
        "graph ${graph_overview:-${graph}}" \
        "graph_args ${graph_args_overview:-${graph_args}}" \
        "graph_category ${graph_category_overview:-${graph_category}}" \
        "graph_height ${graph_height_overview:-${graph_height}}" \
        "graph_info ${graph_info_overview:-"This graph shows an overview of Pi-hole's DNS traffic"}" \
        "graph_scale ${graph_scale_overview:-${graph_scale}}" \
        "graph_title ${graph_title_overview:-"Pi-hole overview"}" \
        "graph_vlabel ${graph_vlabel_overview:-${overview_vlabel}}" \
        "graph_width ${graph_width_overview:-${graph_width}}"
    overview_queries_by_type_response=$(pihole_munin_state_handler "${stats_query_types_url}" ) || exit 1
    overview_replies_by_type_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    overview_all_types=$(
        { printf '%s\n' "${overview_queries_by_type_response}" | jq -r '.types | keys_unsorted[]'; \
            printf '%s\n' "${overview_replies_by_type_response}" | jq -r '.queries.replies | keys_unsorted[]'; \
        } | sort -u
    )
    for overview_record_type in ${overview_all_types}; do
        overview_query_val=$(printf '%s\n' "${overview_queries_by_type_response}" | jq -r --arg k "${overview_record_type}" '.types[$k] // 0')
        overview_reply_val=$(printf '%s\n' "${overview_replies_by_type_response}" | jq -r --arg k "${overview_record_type}" '.queries.replies[$k] // 0')
        if pihole_munin_graph_zero "overview" || [ "${overview_query_val}" -ne 0 ] || [ "${overview_reply_val}" -ne 0 ]; then
            pihole_munin_safe_eval overview_colour "overview_" "${overview_record_type}" "_colour" ""
            pihole_munin_safe_eval overview_crit "overview_" "${overview_record_type}" "_crit" ""
            pihole_munin_safe_eval overview_draw "overview_" "${overview_record_type}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval overview_graph "overview_" "${overview_record_type}" "_graph" "yes"
            pihole_munin_safe_eval overview_type "overview_" "${overview_record_type}" "_type" "${graph_type_overview}"
            if [ "${graph_type_overview:-${overview_type}}" = "DERIVE" ]; then
                if [ "${overview_query_val}" -eq 1 ]; then
                    overview_queries_word="query"
                else
                    overview_queries_word="queries"
                fi
                if [ "${overview_reply_val}" -eq 1 ]; then
                    overview_replies_word="reply"
                else
                    overview_replies_word="replies"
                fi
                overview_info="Pi-hole overview ${overview_record_type} (${overview_query_val} ${overview_queries_word}, ${overview_reply_val} ${overview_replies_word})"
            else
                pihole_munin_safe_eval overview_info "overview_" "${overview_record_type}" "_info" "Pi-hole overview ${overview_record_type}"
            fi
            pihole_munin_safe_eval overview_label "overview_" "${overview_record_type}" "_label" "${overview_record_type}"
            pihole_munin_safe_eval overview_max "overview_" "${overview_record_type}" "_max" ""
            pihole_munin_safe_eval overview_min "overview_" "${overview_record_type}" "_min" "0"
            pihole_munin_safe_eval overview_warn "overview_" "${overview_record_type}" "_warn" ""
            pihole_munin_print \
                "query_${overview_record_type}" \
                "" \
                "${overview_crit:-}" \
                "${overview_draw:-}" \
                "no" \
                "" \
                "${overview_label:-}" \
                "${overview_max:-}" \
                "${overview_min:-}" \
                "${overview_type:-}" \
                "${overview_warn:-}"
            pihole_munin_print \
                "${overview_record_type}" \
                "${overview_colour:-}" \
                "${overview_crit:-}" \
                "${overview_draw:-}" \
                "${overview_graph:-}" \
                "${overview_info:-}" \
                "${overview_label:-}" \
                "${overview_max:-}" \
                "${overview_min:-}" \
                "${overview_type:-}" \
                "${overview_warn:-}"
            printf "%s.negative %s\n" "${overview_record_type}" "query_${overview_record_type}"
        fi
    done
}

###############################################################################
# Percent Blocked Graph Configuration
###############################################################################

pihole_munin_config_percent() {
    printf "%s\n" \
        "graph ${graph_percent:-${graph}}" \
        "graph_args ${graph_args_percent:-"--lower-limit 0 --slope-mode --upper-limit 100"}" \
        "graph_category ${graph_category_percent:-${graph_category}}" \
        "graph_height ${graph_height_percent:-${graph_height}}" \
        "graph_info ${graph_info_percent:-"This graph shows Pi-hole's blocked query percentage"}" \
        "graph_scale ${graph_scale_percent:-${graph_scale}}" \
        "graph_title ${graph_title_percent:-"Pi-hole percent blocked"}" \
        "graph_vlabel ${graph_vlabel_percent:-"percent blocked"}" \
        "graph_width ${graph_width_percent:-${graph_width}}"
    pihole_munin_print \
        "percent_blocked" \
        "${percent_percent_blocked_colour:-}" \
        "${percent_percent_blocked_crit:-"90"}" \
        "${percent_percent_blocked_draw:-${graph_draw}}" \
        "${percent_percent_blocked_graph:-"yes"}" \
        "${percent_percent_blocked_info:-"Pi-hole percent blocked"}" \
        "${percent_percent_blocked_label:-"percent blocked"}" \
        "${percent_percent_blocked_max:-"100"}" \
        "${percent_percent_blocked_min:-"0"}" \
        "${percent_percent_blocked_type:-"GAUGE"}" \
        "${percent_percent_blocked_warn:-"0:85"}"
}

###############################################################################
# Privacy Level Graph Configuration
###############################################################################

pihole_munin_config_privacy() {
    ftl_response=$(pihole_munin_state_handler "${info_ftl_url}" 2>/dev/null)
    privacy_level_val=$(printf "%s" "${ftl_response}" | jq -r '.ftl.privacy_level // empty')
    case "${privacy_level_val}" in
        0)
            privacy_doc_info="Level 0 - show everything"
            privacy_doc_text="Doesn't hide anything, all statistics are available."
            ;;
        1)
            privacy_doc_info="Level 1 - hide domains"
            privacy_doc_text="Show and store all domains as hidden. This setting disables Top Domains, Top Ads."
            ;;
        2)
            privacy_doc_info="Level 2 - hide domains and clients"
            privacy_doc_text="Show and store all domains as hidden and clients as 0.0.0.0 This setting disables Top Domains, Top Ads, Top Clients, Clients over time."
            ;;
        3)
            privacy_doc_info="Level 3 - anonymous mode (anonymize everything)"
            privacy_doc_text="Anonymize everything. This setting disables Top Domains, Top Ads, Top Clients, Clients over time, Query Log, Long-term database logging."
            ;;
        *)
            privacy_doc_info="Privacy level unknown."
            ;;
    esac
    if [ -n "${privacy_doc_info}" ] && [ -n "${privacy_doc_text}" ]; then
        privacy_info="${privacy_doc_info} ${privacy_doc_text}"
    else
        privacy_info="${privacy_doc_info}"
    fi
    printf "%s\n" \
        "graph ${graph_privacy:-${graph}}" \
        "graph_args ${graph_args_privacy:-"--upper-limit 3 --lower-limit 0"}" \
        "graph_category ${graph_category_privacy:-${graph_category}}" \
        "graph_height ${graph_height_privacy:-${graph_height}}" \
        "graph_info ${graph_info_privacy:-"Using privacy levels you can specify which level of detail you want to see in your Pi-hole statistics. The privacy level may be changed at any time without having to restart the DNS resolver. Note that queries with (partially) hidden details cannot be disclosed with a subsequent reduction of the privacy level. They can be changed either from the Settings page on the dashboard or in FTL's config file. Visit <a href=\"https://docs.pi-hole.net/ftldns/privacylevels/\">https://docs.pi-hole.net/ftldns/privacylevels/</a> for more information"}" \
        "graph_scale ${graph_scale_privacy:-${graph_scale}}" \
        "graph_title ${graph_title_privacy:-"Pi-hole privacy level"}" \
        "graph_vlabel ${graph_vlabel_privacy:-"show all / 1 / 2 / anonymous"}" \
        "graph_width ${graph_width_privacy:-${graph_width}}"
    pihole_munin_print \
        "privacy_level" \
        "${privacy_privacy_level_colour:-}" \
        "${privacy_privacy_level_crit:-}" \
        "${privacy_privacy_level_draw:-${graph_draw}}" \
        "${privacy_privacy_level_graph:-"yes"}" \
        "${privacy_privacy_level_info:-"${privacy_info}"}" \
        "${privacy_privacy_level_label:-"privacy level"}" \
        "${privacy_privacy_level_max:-"3"}" \
        "${privacy_privacy_level_min:-"0"}" \
        "${privacy_privacy_level_type:-"GAUGE"}" \
        "${privacy_privacy_level_warn:-}"
}

###############################################################################
# Queries Graph Configuration
###############################################################################

pihole_munin_config_queries() {
    graph_type_queries="${graph_type_queries:-"${graph_type}"}"
    if [ "${graph_type_queries}" = "DERIVE" ]; then
        queries_vlabel="queries / second"
    else
        queries_vlabel="queries"
    fi
    queries_response=$(pihole_munin_state_handler "${stats_summary_url}") || exit 1
    queries_fields_output="$(
        for queries_key_label in \
            "blocked|queries blocked" \
            "cached|queries cached" \
            "forwarded|queries forwarded"; do
            queries_key=${queries_key_label%%|*}
            queries_default_info="Pi-hole ${queries_key_label#*|}"
            queries_default_label=$(printf "%s" "${queries_key}" | sed 's/_/ /g')
            queries_value=$(printf '%s' "${queries_response}" | jq -r --arg k "${queries_key}" '.queries[$k] // 0')
            if pihole_munin_graph_zero "queries" || [ "${queries_value}" -ne 0 ]; then
                pihole_munin_safe_eval queries_colour "queries_" "${queries_key}" "_colour" ""
                pihole_munin_safe_eval queries_crit "queries_" "${queries_key}" "_crit" ""
                pihole_munin_safe_eval queries_draw "queries_" "${queries_key}" "_draw" "${graph_draw}"
                pihole_munin_safe_eval queries_graph "queries_" "${queries_key}" "_graph" "yes"
                pihole_munin_safe_eval queries_type "queries_" "${queries_key}" "_type" "${graph_type_queries}"
                if [ "${graph_type_queries:-${queries_type}}" = "DERIVE" ]; then
                    plural="queries"
                    if [ "${queries_value}" -eq 1 ]; then
                        plural="query"
                    fi
                    queries_info="Pi-hole ${queries_key_label#*|} (${queries_value} ${plural})"
                else
                    pihole_munin_safe_eval queries_info "queries_" "${queries_key}" "_info" "${queries_default_info}"
                fi
                pihole_munin_safe_eval queries_label "queries_" "${queries_key}" "_label" "${queries_default_label}"
                pihole_munin_safe_eval queries_max "queries_" "${queries_key}" "_max" ""
                pihole_munin_safe_eval queries_min "queries_" "${queries_key}" "_min" "0"
                pihole_munin_safe_eval queries_warn "queries_" "${queries_key}" "_warn" ""
                pihole_munin_print \
                    "${queries_key}" \
                    "${queries_colour:-}" \
                    "${queries_crit:-}" \
                    "${queries_draw:-}" \
                    "${queries_graph:-}" \
                    "${queries_info:-}" \
                    "${queries_label:-}" \
                    "${queries_max:-}" \
                    "${queries_min:-}" \
                    "${queries_type:-}" \
                    "${queries_warn:-}"
            fi
        done || true
    )"
    num_fields=$(printf "%s\n" "${queries_fields_output}" | grep -c '\.label ')
    if [ "${graph_total_queries:-"total"}" != "undef" ] && [ "${num_fields}" -ge 2 ]; then
        print_total_line="graph_total ${graph_total_queries:-"total"}"
    else
        print_total_line=""
    fi
    printf "%s\n" \
        "graph ${graph_queries:-${graph}}" \
        "graph_args ${graph_args_queries:-${graph_args}}" \
        "graph_category ${graph_category_queries:-${graph_category}}" \
        "graph_height ${graph_height_queries:-${graph_height}}" \
        "graph_info ${graph_info_queries:-"This graph shows Pi-hole's queries"}" \
        "graph_scale ${graph_scale_queries:-${graph_scale}}" \
        "graph_title ${graph_title_queries:-"Pi-hole queries"}" \
        "${print_total_line}" \
        "graph_vlabel ${graph_vlabel_queries:--${queries_vlabel}}" \
        "graph_width ${graph_width_queries:-${graph_width}}"
    if [ -n "${queries_fields_output}" ]; then
        printf "%s\n" "${queries_fields_output}"
    else
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No queries" \
            "none" \
            "" \
            "0" \
            "${graph_type_queries}" \
            ""
    fi
}

###############################################################################
# Queries by Status Graph Configuration
###############################################################################

pihole_munin_config_queries_by_status() {
    graph_type_queries_by_status="${graph_type_queries_by_status:-"${graph_type}"}"
    if [ "${graph_type_queries_by_status}" = "DERIVE" ]; then
        queries_by_status_vlabel="queries / second"
    else
        queries_by_status_vlabel="queries"
    fi
    queries_by_status_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    queries_by_status_fields_output="$(
        printf "%s" "${queries_by_status_response}" | jq -r '.queries.status | to_entries[] | "\(.key) \(.value)"' \
        | while read -r queries_by_status_key queries_by_status_value; do
            if pihole_munin_graph_zero "queries_by_status" || [ "${queries_by_status_value}" -ne 0 ]; then
                pihole_munin_safe_eval queries_by_status_colour "queries_by_status_" "${queries_by_status_key}" "_colour" ""
                pihole_munin_safe_eval queries_by_status_crit "queries_by_status_" "${queries_by_status_key}" "_crit" ""
                pihole_munin_safe_eval queries_by_status_draw "queries_by_status_" "${queries_by_status_key}" "_draw" "${graph_draw}"
                pihole_munin_safe_eval queries_by_status_graph "queries_by_status_" "${queries_by_status_key}" "_graph" "yes"
                pihole_munin_safe_eval queries_by_status_type "queries_by_status_" "${queries_by_status_key}" "_type" "${graph_type_queries_by_status}"
                if [ "${graph_type_queries_by_status:-${queries_by_status_type}}" = "DERIVE" ]; then
                    plural="queries"
                    if [ "${queries_by_status_value}" -eq 1 ]; then
                        plural="query"
                    fi
                    queries_by_status_info="Pi-hole query status ${queries_by_status_key} (${queries_by_status_value} ${plural})"
                else
                    pihole_munin_safe_eval queries_by_status_info "queries_by_status_" "${queries_by_status_key}" "_info" "Pi-hole query status ${queries_by_status_key}"
                fi
                pihole_munin_safe_eval queries_by_status_label "queries_by_status_" "${queries_by_status_key}" "_label" "${queries_by_status_key}"
                pihole_munin_safe_eval queries_by_status_max "queries_by_status_" "${queries_by_status_key}" "_max" ""
                pihole_munin_safe_eval queries_by_status_min "queries_by_status_" "${queries_by_status_key}" "_min" "0"
                pihole_munin_safe_eval queries_by_status_warn "queries_by_status_" "${queries_by_status_key}" "_warn" ""
                pihole_munin_print \
                    "${queries_by_status_key}" \
                    "${queries_by_status_colour:-}" \
                    "${queries_by_status_crit:-}" \
                    "${queries_by_status_draw:-}" \
                    "${queries_by_status_graph:-}" \
                    "${queries_by_status_info:-}" \
                    "${queries_by_status_label:-}" \
                    "${queries_by_status_max:-}" \
                    "${queries_by_status_min:-}" \
                    "${queries_by_status_type:-}" \
                    "${queries_by_status_warn:-}"
            fi
        done || true
    )"
    num_fields=$(printf "%s\n" "${queries_by_status_fields_output}" | grep -c '\.label ')
    if [ "${graph_total_queries_by_status:-"total"}" != "undef" ] && [ "${num_fields}" -ge 2 ]; then
        print_total_line="graph_total ${graph_total_queries_by_status:-"total"}"
    else
        print_total_line=""
    fi
    printf "%s\n" \
        "graph ${graph_queries_by_status:-${graph}}" \
        "graph_args ${graph_args_queries_by_status:-${graph_args}}" \
        "graph_category ${graph_category_queries_by_status:-${graph_category}}" \
        "graph_height ${graph_height_queries_by_status:-${graph_height}}" \
        "graph_info ${graph_info_queries_by_status:-"This graph shows Pi-hole's queries by status"}" \
        "graph_scale ${graph_scale_queries_by_status:-${graph_scale}}" \
        "graph_title ${graph_title_queries_by_status:-"Pi-hole queries by status"}" \
        "${print_total_line}" \
        "graph_vlabel ${graph_vlabel_queries_by_status:-${queries_by_status_vlabel}}" \
        "graph_width ${graph_width_queries_by_status:-${graph_width}}"
    if [ -n "${queries_by_status_fields_output}" ]; then
        printf "%s\n" "${queries_by_status_fields_output}"
    else
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No query statuses" \
            "none" \
            "" \
            "0" \
            "${graph_type_queries_by_status}" \
            ""
    fi
}

###############################################################################
# Queries by Type Graph Configuration
###############################################################################

pihole_munin_config_queries_by_type() {
    graph_type_queries_by_type="${graph_type_queries_by_type:-"${graph_type}"}"
    if [ "${graph_type_queries_by_type}" = "DERIVE" ]; then
        queries_by_type_vlabel="queries / second"
    else
        queries_by_type_vlabel="queries"
    fi
    queries_by_type_response=$(pihole_munin_state_handler "${stats_query_types_url}" ) || exit 1
    queries_by_type_fields_output="$(
        printf "%s" "${queries_by_type_response}" | jq -r '.types | to_entries[] | "\(.key) \(.value)"' \
        | while read -r queries_by_type_key queries_by_type_value; do
            if pihole_munin_graph_zero "queries_by_type" || [ "${queries_by_type_value}" -ne 0 ]; then
                pihole_munin_safe_eval queries_by_type_colour "queries_by_type_" "${queries_by_type_key}" "_colour" ""
                pihole_munin_safe_eval queries_by_type_crit "queries_by_type_" "${queries_by_type_key}" "_crit" ""
                pihole_munin_safe_eval queries_by_type_draw "queries_by_type_" "${queries_by_type_key}" "_draw" "${graph_draw}"
                pihole_munin_safe_eval queries_by_type_graph "queries_by_type_" "${queries_by_type_key}" "_graph" "yes"
                pihole_munin_safe_eval queries_by_type_type "queries_by_type_" "${queries_by_type_key}" "_type" "${graph_type_queries_by_type}"
                if [ "${graph_type_queries_by_type:-${queries_by_type_type}}" = "DERIVE" ]; then
                    plural="queries"
                    if [ "${queries_by_type_value}" -eq 1 ]; then
                        plural="query"
                    fi
                    queries_by_type_info="Pi-hole query type ${queries_by_type_key} (${queries_by_type_value} ${plural})"
                else
                    pihole_munin_safe_eval queries_by_type_info "queries_by_type_" "${queries_by_type_key}" "_info" "Pi-hole query type ${queries_by_type_key}"
                fi
                pihole_munin_safe_eval queries_by_type_label "queries_by_type_" "${queries_by_type_key}" "_label" "${queries_by_type_key}"
                pihole_munin_safe_eval queries_by_type_max "queries_by_type_" "${queries_by_type_key}" "_max" ""
                pihole_munin_safe_eval queries_by_type_min "queries_by_type_" "${queries_by_type_key}" "_min" "0"
                pihole_munin_safe_eval queries_by_type_warn "queries_by_type_" "${queries_by_type_key}" "_warn" ""
                pihole_munin_print \
                    "${queries_by_type_key}" \
                    "${queries_by_type_colour:-}" \
                    "${queries_by_type_crit:-}" \
                    "${queries_by_type_draw:-}" \
                    "${queries_by_type_graph:-}" \
                    "${queries_by_type_info:-}" \
                    "${queries_by_type_label:-}" \
                    "${queries_by_type_max:-}" \
                    "${queries_by_type_min:-}" \
                    "${queries_by_type_type:-}" \
                    "${queries_by_type_warn:-}"
            fi
        done || true
    )"
    num_fields=$(printf "%s\n" "${queries_by_type_fields_output}" | grep -c '\.label ')
    if [ "${graph_total_queries_by_type:-"total"}" != "undef" ] && [ "${num_fields}" -ge 2 ]; then
        print_total_line="graph_total ${graph_total_queries_by_type:-"total"}"
    else
        print_total_line=""
    fi
    printf "%s\n" \
        "graph ${graph_queries_by_type:-${graph}}" \
        "graph_args ${graph_args_queries_by_type:-${graph_args}}" \
        "graph_category ${graph_category_queries_by_type:-${graph_category}}" \
        "graph_height ${graph_height_queries_by_type:-${graph_height}}" \
        "graph_info ${graph_info_queries_by_type:-"This graph shows Pi-hole's queries by record type"}" \
        "graph_scale ${graph_scale_queries_by_type:-${graph_scale}}" \
        "graph_title ${graph_title_queries_by_type:-"Pi-hole queries by type"}" \
        "${print_total_line}" \
        "graph_vlabel ${graph_vlabel_queries_by_type:-${queries_by_type_vlabel}}" \
        "graph_width ${graph_width_queries_by_type:-${graph_width}}"
    if [ -n "${queries_by_type_fields_output}" ]; then
        printf "%s\n" "${queries_by_type_fields_output}"
    else
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No query types" \
            "none" \
            "" \
            "0" \
            "${graph_type_queries_by_type}" \
            ""
    fi
}

###############################################################################
# Replies Graph Configuration
###############################################################################

pihole_munin_config_replies() {
    graph_type_replies="${graph_type_replies:-"${graph_type}"}"
    if [ "${graph_type_replies}" = "DERIVE" ]; then
        replies_vlabel="replies / second"
    else
        replies_vlabel="replies"
    fi
    replies_response=$(pihole_munin_state_handler "${info_metrics_url}" ) || exit 1
    replies_fields_output="$(
        for replies_key in "auth" "forwarded" "local" "optimized" "unanswered"; do
            replies_value=$(printf '%s\n' "${replies_response}" | jq -r --arg k "${replies_key}" '.metrics.dns.replies[$k] // 0')
            if pihole_munin_graph_zero "replies" || [ "${replies_value}" -ne 0 ]; then
                pihole_munin_safe_eval replies_colour "replies_" "${replies_key}" "_colour" ""
                pihole_munin_safe_eval replies_crit "replies_" "${replies_key}" "_crit" ""
                pihole_munin_safe_eval replies_draw "replies_" "${replies_key}" "_draw" "${graph_draw}"
                pihole_munin_safe_eval replies_graph "replies_" "${replies_key}" "_graph" "yes"
                pihole_munin_safe_eval replies_type "replies_" "${replies_key}" "_type" "${graph_type_replies}"
                if [ "${graph_type_replies:-${replies_type}}" = "DERIVE" ]; then
                    plural="replies"
                    if [ "${replies_value}" -eq 1 ]; then
                        plural="reply"
                    fi
                    replies_info="Pi-hole ${replies_key} replies (${replies_value} ${plural})"
                else
                    pihole_munin_safe_eval replies_info "replies_" "${replies_key}" "_info" "Pi-hole ${replies_key} replies"
                fi
                pihole_munin_safe_eval replies_label "replies_" "${replies_key}" "_label" "${replies_key}"
                pihole_munin_safe_eval replies_max "replies_" "${replies_key}" "_max" ""
                pihole_munin_safe_eval replies_min "replies_" "${replies_key}" "_min" "0"
                pihole_munin_safe_eval replies_warn "replies_" "${replies_key}" "_warn" ""
                pihole_munin_print \
                    "${replies_key}" \
                    "${replies_colour:-}" \
                    "${replies_crit:-}" \
                    "${replies_draw:-}" \
                    "${replies_graph:-}" \
                    "${replies_info:-}" \
                    "${replies_label:-}" \
                    "${replies_max:-}" \
                    "${replies_min:-}" \
                    "${replies_type:-}" \
                    "${replies_warn:-}"
            fi
        done || true
    )"
    num_fields=$(printf "%s\n" "${replies_fields_output}" | grep -c '\.label ')
    if [ "${graph_total_replies:-"total"}" != "undef" ] && [ "${num_fields}" -ge 2 ]; then
        print_total_line="graph_total ${graph_total_replies:-"total"}"
    else
        print_total_line=""
    fi
    printf "%s\n" \
        "graph ${graph_replies:-${graph}}" \
        "graph_args ${graph_args_replies:-${graph_args}}" \
        "graph_category ${graph_category_replies:-${graph_category}}" \
        "graph_height ${graph_height_replies:-${graph_height}}" \
        "graph_info ${graph_info_replies:-"This graph shows Pi-hole's replies"}" \
        "graph_scale ${graph_scale_replies:-${graph_scale}}" \
        "graph_title ${graph_title_replies:-"Pi-hole replies"}" \
        "${print_total_line}" \
        "graph_vlabel ${graph_vlabel_replies:-${replies_vlabel}}" \
        "graph_width ${graph_width_replies:-${graph_width}}"
    if [ -n "${replies_fields_output}" ]; then
        printf "%s\n" "${replies_fields_output}"
    else
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No replies" \
            "none" \
            "" \
            "0" \
            "${graph_type_replies}" \
            ""
    fi
}

###############################################################################
# Replies by Type Graph Configuration
###############################################################################

pihole_munin_config_replies_by_type() {
    graph_type_replies_by_type="${graph_type_replies_by_type:-"${graph_type}"}"
    if [ "${graph_type_replies_by_type}" = "DERIVE" ]; then
        replies_by_type_vlabel="replies / second"
    else
        replies_by_type_vlabel="replies"
    fi
    replies_by_type_response=$(pihole_munin_state_handler "${stats_summary_url}") || exit 1
    replies_by_type_fields_output="$(
        printf "%s" "${replies_by_type_response}" | jq -r '.queries.replies | to_entries[] | "\(.key) \(.value)"' \
        | while read -r replies_by_type_key replies_by_type_value; do
            if pihole_munin_graph_zero "replies_by_type" || [ "${replies_by_type_value}" -ne 0 ]; then
                pihole_munin_safe_eval replies_by_type_colour "replies_by_type_" "${replies_by_type_key}" "_colour" ""
                pihole_munin_safe_eval replies_by_type_crit "replies_by_type_" "${replies_by_type_key}" "_crit" ""
                pihole_munin_safe_eval replies_by_type_draw "replies_by_type_" "${replies_by_type_key}" "_draw" "${graph_draw}"
                pihole_munin_safe_eval replies_by_type_graph "replies_by_type_" "${replies_by_type_key}" "_graph" "yes"
                pihole_munin_safe_eval replies_by_type_type "replies_by_type_" "${replies_by_type_key}" "_type" "${graph_type_replies_by_type}"
                if [ "${graph_type_replies_by_type:-${replies_by_type_type}}" = "DERIVE" ]; then
                    plural="replies"
                    if [ "${replies_by_type_value}" -eq 1 ]; then
                        plural="reply"
                    fi
                    replies_by_type_info="Pi-hole reply type ${replies_by_type_key} (${replies_by_type_value} ${plural})"
                else
                    pihole_munin_safe_eval replies_by_type_info "replies_by_type_" "${replies_by_type_key}" "_info" "Pi-hole reply type ${replies_by_type_key}"
                fi
                pihole_munin_safe_eval replies_by_type_label "replies_by_type_" "${replies_by_type_key}" "_label" "${replies_by_type_key}"
                pihole_munin_safe_eval replies_by_type_max "replies_by_type_" "${replies_by_type_key}" "_max" ""
                pihole_munin_safe_eval replies_by_type_min "replies_by_type_" "${replies_by_type_key}" "_min" "0"
                pihole_munin_safe_eval replies_by_type_warn "replies_by_type_" "${replies_by_type_key}" "_warn" ""
                pihole_munin_print \
                    "${replies_by_type_key}" \
                    "${replies_by_type_colour:-}" \
                    "${replies_by_type_crit:-}" \
                    "${replies_by_type_draw:-}" \
                    "${replies_by_type_graph:-}" \
                    "${replies_by_type_info:-}" \
                    "${replies_by_type_label:-}" \
                    "${replies_by_type_max:-}" \
                    "${replies_by_type_min:-}" \
                    "${replies_by_type_type:-}" \
                    "${replies_by_type_warn:-}"
            fi
        done || true
    )"
    num_fields=$(printf "%s\n" "${replies_by_type_fields_output}" | grep -c '\.label ')
    if [ "${graph_total_replies_by_type:-"total"}" != "undef" ] && [ "${num_fields}" -ge 2 ]; then
        print_total_line="graph_total ${graph_total_replies_by_type:-"total"}"
    else
        print_total_line=""
    fi
    printf "%s\n" \
        "graph ${graph_replies_by_type:-${graph}}" \
        "graph_args ${graph_args_replies_by_type:-${graph_args}}" \
        "graph_category ${graph_category_replies_by_type:-${graph_category}}" \
        "graph_height ${graph_height_replies_by_type:-${graph_height}}" \
        "graph_info ${graph_info_replies_by_type:-"This graph shows Pi-hole's replies by record type"}" \
        "graph_scale ${graph_scale_replies_by_type:-${graph_scale}}" \
        "graph_title ${graph_title_replies_by_type:-"Pi-hole replies by type"}" \
        "${print_total_line}" \
        "graph_vlabel ${graph_vlabel_replies_by_type:-${replies_by_type_vlabel}}" \
        "graph_width ${graph_width_replies_by_type:-${graph_width}}"
    if [ -n "${replies_by_type_fields_output}" ]; then
        printf "%s\n" "${replies_by_type_fields_output}"
    else
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No reply types" \
            "none" \
            "" \
            "0" \
            "${graph_type_replies_by_type}" \
            ""
    fi
}

###############################################################################
# Status Graph Configuration
###############################################################################

pihole_munin_config_status() {
    printf "%s\n" \
        "graph ${graph_status:-${graph}}" \
        "graph_args ${graph_args_status:-"--lower-limit -1 --upper-limit 1"}" \
        "graph_height ${graph_height_status:-${graph_height}}" \
        "graph_info ${graph_info_status:-"This graph shows Pi-hole's blocking status"}" \
        "graph_category ${graph_category_status:-${graph_category}}" \
        "graph_scale ${graph_scale_status:-${graph_scale}}" \
        "graph_title ${graph_title_status:-"Pi-hole status"}" \
        "graph_vlabel ${graph_vlabel_status:-"unknown / disabled / enabled"}" \
        "graph_width ${graph_width_status:-${graph_width}}"
    pihole_munin_print \
        "blocking_status" \
        "${status_blocking_status_colour:-}" \
        "${status_blocking_status_crit:-"0:1"}" \
        "${status_blocking_status_draw:-${graph_draw}}" \
        "${status_blocking_status_graph:-"yes"}" \
        "${status_blocking_status_info:-"Pi-hole blocking status"}" \
        "${status_blocking_status_label:-"blocking status"}" \
        "${status_blocking_status_max:-"1"}" \
        "${status_blocking_status_min:-"-1"}" \
        "${status_blocking_status_type:-"GAUGE"}" \
        "${status_blocking_status_warn:-"1:1"}"
}

###############################################################################
# Reverse PTR Lookup Helper
###############################################################################
# Usage:
#   pihole_munin_rev_ptr <ip[:port]>
#
# Description:
#   Performs a reverse DNS lookup for the given IP address (optionally with
#   port), using system utilities (getent, dig) and caches results in a state
#   file with a configurable TTL. Handles both IPv4 and IPv6 addresses, and
#   supports cache migration from old formats. Returns the resolved hostname
#   or the original IP if no hostname is found.
#
# Arguments:
#   $1  ip_port   - IP address (optionally with port, e.g. "192.168.1.1:53" or
#                   "[::1]:5353")
#
# Logic:
#   - Normalizes input, extracts IP from IP:PORT.
#   - Checks cache for existing valid entry (migrates old format if needed).
#   - If cache is valid, returns cached hostname or IP.
#   - If cache is stale or missing, performs reverse lookup using getent and
#     dig.
#   - Caches result (negative cache if lookup fails and dig did not timeout).
#
# Output:
#   - Prints resolved hostname if found, else prints original IP (or IP:PORT).
#   - Updates cache file with lookup results.
###############################################################################

pihole_munin_rev_ptr() {
    ip_port="$1"
    reverse_lookup_cache="${pihole_munin_plugstate}/pihole_munin_rev_ptr.state"
    rev_ptr_ttl="${rev_ptr_ttl:-"86400"}"
    now=$(date +%s)
    ip_port=$(printf "%s" "${ip_port}" | sed 's/^\[\(.*\)\]$/\1/')
    if printf "%s" "${ip_port}" | grep -Eq '^\[?[0-9a-fA-F:]+\]?:[0-9]+$'; then
        ip=$(printf "%s" "${ip_port}" | sed 's/\(.*\):[0-9]\+$/\1/')
    elif printf "%s" "${ip_port}" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(:[0-9]+)?$'; then
        ip=$(printf "%s" "${ip_port}" | cut -d: -f1)
    else
        ip="${ip_port}"
    fi
    if grep -q "^${ip} " "${reverse_lookup_cache}" 2>/dev/null; then
        cached_line=$(grep "^${ip} " "${reverse_lookup_cache}" | head -n1)
        fields=$(printf "%s" "${cached_line}" | awk '{print NF}')
        if [ "${fields}" -eq 2 ]; then
            cached_val=$(printf "%s" "${cached_line}" | cut -d' ' -f2)
            cached_time="${now}"
            grep -v "^${ip} " "${reverse_lookup_cache}" > "${reverse_lookup_cache}.tmp"
            printf "%s %s %s\n" "${ip}" "${cached_time}" "${cached_val}" >> "${reverse_lookup_cache}.tmp"
            mv "${reverse_lookup_cache}.tmp" "${reverse_lookup_cache}"
        elif [ "${fields}" -ge 3 ]; then
            cached_time=$(printf "%s" "${cached_line}" | awk '{print $2}')
            cached_val=$(printf "%s" "${cached_line}" | cut -d' ' -f3-)
        fi
        if [ -n "${cached_time}" ] && [ $((now - cached_time)) -lt "${rev_ptr_ttl}" ]; then
            if [ "${cached_val}" = "-" ]; then
                printf "%s\n" "${ip_port}"
            else
                printf "%s\n" "${cached_val}"
            fi
            return
        fi
        grep -v "^${ip} " "${reverse_lookup_cache}" > "${reverse_lookup_cache}.tmp" && mv "${reverse_lookup_cache}.tmp" "${reverse_lookup_cache}"
    fi
    hostname=$(getent hosts "${ip}" 2>/dev/null | awk '{print $2}' | head -n1)
    if [ -z "${hostname}" ]; then
        dig_output=$(dig +time=10 +short -x "${ip}" 2>&1)
        dig_status=$?
        if [ "${dig_status}" -eq 0 ] && [ -n "${dig_output}" ] && ! printf "%s" "${dig_output}" | grep -q '^;;'; then
            hostname=$(printf "%s" "${dig_output}" | head -n1)
        fi
    fi
    if [ -n "${hostname}" ] && ! printf "%s" "${hostname}" | grep -q '^;;'; then
        printf "%s %s %s\n" "${ip}" "${now}" "${hostname}" >> "${reverse_lookup_cache}"
        printf "%s\n" "${hostname}"
    else
        if [ "${dig_status:-"0"}" -eq 0 ] && [ -z "${hostname}" ]; then
            printf "%s %s -\n" "${ip}" "${now}" >> "${reverse_lookup_cache}"
        fi
        printf "%s\n" "${ip_port}"
    fi
}

###############################################################################
# Top Clients Graph Configuration
###############################################################################

pihole_munin_config_top_clients() {
    graph_type_top_clients="${graph_type_top_clients:-"${graph_type}"}"
    if [ "${graph_type_top_clients}" = "DERIVE" ]; then
        top_clients_vlabel="queries / second"
    else
        top_clients_vlabel="queries"
    fi
    top_clients_response=$(pihole_munin_state_handler "${stats_top_clients_url}?count=${top_clients_n}") || exit 1
    top_clients_fields_output="$(
        printf "%s" "${top_clients_response}" | jq -r ".clients[] | \"\(.name) \(.count)\"" | awk 'NF == 2' |
        while read -r raw_key raw_value; do
            top_clients_key="$(printf "%s" "${raw_key}" | tr -c 'a-zA-Z0-9' '_')"
            case "${top_clients_key}" in
                [0-9]*) top_clients_key="top_clients_${top_clients_key}" ;;
            esac
            default_label="${raw_key}"
            default_info="Pi-hole top client ${raw_key}"
            pihole_munin_safe_eval top_clients_colour "top_clients_" "${top_clients_key}" "_colour" ""
            pihole_munin_safe_eval top_clients_crit "top_clients_" "${top_clients_key}" "_crit" ""
            pihole_munin_safe_eval top_clients_draw "top_clients_" "${top_clients_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval top_clients_graph "top_clients_" "${top_clients_key}" "_graph" "yes"
            pihole_munin_safe_eval top_clients_type "top_clients_" "${top_clients_key}" "_type" "${graph_type_top_clients}"
            if [ "${graph_type_top_clients:-${top_clients_type}}" = "DERIVE" ]; then
                plural="queries"
                if [ "${raw_value}" -eq 1 ]; then
                    plural="query"
                fi
                top_clients_info="${default_info} (${raw_value} ${plural})"
            else
                pihole_munin_safe_eval top_clients_info "top_clients_" "${top_clients_key}" "_info" "${default_info}"
            fi
            pihole_munin_safe_eval top_clients_label "top_clients_" "${top_clients_key}" "_label" "${default_label}"
            pihole_munin_safe_eval top_clients_max "top_clients_" "${top_clients_key}" "_max" ""
            pihole_munin_safe_eval top_clients_min "top_clients_" "${top_clients_key}" "_min" "0"
            pihole_munin_safe_eval top_clients_warn "top_clients_" "${top_clients_key}" "_warn" ""
            pihole_munin_print \
                "${top_clients_key}" \
                "${top_clients_colour:-}" \
                "${top_clients_crit:-}" \
                "${top_clients_draw:-}" \
                "${top_clients_graph:-}" \
                "${top_clients_info:-}" \
                "${top_clients_label:-}" \
                "${top_clients_max:-}" \
                "${top_clients_min:-}" \
                "${top_clients_type:-}" \
                "${top_clients_warn:-}"
        done || true
    )"
    num_fields=$(printf "%s\n" "${top_clients_fields_output}" | grep -c '\.label ')
    if [ "${graph_total_top_clients:-"total"}" != "undef" ] && [ "${num_fields}" -ge 2 ]; then
        print_total_line="graph_total ${graph_total_top_clients:-"total"}"
    else
        print_total_line=""
    fi
    printf "%s\n" \
        "graph ${graph_top_clients:-${graph}}" \
        "graph_args ${graph_args_top_clients:-${graph_args}}" \
        "graph_category ${graph_category_top_clients:-${graph_category}}" \
        "graph_height ${graph_height_top_clients:-${graph_height}}" \
        "graph_info ${graph_info_top_clients:-"This graph shows Pi-hole's top clients by query count (max ${top_clients_n} clients)"}" \
        "graph_scale ${graph_scale_top_clients:-${graph_scale}}" \
        "graph_title ${graph_title_top_clients:-"Pi-hole top clients"}" \
        "${print_total_line}" \
        "graph_vlabel ${graph_vlabel_top_clients:-${top_clients_vlabel}}" \
        "graph_width ${graph_width_top_clients:-${graph_width}}"
    if [ -n "${top_clients_fields_output}" ]; then
        printf "%s\n" "${top_clients_fields_output}"
    else
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No clients" \
            "none" \
            "" \
            "0" \
            "${graph_type:-${graph_type_top_clients}}" \
            ""
    fi
}

###############################################################################
# Top Domains Graph Configuration
###############################################################################

pihole_munin_config_top_domains() {
    graph_type_top_domains="${graph_type_top_domains:-"${graph_type}"}"
    if [ "${graph_type_top_domains}" = "DERIVE" ]; then
        top_domains_vlabel="queries / second"
    else
        top_domains_vlabel="queries"
    fi
    top_domains_response=$(pihole_munin_state_handler "${stats_top_domains_url}?count=${top_domains_n}") || exit 1
    top_domains_fields_output="$(
        printf "%s" "${top_domains_response}" | jq -r ".domains[] | \"\(.domain) \(.count)\"" | awk 'NF == 2' |
        while read -r raw_key raw_value; do
            top_domains_key="$(printf "%s" "${raw_key}" | tr -c 'a-zA-Z0-9' '_')"
            case "${top_domains_key}" in
                [0-9]*) top_domains_key="top_domains_${top_domains_key}" ;;
            esac
            default_label="${raw_key}"
            default_info="Pi-hole top domain ${raw_key}"
            pihole_munin_safe_eval top_domains_colour "top_domains_" "${top_domains_key}" "_colour" ""
            pihole_munin_safe_eval top_domains_crit "top_domains_" "${top_domains_key}" "_crit" ""
            pihole_munin_safe_eval top_domains_draw "top_domains_" "${top_domains_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval top_domains_graph "top_domains_" "${top_domains_key}" "_graph" "yes"
            pihole_munin_safe_eval top_domains_type "top_domains_" "${top_domains_key}" "_type" "${graph_type_top_domains}"
            if [ "${graph_type_top_domains:-${top_domains_type}}" = "DERIVE" ]; then
                plural="queries"
                if [ "${raw_value}" -eq 1 ]; then
                    plural="query"
                fi
                top_domains_info="${default_info} (${raw_value} ${plural})"
            else
                pihole_munin_safe_eval top_domains_info "top_domains_" "${top_domains_key}" "_info" "${default_info}"
            fi
            pihole_munin_safe_eval top_domains_label "top_domains_" "${top_domains_key}" "_label" "${default_label}"
            pihole_munin_safe_eval top_domains_max "top_domains_" "${top_domains_key}" "_max" ""
            pihole_munin_safe_eval top_domains_min "top_domains_" "${top_domains_key}" "_min" "0"
            pihole_munin_safe_eval top_domains_warn "top_domains_" "${top_domains_key}" "_warn" ""
            pihole_munin_print \
                "${top_domains_key}" \
                "${top_domains_colour:-}" \
                "${top_domains_crit:-}" \
                "${top_domains_draw:-}" \
                "${top_domains_graph:-}" \
                "${top_domains_info:-}" \
                "${top_domains_label:-}" \
                "${top_domains_max:-}" \
                "${top_domains_min:-}" \
                "${top_domains_type:-}" \
                "${top_domains_warn:-}"
        done || true
    )"
    num_fields=$(printf "%s\n" "${top_domains_fields_output}" | grep -c '\.label ')
    if [ "${graph_total_top_domains:-"total"}" != "undef" ] && [ "${num_fields}" -ge 2 ]; then
        print_total_line="graph_total ${graph_total_top_domains:-"total"}"
    else
        print_total_line=""
    fi
    printf "%s\n" \
        "graph ${graph_top_domains:-${graph}}" \
        "graph_args ${graph_args_top_domains:-${graph_args}}" \
        "graph_category ${graph_category_top_domains:-${graph_category}}" \
        "graph_height ${graph_height_top_domains:-${graph_height}}" \
        "graph_info ${graph_info_top_domains:-"This graph shows Pi-hole's top domains by query count (max ${top_domains_n} domains)"}" \
        "graph_scale ${graph_scale_top_domains:-${graph_scale}}" \
        "graph_title ${graph_title_top_domains:-"Pi-hole top domains"}" \
        "${print_total_line}" \
        "graph_vlabel ${graph_vlabel_top_domains:-${top_domains_vlabel}}" \
        "graph_width ${graph_width_top_domains:-${graph_width}}"
    if [ -n "${top_domains_fields_output}" ]; then
        printf "%s\n" "${top_domains_fields_output}"
    else
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No domains" \
            "none" \
            "" \
            "0" \
            "${graph_type:-${graph_type_top_domains}}" \
            ""
    fi
}

###############################################################################
# Unique Domains Graph Configuration
###############################################################################

pihole_munin_config_unique() {
    graph_type_unique="${graph_type_unique:-"${graph_type}"}"
    if [ "${graph_type_unique}" = "DERIVE" ]; then
        unique_vlabel="domains / second"
    else
        unique_vlabel="domains"
    fi
    printf "%s\n" \
        "graph ${graph_unique:-${graph}}" \
        "graph_args ${graph_args_unique:-${graph_args}}" \
        "graph_category ${graph_category_unique:-${graph_category}}" \
        "graph_height ${graph_height_unique:-${graph_height}}" \
        "graph_info ${graph_info_unique:-"This graph shows the number of unique domains queried by Pi-hole"}" \
        "graph_scale ${graph_scale_unique:-${graph_scale}}" \
        "graph_title ${graph_title_unique:-"Pi-hole unique domains"}" \
        "graph_vlabel ${graph_vlabel_unique:-${unique_vlabel}}" \
        "graph_width ${graph_width_unique:-${graph_width}}"
    unique_response=$(pihole_munin_state_handler "${stats_summary_url}" 2>/dev/null)
    unique_domains_val=$(printf "%s" "${unique_response}" | jq -r '.queries.unique_domains // empty')
    pihole_munin_safe_eval unique_type "unique_" "unique_domains" "_type" "${graph_type_unique}"
    if [ "${graph_type_unique:-${unique_type}}" = "DERIVE" ]; then
        plural="domains"
        if [ "${unique_domains_val}" = "1" ]; then
            plural="domain"
        fi
        unique_info="Pi-hole unique domains (${unique_domains_val:-"0"} ${plural})"
    else
        pihole_munin_safe_eval unique_info "unique_" "unique_domains" "_info" "Pi-hole unique domains"
    fi
    pihole_munin_print \
        "unique_domains" \
        "${unique_unique_domains_colour:-}" \
        "${unique_unique_domains_crit:-}" \
        "${unique_unique_domains_draw:-${graph_draw}}" \
        "${unique_unique_domains_graph:-"yes"}" \
        "${unique_info:-}" \
        "${unique_unique_domains_label:-"unique domains"}" \
        "${unique_unique_domains_max:-}" \
        "${unique_unique_domains_min:-"0"}" \
        "${unique_type:-}" \
        "${unique_unique_domains_warn:-}"
}

###############################################################################
# Upstreams Graph Configuration
###############################################################################

pihole_munin_config_upstreams() {
    graph_type_upstreams="${graph_type_upstreams:-"${graph_type}"}"
    if [ "${graph_type_upstreams}" = "DERIVE" ]; then
        upstreams_vlabel="queries / second"
    else
        upstreams_vlabel="queries"
    fi
    upstreams_response=$(pihole_munin_state_handler "${stats_upstreams_url}") || exit 1
    upstreams_fields_output="$(
        upstreams_total=$(printf '%s' "${upstreams_response}" | jq '[.upstreams[].count // 0] | add')
        printf "%s" "${upstreams_response}" | jq -c '.upstreams[]' | while read -r upstream; do
            raw_name=$(printf '%s' "${upstream}" | jq -r '.name // empty')
            raw_ip=$(printf '%s' "${upstream}" | jq -r '.ip // empty')
            raw_port=$(printf '%s' "${upstream}" | jq -r '.port // 0')
            upstream_count=$(printf '%s' "${upstream}" | jq -r '.count // 0')
            percent="0"
            if [ "${upstreams_total}" -gt 0 ]; then
                percent=$(awk "BEGIN { printf \"%.2f\", (${upstream_count}/${upstreams_total})*100 }")
            fi
            if [ -n "${raw_name}" ] && [ "${raw_name}" != "null" ]; then
                upstreams_key=$(printf "%s" "${raw_name}" | tr -c 'a-zA-Z0-9' '_')
            else
                upstreams_key=$(printf "%s" "${raw_ip}" | tr -c 'a-zA-Z0-9' '_')
            fi
            case "${upstreams_key}" in
                [0-9]*) upstreams_key="upstreams_${upstreams_key}" ;;
            esac
            port_str=""
            if [ -n "${raw_port}" ] && printf "%s" "${raw_port}" | grep -Eq '^[0-9]+$' && [ "${raw_port}" -gt 0 ] && [ "${raw_port}" -le 65535 ] && [ "${raw_port}" -ne 53 ]; then
                port_str=":${raw_port}"
            fi
            if [ -n "${raw_name}" ] && [ "${raw_name}" != "null" ]; then
                default_label="${raw_name}${port_str}"
                default_info="Pi-hole upstream server ${raw_name}${port_str} (${raw_ip}${port_str}"
            else
                rev_label=$(pihole_munin_rev_ptr "${raw_ip}")
                default_label="${rev_label}${port_str}"
                default_info="Pi-hole upstream server ${rev_label}${port_str} (${raw_ip}${port_str}"
            fi
            pihole_munin_safe_eval upstreams_colour "upstreams_" "${upstreams_key}" "_colour" ""
            pihole_munin_safe_eval upstreams_crit "upstreams_" "${upstreams_key}" "_crit" ""
            pihole_munin_safe_eval upstreams_draw "upstreams_" "${upstreams_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval upstreams_graph "upstreams_" "${upstreams_key}" "_graph" "yes"
            pihole_munin_safe_eval upstreams_type "upstreams_" "${upstreams_key}" "_type" "${graph_type_upstreams}"
            if [ "${graph_type_upstreams:-${upstreams_type}}" = "DERIVE" ]; then
                plural="queries"
                if [ "${upstream_count}" -eq 1 ]; then
                    plural="query"
                fi
                if [ -n "${raw_name}" ] && [ "${raw_name}" != "null" ]; then
                    upstreams_info="${default_info}, ${upstream_count} ${plural}, ${percent}% of total)"
                else
                    upstreams_info="${default_info} ${upstream_count} ${plural}, ${percent}% of total)"
                fi
            else
                pihole_munin_safe_eval upstreams_info "upstreams_" "${upstreams_key}" "_info" "${default_info})"
            fi
            pihole_munin_safe_eval upstreams_label "upstreams_" "${upstreams_key}" "_label" "${default_label}"
            pihole_munin_safe_eval upstreams_max "upstreams_" "${upstreams_key}" "_max" ""
            pihole_munin_safe_eval upstreams_min "upstreams_" "${upstreams_key}" "_min" "0"
            pihole_munin_safe_eval upstreams_warn "upstreams_" "${upstreams_key}" "_warn" ""
            pihole_munin_print \
                "${upstreams_key}" \
                "${upstreams_colour:-}" \
                "${upstreams_crit:-}" \
                "${upstreams_draw:-}" \
                "${upstreams_graph:-}" \
                "${upstreams_info:-}" \
                "${upstreams_label:-}" \
                "${upstreams_max:-}" \
                "${upstreams_min:-}" \
                "${upstreams_type:-}" \
                "${upstreams_warn:-}"
        done || true
    )"
    num_fields=$(printf "%s\n" "${upstreams_fields_output}" | grep -c '\.label ')
    if [ "${graph_total_upstreams:-"total"}" != "undef" ] && [ "${num_fields}" -ge 2 ]; then
        print_total_line="graph_total ${graph_total_upstreams:-"total"}"
    else
        print_total_line=""
    fi
    printf "%s\n" \
        "graph ${graph_upstreams:-${graph}}" \
        "graph_args ${graph_args_upstreams:-${graph_args}}" \
        "graph_category ${graph_category_upstreams:-${graph_category}}" \
        "graph_height ${graph_height_upstreams:-${graph_height}}" \
        "graph_info ${graph_info_upstreams:-"This graph shows the query counts for each of Pi-hole's upstream destinations"}" \
        "graph_scale ${graph_scale_upstreams:-${graph_scale}}" \
        "graph_title ${graph_title_upstreams:-"Pi-hole upstream servers"}" \
        "${print_total_line}" \
        "graph_vlabel ${graph_vlabel_upstreams:-${upstreams_vlabel}}" \
        "graph_width ${graph_width_upstreams:-${graph_width}}"
    if [ -n "${upstreams_fields_output}" ]; then
        printf "%s\n" "${upstreams_fields_output}"
    else
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No upstreams" \
            "none" \
            "" \
            "0" \
            "${graph_type_upstreams}" \
            ""
    fi
}

###############################################################################
# Version Graph Configuration
###############################################################################
# Docker version monitoring is disabled by default.
# To enable, set: env.version_enable_docker yes
###############################################################################

pihole_munin_config_version() {
    version_enable_docker="${version_enable_docker:-"no"}"
    printf "%s\n" \
        "graph ${graph_version:-${graph}}" \
        "graph_args ${graph_args_version:-"--lower-limit -1 --upper-limit 1"}" \
        "graph_category ${graph_category_version:-${graph_category}}" \
        "graph_height ${graph_height_version:-${graph_height}}" \
        "graph_info ${graph_info_version:-"This graph shows the version status of Pi-hole components"}" \
        "graph_scale ${graph_scale_version:-${graph_scale}}" \
        "graph_title ${graph_title_version:-"Pi-hole version"}" \
        "graph_vlabel ${graph_vlabel_version:-"unknown / up-to-date / update available"}" \
        "graph_width ${graph_width_version:-${graph_width}}"
    version_response=$(pihole_munin_state_handler "/info/version" 2>/dev/null)
    for pihole_module in core web ftl docker; do
        if [ "${pihole_module}" = "docker" ] && [ "${version_enable_docker}" != "yes" ]; then
            continue
        fi
        label="version_${pihole_module}"
        info=""
        if [ -n "${version_response}" ]; then
            case "${pihole_module}" in
                "core"|"web"|"ftl")
                    local_ver=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.local.version // empty")
                    remote_ver=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.remote.version // empty")
                    branch=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.local.branch // empty")
                    hash=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.local.hash // empty")
                    remote_hash=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.remote.hash // empty")
                    date=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.local.date // empty")
                    info="Branch: ${branch}, Local: ${local_ver} (${hash})"
                    [ -n "${date}" ] && info="${info}, Date: ${date}"
                    info="${info}; Remote: ${remote_ver} (${remote_hash})"
                    ;;
                "docker")
                    local_ver=$(printf '%s' "${version_response}" | jq -r ".version.docker.local // empty")
                    remote_ver=$(printf '%s' "${version_response}" | jq -r ".version.docker.remote // empty")
                    info="Local: ${local_ver}; Remote: ${remote_ver}"
                    ;;
            esac
        fi
        default_info="Pi-hole ${pihole_module} version status"
        [ -n "${info}" ] && default_info="${default_info} (${info})"
        pihole_munin_safe_eval version_colour "version_" "${pihole_module}" "_colour" ""
        pihole_munin_safe_eval version_crit "version_" "${pihole_module}" "_crit" ""
        pihole_munin_safe_eval version_draw "version_" "${pihole_module}" "_draw" "${graph_draw}"
        pihole_munin_safe_eval version_graph "version_" "${pihole_module}" "_graph" "yes"
        pihole_munin_safe_eval version_info "version_" "${pihole_module}" "_info" "${default_info}"
        pihole_munin_safe_eval version_label "version_" "${pihole_module}" "_label" "${pihole_module}"
        pihole_munin_safe_eval version_max "version_" "${pihole_module}" "_max" "1"
        pihole_munin_safe_eval version_min "version_" "${pihole_module}" "_min" "-1"
        pihole_munin_safe_eval version_type "version_" "${pihole_module}" "_type" "GAUGE"
        pihole_munin_safe_eval version_warn "version_" "${pihole_module}" "_warn" ""
        pihole_munin_print \
            "${label}" \
            "${version_colour:-}" \
            "${version_crit:-}" \
            "${version_draw:-}" \
            "${version_graph:-}" \
            "${version_info:-}" \
            "${version_label:-}" \
            "${version_max:-}" \
            "${version_min:-}" \
            "${version_type:-}" \
            "${version_warn:-}"
    done
}

###############################################################################
# Dependency Check Function
###############################################################################
# Usage:
#   pihole_munin_check_dependencies
#
# Description:
#   Checks for the presence of required command-line dependencies needed by
#   the plugin. Iterates through a list of required commands and verifies
#   each is available in the system PATH. Prints an error and returns 1 if
#   any dependency is missing.
#
# Dependencies Checked:
#   - awk
#   - curl
#   - dig
#   - grep
#   - jq
#   - mktemp
#   - sed
#
# Logic:
#   - For each dependency, checks if the command exists.
#   - If any dependency is missing, prints an error and returns 1.
#   - If all dependencies are present, returns 0.
#
# Output:
#   - Prints error message for each missing dependency.
#   - Returns 1 if any dependency is missing, else 0.
###############################################################################

pihole_munin_check_dependencies() {
    plugin_dependencies="awk curl dig grep jq mktemp sed"
    for plugin_dependency in ${plugin_dependencies}; do
        if ! command -v "${plugin_dependency}" >/dev/null 2>&1; then
            pihole_munin_print_status "‚ùå" "Missing pihole_munin_ plugin dependency '${plugin_dependency}'." >&2
            return 1
        fi
    done
}

###############################################################################
# Plugin Config Handler
###############################################################################

pihole_munin_config_handler() {
    case "${pihole_munin_plugin_id}" in
        "cache") pihole_munin_config_cache ;;
        "cache_by_type") pihole_munin_config_cache_by_type ;;
        "clients") pihole_munin_config_clients ;;
        "dnsmasq") pihole_munin_config_dnsmasq ;;
        "domains") pihole_munin_config_domains ;;
        "frequency") pihole_munin_config_frequency ;;
        "gravity") pihole_munin_config_gravity ;;
        "overview") pihole_munin_config_overview ;;
        "percent") pihole_munin_config_percent ;;
        "privacy") pihole_munin_config_privacy ;;
        "queries") pihole_munin_config_queries ;;
        "queries_by_status") pihole_munin_config_queries_by_status ;;
        "queries_by_type") pihole_munin_config_queries_by_type ;;
        "replies") pihole_munin_config_replies ;;
        "replies_by_type") pihole_munin_config_replies_by_type ;;
        "status") pihole_munin_config_status ;;
        "top_clients") pihole_munin_config_top_clients ;;
        "top_domains") pihole_munin_config_top_domains ;;
        "unique") pihole_munin_config_unique ;;
        "upstreams") pihole_munin_config_upstreams ;;
        "version") pihole_munin_config_version ;;
        *)
            pihole_munin_print_status "‚ùå" "Unknown pihole_munin_ plugin ID '${pihole_munin_plugin_id}'." >&2
            exit 1
            ;;
    esac
}

###############################################################################
# Fetch Cache Metrics
###############################################################################

pihole_munin_fetch_cache() {
    if [ -z "${cache_response}" ]; then
        cache_response=$(pihole_munin_state_handler "${info_metrics_url}" ) || exit 1
    fi
    for cache_key in "evicted" "expired" "immortal" "inserted"; do
        cache_value=$(printf '%s' "${cache_response}" | jq -r --arg k "${cache_key}" '.metrics.dns.cache[$k] // 0')
        if pihole_munin_graph_zero "cache" || [ "${cache_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${cache_key}" "${cache_value}"
        fi
    done
}

###############################################################################
# Fetch Cache by Type Metrics
###############################################################################

pihole_munin_fetch_cache_by_type() {
    if [ -z "${cache_by_type_response}" ]; then
        cache_by_type_response=$(pihole_munin_state_handler "${info_metrics_url}" ) || exit 1
    fi
    printf "%s" "${cache_by_type_response}" | jq -c '.metrics.dns.cache.content[]' \
    | while read -r cache_by_type_entry; do
        cache_by_type_name=$(printf '%s' "${cache_by_type_entry}" | jq -r '.name')
        cache_by_type_valid=$(printf '%s' "${cache_by_type_entry}" | jq -r '.count.valid')
        cache_by_type_stale=$(printf '%s' "${cache_by_type_entry}" | jq -r '.count.stale')
        for cache_by_type_entry in "valid" "stale"; do
            case "${cache_by_type_entry}" in
                "valid")
                    cache_by_type_key="${cache_by_type_name}"
                    cache_by_type_value="${cache_by_type_valid}"
                    ;;
                "stale")
                    cache_by_type_key="${cache_by_type_name}_STALE"
                    cache_by_type_value="${cache_by_type_stale}"
                    ;;
            esac
            if pihole_munin_graph_zero "cache_by_type" || [ "${cache_by_type_value}" -ne 0 ]; then
                printf "%s.value %s\n" "${cache_by_type_key}" "${cache_by_type_value}"
            fi
        done
    done
}

###############################################################################
# Fetch Clients Metrics
###############################################################################

pihole_munin_fetch_clients() {
    if [ -z "${clients_response}" ]; then
        clients_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    fi
    printf "%s" "${clients_response}" | jq -r '.clients | to_entries[] | "\(.key) \(.value)"' \
    | while read -r clients_key clients_value; do
        if pihole_munin_graph_zero "clients" || [ "${clients_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${clients_key}" "${clients_value}"
        fi
    done
}

###############################################################################
# Fetch Dnsmasq Metrics
###############################################################################

pihole_munin_fetch_dnsmasq() {
    if [ -z "${dnsmasq_response}" ]; then
        dnsmasq_response=$(pihole_munin_state_handler "${info_ftl_url}" ) || exit 1
    fi
    printf "%s" "${dnsmasq_response}" | jq -r '.ftl.dnsmasq | to_entries[] | "\(.key) \(.value)"' \
    | while read -r dnsmasq_key dnsmasq_value; do
        if pihole_munin_graph_zero "dnsmasq" || [ "${dnsmasq_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${dnsmasq_key}" "${dnsmasq_value}"
        fi
    done
}

###############################################################################
# Fetch Domains Being Blocked
###############################################################################

pihole_munin_fetch_domains() {
    if [ -z "${domains_response}" ]; then
        domains_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    fi
    printf "%s" "${domains_response}" | jq -r '.gravity | "\("domains_being_blocked.value") \(.domains_being_blocked)"'
}

###############################################################################
# Fetch Query Frequency
###############################################################################

pihole_munin_fetch_frequency() {
    if [ -z "${frequency_response}" ]; then
        frequency_response=$(pihole_munin_state_handler "${stats_summary_url}") || exit 1
    fi
    printf "%s" "${frequency_response}" | jq -r '.queries | "frequency.value \(.frequency | tonumber | . * 100 | round | . / 100)"'
}

###############################################################################
# Fetch Gravity Database Metrics
###############################################################################

pihole_munin_fetch_gravity() {
    if [ -z "${gravity_response}" ]; then
        gravity_response=$(pihole_munin_state_handler "${info_ftl_url}") || exit 1
    fi
    for gravity_key in "groups" "lists" "domains_allowed" "domains_denied" "regex_allowed" "regex_denied"; do
        case "${gravity_key}" in
            "domains_"*)
                gravity_jq_key=".ftl.database.domains.${gravity_key#domains_}"
                ;;
            "regex_"*)
                gravity_jq_key=".ftl.database.regex.${gravity_key#regex_}"
                ;;
            *)
                gravity_jq_key=".ftl.database.${gravity_key}"
                ;;
        esac
        gravity_value=$(printf '%s' "${gravity_response}" | jq -r "${gravity_jq_key} // 0")
        if pihole_munin_graph_zero "gravity" || [ "${gravity_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${gravity_key}" "${gravity_value}"
        fi
    done
}

###############################################################################
# Fetch Overview Metrics (queries and replies by type)
###############################################################################

pihole_munin_fetch_overview() {
    if [ -z "${overview_queries_by_type_response}" ]; then
        overview_queries_by_type_response=$(pihole_munin_state_handler "${stats_query_types_url}" ) || exit 1
    fi
    if [ -z "${overview_replies_by_type_response}" ]; then
        overview_replies_by_type_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    fi
    overview_all_types=$(
        { printf '%s\n' "${overview_queries_by_type_response}" | jq -r '.types | keys_unsorted[]'; \
            printf '%s\n' "${overview_replies_by_type_response}" | jq -r '.queries.replies | keys_unsorted[]'; \
        } | sort -u
    )
    for overview_record_type in ${overview_all_types}; do
        overview_query_val=$(printf '%s\n' "${overview_queries_by_type_response}" | jq -r --arg k "${overview_record_type}" '.types[$k] // 0')
        overview_reply_val=$(printf '%s\n' "${overview_replies_by_type_response}" | jq -r --arg k "${overview_record_type}" '.queries.replies[$k] // 0')
        if pihole_munin_graph_zero "overview" || [ "${overview_query_val}" -ne 0 ] || [ "${overview_reply_val}" -ne 0 ]; then
            printf "query_%s.value %s\n" "${overview_record_type}" "${overview_query_val}"
            printf "%s.value %s\n" "${overview_record_type}" "${overview_reply_val}"
        fi
    done
}

###############################################################################
# Fetch Percent Blocked
###############################################################################

pihole_munin_fetch_percent() {
    percent_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    printf "%s" "${percent_response}" | jq -r '.queries | "percent_blocked.value \(.percent_blocked | tonumber | . * 100 | round / 100)"'
}

###############################################################################
# Fetch Privacy Level
###############################################################################

pihole_munin_fetch_privacy() {
    if [ -z "${ftl_response}" ]; then
        ftl_response=$(pihole_munin_state_handler "${info_ftl_url}" ) || exit 1
    fi
    printf "%s" "${ftl_response}" | jq -r '"privacy_level.value \(.ftl.privacy_level)"'
}

###############################################################################
# Fetch Queries Metrics
###############################################################################

pihole_munin_fetch_queries() {
    if [ -z "${queries_response}" ]; then
        queries_response=$(pihole_munin_state_handler "${stats_summary_url}") || exit 1
    fi
    for queries_key in "blocked" "cached" "forwarded"; do
        queries_value=$(printf '%s' "${queries_response}" | jq -r --arg k "${queries_key}" '.queries[$k] // 0')
        if pihole_munin_graph_zero "queries" || [ "${queries_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${queries_key}" "${queries_value}"
        fi
    done
}

###############################################################################
# Fetch Queries by Status Metrics
###############################################################################

pihole_munin_fetch_queries_by_status() {
    if [ -z "${queries_by_status_response}" ]; then
        queries_by_status_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    fi
    printf "%s" "${queries_by_status_response}" | jq -r '.queries.status | to_entries[] | "\(.key) \(.value)"' \
    | while read -r queries_by_status_key queries_by_status_value; do
        if pihole_munin_graph_zero "queries_by_status" || [ "${queries_by_status_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${queries_by_status_key}" "${queries_by_status_value}"
        fi
    done
}

###############################################################################
# Fetch Queries by Type Metrics
###############################################################################

pihole_munin_fetch_queries_by_type() {
    if [ -z "${queries_by_type_response}" ]; then
        queries_by_type_response=$(pihole_munin_state_handler "${stats_query_types_url}" ) || exit 1
    fi
    printf "%s" "${queries_by_type_response}" | jq -r '.types | to_entries[] | "\(.key) \(.value)"' \
    | while read -r queries_by_type_key queries_by_type_value; do
        if pihole_munin_graph_zero "queries_by_type" || [ "${queries_by_type_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${queries_by_type_key}" "${queries_by_type_value}"
        fi
    done
}

###############################################################################
# Fetch Replies Metrics
###############################################################################

pihole_munin_fetch_replies() {
    if [ -z "${replies_response}" ]; then
        replies_response=$(pihole_munin_state_handler "${info_metrics_url}") || exit 1
    fi
    for replies_key in "auth" "forwarded" "local" "optimized" "unanswered"; do
        replies_value=$(printf '%s\n' "${replies_response}" \
            | jq -r --arg k "${replies_key}" '.metrics.dns.replies[$k] // 0')
        if pihole_munin_graph_zero "replies" || [ "${replies_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${replies_key}" "${replies_value}"
        fi
    done
}

###############################################################################
# Fetch Replies by Type Metrics
###############################################################################

pihole_munin_fetch_replies_by_type() {
    if [ -z "${replies_by_type_response}" ]; then
        replies_by_type_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    fi
    printf "%s" "${replies_by_type_response}" | jq -r '.queries.replies | to_entries[] | "\(.key) \(.value)"' \
    | while read -r replies_by_type_key replies_by_type_value; do
        if pihole_munin_graph_zero "replies_by_type" || [ "${replies_by_type_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${replies_by_type_key}" "${replies_by_type_value}"
        fi
    done
}

###############################################################################
# Fetch Blocking Status
###############################################################################

pihole_munin_fetch_status() {
    if [ -z "${status_response}" ]; then
        status_response=$(pihole_munin_state_handler "${dns_blocking_url}" ) || exit 1
    fi
    printf "%s" "${status_response}" | jq -r '.blocking' \
    | while read -r status_key; do
        case "${status_key}" in
            "enabled") status_value="1" ;;
            "disabled") status_value="0" ;;
            *) status_value="-1" ;;
        esac
        printf "blocking_status.value %s\n" "${status_value}"
    done
}

###############################################################################
# Fetch Top Clients Metrics
###############################################################################

pihole_munin_fetch_top_clients() {
    if [ -z "${top_clients_response}" ]; then
        top_clients_response=$(pihole_munin_state_handler "${stats_top_clients_url}?count=${top_clients_n}") || exit 1
    fi
    printf "%s" "${top_clients_response}" | jq -r ".clients[] | \"\(.name) \(.count)\"" | awk 'NF == 2' |
    while read -r client num_queries; do
        top_clients_key="$(printf "%s" "${client}" | tr -c 'a-zA-Z0-9' '_')"
        case "${top_clients_key}" in
            [0-9]*) top_clients_key="top_clients_${top_clients_key}" ;;
        esac
        printf "%s.value %s\n" "${top_clients_key}" "${num_queries}"
    done
    if ! printf "%s" "${top_clients_response}" | jq -e '.clients | length > 0' >/dev/null 2>&1; then
        printf "none.value 0\n"
    fi
}

###############################################################################
# Fetch Top Domains Metrics
###############################################################################

pihole_munin_fetch_top_domains() {
    if [ -z "${top_domains_response}" ]; then
        top_domains_response=$(pihole_munin_state_handler "${stats_top_domains_url}?count=${top_domains_n}") || exit 1
    fi
    printf "%s" "${top_domains_response}" | jq -r ".domains[] | \"\(.domain) \(.count)\"" | awk 'NF == 2' |
    while read -r domain num_queries; do
        top_domains_key="$(printf "%s" "${domain}" | tr -c 'a-zA-Z0-9' '_')"
        case "${top_domains_key}" in
            [0-9]*) top_domains_key="top_domains_${top_domains_key}" ;;
        esac
        printf "%s.value %s\n" "${top_domains_key}" "${num_queries}"
    done
    if ! printf "%s" "${top_domains_response}" | jq -e '.domains | length > 0' >/dev/null 2>&1; then
        printf "none.value 0\n"
    fi
}

###############################################################################
# Fetch Unique Domains
###############################################################################

pihole_munin_fetch_unique() {
    if [ -z "${unique_response}" ]; then
        unique_response=$(pihole_munin_state_handler "${stats_summary_url}") || exit 1
    fi
    printf "%s" "${unique_response}" | jq -r '.queries | "unique_domains.value \(.unique_domains)"'
}

###############################################################################
# Fetch Upstreams Metrics
###############################################################################
# Fetches the count of queries sent to each upstream DNS server.
###############################################################################

pihole_munin_fetch_upstreams() {
    if [ -z "${upstreams_response}" ]; then
        upstreams_response=$(pihole_munin_state_handler "${stats_upstreams_url}") || exit 1
    fi
    printf "%s" "${upstreams_response}" | jq -c '.upstreams[]' | while read -r upstream; do
        raw_name=$(printf '%s' "${upstream}" | jq -r '.name // empty')
        raw_ip=$(printf '%s' "${upstream}" | jq -r '.ip // empty')
        if [ -n "${raw_name}" ] && [ "${raw_name}" != "null" ]; then
            upstreams_key=$(printf "%s" "${raw_name}" | tr -c 'a-zA-Z0-9' '_')
        else
            upstreams_key=$(printf "%s" "${raw_ip}" | tr -c 'a-zA-Z0-9' '_')
        fi
        case "${upstreams_key}" in
            [0-9]*) upstreams_key="upstreams_${upstreams_key}" ;;
        esac
        upstream_count=$(printf '%s' "${upstream}" | jq -r '.count // 0')
        if pihole_munin_graph_zero "upstreams" || [ "${upstream_count}" -ne 0 ]; then
            printf "%s.value %s\n" "${upstreams_key}" "${upstream_count}"
        fi
    done
}

###############################################################################
# Fetch Version Metrics
###############################################################################
# Docker version monitoring is now disabled by default.
# To enable, set: env.version_enable_docker yes
###############################################################################

pihole_munin_fetch_version() {
    if [ -z "${version_response}" ]; then
        version_response=$(pihole_munin_state_handler "${info_version_url}" 2>/dev/null)
    fi
    version_enable_docker="${version_enable_docker:-"no"}"
    for pihole_module in core web ftl docker; do
        if [ "${pihole_module}" = "docker" ] && [ "${version_enable_docker}" != "yes" ]; then
            continue
        fi
        status="-1"
        case "${pihole_module}" in
            "core"|"web"|"ftl")
                local_ver=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.local.version // empty")
                remote_ver=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.remote.version // empty")
                if [ -n "${local_ver}" ] && [ -n "${remote_ver}" ]; then
                    if [ "${local_ver}" = "${remote_ver}" ]; then
                        status="0"
                    else
                        status="1"
                    fi
                fi
                ;;
            "docker")
                local_ver=$(printf '%s' "${version_response}" | jq -r ".version.docker.local // empty")
                remote_ver=$(printf '%s' "${version_response}" | jq -r ".version.docker.remote // empty")
                if [ -n "${local_ver}" ] && [ -n "${remote_ver}" ]; then
                    if [ "${local_ver}" = "${remote_ver}" ]; then
                        status="0"
                    else
                        status="1"
                    fi
                fi
                ;;
        esac
        printf "version_%s.value %s\n" "${pihole_module}" "${status}"
    done
}

###############################################################################
# Fetch Handler: Calls the correct fetch function for the plugin ID
###############################################################################

pihole_munin_fetch_handler() {
    case "${pihole_munin_plugin_id}" in
        "cache") pihole_munin_fetch_cache ;;
        "cache_by_type") pihole_munin_fetch_cache_by_type ;;
        "clients") pihole_munin_fetch_clients ;;
        "dnsmasq") pihole_munin_fetch_dnsmasq ;;
        "domains") pihole_munin_fetch_domains ;;
        "frequency") pihole_munin_fetch_frequency ;;
        "gravity") pihole_munin_fetch_gravity ;;
        "overview") pihole_munin_fetch_overview ;;
        "percent") pihole_munin_fetch_percent ;;
        "privacy") pihole_munin_fetch_privacy ;;
        "queries") pihole_munin_fetch_queries ;;
        "queries_by_status") pihole_munin_fetch_queries_by_status ;;
        "queries_by_type") pihole_munin_fetch_queries_by_type ;;
        "replies") pihole_munin_fetch_replies ;;
        "replies_by_type") pihole_munin_fetch_replies_by_type ;;
        "status") pihole_munin_fetch_status ;;
        "top_clients") pihole_munin_fetch_top_clients ;;
        "top_domains") pihole_munin_fetch_top_domains ;;
        "unique") pihole_munin_fetch_unique ;;
        "upstreams") pihole_munin_fetch_upstreams ;;
        "version") pihole_munin_fetch_version ;;
        *)
            pihole_munin_print_status "‚ùå" "Unknown pihole_munin_ plugin ID '${pihole_munin_plugin_id}'." >&2
            exit 1
            ;;
    esac
}

###############################################################################
# Munin Autoconf Helper
###############################################################################
# Usage:
#   pihole_munin_autoconf
#
# Description:
#   Checks if the plugin can run on this system by verifying required
#   dependencies, Pi-hole command availability (if localhost), and password
#   configuration. Prints "yes" if all checks pass, otherwise prints "no"
#   with a reason.
#
# Logic:
#   - Checks for required command-line dependencies.
#   - If running on localhost, checks for Pi-hole command.
#   - Checks if a password is set for API authentication.
#   - Prints "yes" if all checks pass, "no (<reason>)" otherwise.
#   - Always exits with status 0.
#
# Output:
#   - Prints "yes" if plugin is usable, "no (<reason>)" otherwise.
###############################################################################

pihole_munin_autoconf() {
    if ! pihole_munin_check_dependencies >/dev/null 2>&1; then
        printf "no (missing dependencies)\n"
        exit 0
    fi
    if { [ "${is_localhost}" -eq 1 ]; } && ! command -v pihole >/dev/null 2>&1; then
        printf "no (not a Pi-hole host)\n"
        exit 0
    fi
    if [ "${password_set}" -eq 0 ]; then
        printf "no (no password set)\n"
        exit 0
    fi
    printf "yes\n"
}

###############################################################################
# Plugin List Normalisation Helper
###############################################################################
# Usage:
#   pihole_munin_normalise_plugins <plugin_list>
#
# Description:
#   Cleans up a plugin list string by removing comments and empty lines,
#   normalizing commas and newlines to spaces, and squeezing multiple spaces
#   into one. Produces a space-separated list of plugin names suitable for
#   further processing.
#
# Arguments:
#   $1  plugin_list   - Raw plugin list string (may contain comments, commas
#                       and newlines)
#
# Logic:
#   - Removes comments (lines starting with #).
#   - Removes empty lines.
#   - Converts commas and newlines to spaces.
#   - Squeezes multiple spaces into a single space.
#
# Output:
#   - Prints a normalized, space-separated plugin list.
###############################################################################

pihole_munin_normalise_plugins() {
    printf "%s\n" "${1}" \
        | sed 's/#.*//;/^[[:space:]]*$/d' \
        | tr ',\n' ' ' \
        | tr -s ' '
}

###############################################################################
# Plugin Lists
###############################################################################
# Defines valid and default plugin lists, processes input plugins
###############################################################################

valid_plugins="cache cache_by_type clients dnsmasq domains frequency gravity overview percent privacy queries queries_by_status queries_by_type replies replies_by_type status top_clients top_domains unique upstreams version"

default_plugins="cache cache_by_type frequency overview percent queries queries_by_status queries_by_type replies replies_by_type unique"

if [ -n "${PLUGINS+x}" ]; then
    if printf '%s' "${PLUGINS}" | grep -qw "all"; then
        plugins="${valid_plugins}"
    else
        plugins=$(pihole_munin_normalise_plugins "${PLUGINS}")
    fi
else
    plugins="${default_plugins}"
fi

###############################################################################
# Suggest Plugins
###############################################################################
# Prints all valid plugins, one per line
###############################################################################

pihole_munin_suggest() {
    for plugin in ${valid_plugins}; do
        printf "%s\n" "${plugin}"
    done
}

###############################################################################
# Filter Valid Plugins Helper
###############################################################################
# Usage:
#   pihole_munin_filter_valid_plugins <plugin_list> [warn]
#
# Description:
#   Filters an input list of plugin names, returning only those that are valid
#   according to the known plugins list. Optionally warns about unknown plugins.
#
# Arguments:
#   $1  input_plugin_list   - Space-separated list of plugin names to filter.
#   $2  warn_unknown        - If set to "warn", prints a warning for each unknown plugin.
#
# Logic:
#   - Iterates over each candidate plugin in the input list.
#   - Checks if the candidate is in the valid_plugins list.
#   - Adds valid plugins to the output list.
#   - If warn_unknown is "warn", prints a warning for each unknown plugin.
#   - Trims leading/trailing spaces from the output.
#
# Output:
#   - Prints a space-separated list of valid plugins.
#   - Prints warnings for unknown plugins if enabled.
###############################################################################

pihole_munin_filter_valid_plugins() {
    input_plugin_list="${1}"
    warn_unknown="${2}"
    filtered_plugins=""
    for candidate_plugin in ${input_plugin_list}; do
        is_valid_plugin="0"
        for known_plugin in ${valid_plugins}; do
            if [ "${candidate_plugin}" = "${known_plugin}" ]; then
                is_valid_plugin="1"
                break
            fi
        done
        if [ "${is_valid_plugin}" -eq 1 ]; then
            filtered_plugins="${filtered_plugins} ${candidate_plugin}"
        elif [ "${warn_unknown}" = "warn" ]; then
            pihole_munin_print_status "‚ö†Ô∏è" "Unknown pihole_munin_ plugin '${candidate_plugin}' skipped." >&2
        fi
    done
    printf "%s\n" "$(printf '%s' "${filtered_plugins}" | sed 's/^ *//;s/ *$//')"
}

###############################################################################
# Print Valid Plugins (with warning for unknowns)
###############################################################################

pihole_munin_valid_plugins() {
    pihole_munin_filter_valid_plugins "$plugins" "warn"
}

###############################################################################
# Validate Input Plugins
###############################################################################
# Normalises and filters input plugin list
###############################################################################

pihole_munin_validate_input_plugins() {
    input_plugins=$(pihole_munin_normalise_plugins "${1}")
    pihole_munin_filter_valid_plugins "$input_plugins" "warn"
}

###############################################################################
# Root Privilege Helper
###############################################################################
# Usage:
#   pihole_munin_root [<args>]
#
# Description:
#   Ensures the script is running with root privileges. If not, attempts to
#   re-execute itself via 'sudo', passing all arguments and setting an
#   environment variable to indicate privilege elevation. Prints status
#   messages for privilege escalation and errors.
#
# Arguments:
#   <args>   - Arguments to pass to the script after re-exec (optional)
#
# Logic:
#   - Checks if the current user is root.
#   - If not root and 'sudo' is available, re-executes the script via 'sudo'.
#   - Sets PIHOLE_MUNIN_PRIVS_ELEVATED_BY_SUDO=1 for tracking.
#   - Prints error and exits if 'sudo' is not available or escalation fails.
#
# Output:
#   - Prints status messages for privilege escalation.
#   - Exits with error if unable to acquire root privileges.
###############################################################################

pihole_munin_root() {
    if [ "$(id -u)" -ne 0 ]; then
        if command -v sudo >/dev/null 2>&1; then
            pihole_munin_print_status "üõ°Ô∏è" "Acquiring root privileges via 'sudo' ‚Ä¶"
            exec sudo PIHOLE_MUNIN_PRIVS_ELEVATED_BY_SUDO="1" "$(command -v -- "${script_path}")" "$@" || {
                pihole_munin_print_status "‚ùå" "Failed to acquire root privileges." >&2
                exit 1
            }
        else
            pihole_munin_print_status "‚ùå" "Root privileges are required, run as root or install 'sudo'." >&2
            exit 1
        fi
    fi
}

# RFC 3339 timestamp for script header
rfc3339_timestamp=$(date --rfc-3339=seconds)

###############################################################################
# Obligatory Obnoxious ASCII (and Unicode Emoji) Header
###############################################################################

pihole_munin_header() {
    printf "%b\n%b\n%b\n%b\n%b\n%b\n\n%b\n\n%b\n\n%b\n" \
        "${TEXT_RED}          _  _             _                                     _" \
        "${TEXT_ORANGE}   _ __  (_)| |__    ___  | |  ___      _ __ ___   _   _  _ __  (_) _ __" \
        "${TEXT_YELLOW}  | '_ \\ | || '_ \\  / _ \\ | | / _ \\    | '_ \` _ \\ | | | || '_ \\ | || '_ \\\\" \
        "${TEXT_LIGHTGREEN}  | |_) || || | | || (_) || ||  __/ __ | | | | | || |_| || | | || || | | | __" \
        "${TEXT_GREEN}  | .__/ |_||_| |_| \\___/ |_| \\___||__||_| |_| |_| \\__,_||_| |_||_||_| |_||__|" \
        "${TEXT_LIGHTBLUE}  |_|" \
        " ${TEXT_BLUE}[üåø] Branch: ${branch}" \
        " ${TEXT_VIOLET}[‚è±Ô∏è] Runtime: ${rfc3339_timestamp}" \
        " ${TEXT_INDIGO}[üì¶] Version: ${pihole_munin_version}${TEXT_RESET}"
}

###############################################################################
# Safe Path Normalization Helper
###############################################################################
# Usage:
#   pihole_munin_safe_path <path>
#
# Description:
#   Cleans up a filesystem path by removing duplicate slashes and trailing
#   slashes. Produces a normalized path suitable for use in file and directory
#   operations.
#
# Arguments:
#   $1  path   - Input path string to normalize.
#
# Logic:
#   - Replaces multiple consecutive slashes with a single slash.
#   - Removes any trailing slashes from the path.
#
# Output:
#   - Prints the normalized path.
###############################################################################

pihole_munin_safe_path() {
    printf "%s" "$1" | sed -E 's:/+:/:g; s:/*$::'
}

###############################################################################
# Install Argument Parser
###############################################################################
# Usage:
#   parse_install_args [<plugin> ‚Ä¶] [<option>]
#
# Description:
#   Parses command-line arguments for plugin installation and setup. Supports
#   dry run mode, custom plugin paths, and plugin selection. Expands 'all'
#   shortcode to enable every valid plugin. Validates plugin names and warns
#   if none are valid.
#
# Arguments:
#   <plugin> ‚Ä¶   - List of plugins to enable (optional, defaults to all valid)
#   <option>     - Options:
#                -D, dry, --dry-run         Enable dry run mode
#                -P, path, --plugins-path   Specify custom plugins directory
#
# Logic:
#   - Loops through arguments, sets dry_run and custom_path as needed.
#   - Collects plugin names, trims whitespace.
#   - Expands 'all' to all valid plugins.
#   - Validates plugin names, warns and exits if none are valid.
#   - If custom_path is set, overrides plugins_available and related paths.
#
# Output:
#   - Sets dry_run, plugins, plugins_available, and pihole_munin_path variables.
#   - Prints error and exits if no valid plugins are specified.
###############################################################################

parse_install_args() {
    dry_run="0"
    plugins_arg=""
    custom_path=""
    while [ $# -gt 0 ]; do
        case "${1}" in
            "-D"|"dry"|"--dry-run") dry_run="1" ;;
            "-P"|"path"|"--plugins-path")
                shift
                custom_path="${1}"
                ;;
            *)
                plugins_arg="${plugins_arg} ${1}" ;;
        esac
        shift
    done
    plugins_arg=$(printf '%s' "${plugins_arg}" | sed 's/^ *//;s/ *$//')
    if printf '%s' "${plugins_arg}" | grep -qw "all"; then
        plugins_arg="${valid_plugins}"
    fi
    if [ -n "${plugins_arg}" ]; then
        plugins=$(pihole_munin_validate_input_plugins "${plugins_arg}")
        plugins=$(printf '%s' "${plugins}" | sed 's/^ *//;s/ *$//')
        [ -z "${plugins}" ] && {
            pihole_munin_print_status "‚ùå" "No valid plugins specified." >&2
            exit 1
        }
    else
        plugins=$(pihole_munin_valid_plugins)
    fi
    if [ -n "${custom_path}" ]; then
        plugins_available="$(pihole_munin_safe_path "${custom_path}")"
        pihole_munin_path="${plugins_available}/pihole_munin_"
    fi
}

###############################################################################
# Directory Setup
###############################################################################

plugins_available="$(pihole_munin_safe_path "${PLUGINS_AVAILABLE:-"/usr/share/munin/plugins"}")"
plugins_enabled="$(pihole_munin_safe_path "${PLUGINS_ENABLED:-"/etc/munin/plugins"}")"
plugins_config="$(pihole_munin_safe_path "${PLUGINS_CONFIG:-"/etc/munin/plugin-conf.d"}")"
config_file="${plugins_config}/pihole_munin_"
[ -n "${PIHOLE_MUNIN_CONF}" ] && config_file="${PIHOLE_MUNIN_CONF}"
pihole_munin_path="${plugins_available}/pihole_munin_"

###############################################################################
# Required Directory Check Helper
###############################################################################
# Usage:
#   pihole_munin_check_required_dirs <dir1> <dir2> ‚Ä¶
#
# Description:
#   Checks that each specified directory exists. Prints status messages for
#   each directory and exits with an error if any are missing.
#
# Arguments:
#   <dir> ‚Ä¶   - One or more directory paths to check.
#
# Logic:
#   - Iterates over each directory argument.
#   - If a directory does not exist, prints an error and exits.
#   - Prints each checked directory in blue.
#   - Prints success message if all directories exist.
#
# Output:
#   - Prints status and error messages.
#   - Exits with error if any directory is missing.
###############################################################################

pihole_munin_check_required_dirs() {
    dry_run="${dry_run:-"0"}"
    pihole_munin_print_status "üìÅ" "Checking required directories ‚Ä¶"
    for required_dir in "$@"; do
        [ -d "${required_dir}" ] || {
            pihole_munin_print_status "‚ùå" "Missing required directory '${required_dir}' does not exist." >&2
            exit 1
        }
        printf "%b\n" "    ${TEXT_BLUE}${required_dir}${TEXT_RESET}"
    done
    pihole_munin_print_status "‚úÖ" "Success."
}

###############################################################################
# Plugin File Check Helper
###############################################################################
# Usage:
#   pihole_munin_check_plugin_file
#
# Description:
#   Checks if the plugin file exists at the expected path. Prints status
#   messages for the check and exits with an error if the file is missing.
#
# Logic:
#   - Prints status message indicating the check.
#   - Checks if the plugin file exists at ${pihole_munin_path}.
#   - If missing, prints error and exits.
#   - If present, prints the file path in green and a success message.
#
# Output:
#   - Prints status and error messages.
#   - Exits with error if the plugin file is missing.
###############################################################################

pihole_munin_check_plugin_file() {
    dry_run="${dry_run:-"0"}"
    pihole_munin_print_status "üìÑ" "Checking plugin file ‚Ä¶"
    [ -f "${pihole_munin_path}" ] || {
        pihole_munin_print_status "‚ùå" "Plugin file '${pihole_munin_path}' does not exist." >&2
        exit 1
    }
    printf "%b\n" "    ${TEXT_GREEN}${pihole_munin_path}${TEXT_RESET}"
    pihole_munin_print_status "‚úÖ" "Success."
}

###############################################################################
# Config File Creation Helper
###############################################################################
# Usage:
#   pihole_munin_create_config
#
# Description:
#   Creates the plugin config file if it doesn't exist. Sets the plugin user to
#   'pihole' if the CLI password is available, allowing access without root.
#   Handles file creation, permission setting, and prints status messages.
#
# Logic:
#   - Checks if the config file exists.
#   - If not, prints status and creates the file (unless dry run).
#   - Sets permissions to 644.
#   - Adds 'user pihole' if CLI password is available and readable.
#   - Otherwise, writes a minimal config header.
#
# Output:
#   - Creates and configures the plugin config file.
#   - Prints status and error messages.
###############################################################################

pihole_munin_create_config() {
    if [ ! -f "${config_file}" ]; then
        pihole_munin_print_status "üìù" "Creating config file ‚Ä¶
            |   ${TEXT_WHITE}${config_file}${TEXT_RESET}"
        if [ "${dry_run}" -eq 0 ]; then
            touch "${config_file}" || {
                pihole_munin_print_status "‚ùå" "Failed to create config file '${config_file}'." >&2
                exit 1
            }
            chmod 644 "${config_file}" || {
                pihole_munin_print_status "‚ùå" "Failed to set permissions (644) on config file '${config_file}'." >&2
                exit 1
            }
            creation_comment="# Created by pihole_munin plugin installer on ${rfc3339_timestamp}"
            if [ -r "${cli_password}" ] && [ -s "${cli_password}" ]; then
                pihole_munin_safe_write printf "${creation_comment}\n[pihole_munin_*]\nuser pihole\n" > "${config_file}"
            else
                pihole_munin_safe_write printf "${creation_comment}\n[pihole_munin_*]\n" > "${config_file}"
            fi
        fi
        pihole_munin_print_status "‚úÖ" "Success."
    fi
}

###############################################################################
# Suggest Restart Helper
###############################################################################
# Suggests restarting Munin node
###############################################################################

pihole_munin_suggest_restart() {
    pihole_munin_print_status "‚ÑπÔ∏è" "It is recommended to restart the Munin node.\n
        Example:
        |  ${TEXT_GREEN}${pihole_munin_user}@${pihole_munin_host}${TEXT_RESET}:${TEXT_LIGHTBLUE}~${TEXT_RESET}$ ${TEXT_WHITE}sudo systemctl restart munin-node.service${TEXT_RESET}\n
        |  or\n
        |  ${TEXT_GREEN}${pihole_munin_user}@${pihole_munin_host}${TEXT_RESET}:${TEXT_LIGHTBLUE}~${TEXT_RESET}$ ${TEXT_WHITE}sudo service munin-node restart${TEXT_RESET}\n"
}

###############################################################################
# Install Plugin Function
###############################################################################
# Usage:
#   pihole_munin_install [<plugin> ‚Ä¶] [<option>]
#
# Description:
#   Installs the pihole_munin_ plugin and enables selected plugins by creating
#   symlinks in the Munin plugins directory. Handles directory creation,
#   cleans up old symlinks, sets permissions, and prints status messages.
#   Supports dry run mode and custom plugin paths.
#
# Arguments:
#   <plugin> ‚Ä¶   - List of plugins to enable (optional, defaults to all valid)
#   <option>     - Options:
#                -D, dry, --dry-run         Show actions without making changes
#                -P, path, --plugins-path   Specify custom plugins directory
#
# Logic:
#   - Ensures required directories exist, creates if missing.
#   - Copies plugin file and sets permissions (unless dry run).
#   - Removes old plugin symlinks if present.
#   - Enables plugins by creating symlinks.
#   - Suggests adding plugin to PATH if not present.
#   - Suggests restarting munin-node after install.
#
# Output:
#   - Prints status and success/error messages.
#   - Creates symlinks for enabled plugins.
#   - Returns non-zero on error.
###############################################################################

pihole_munin_install() {
    pihole_munin_header
    shift 2
    parse_install_args "$@"
    plugins_to_clean="0"
    if [ ! -d "${plugins_available}" ]; then
        if [ "${dry_run}" -eq 0 ]; then
            mkdir -p "${plugins_available}" || {
                pihole_munin_print_status "‚ùå" "Failed to create directory '${plugins_available}'." >&2
                exit 1
            }
        fi
    fi
    pihole_munin_check_required_dirs "${plugins_available}" "${plugins_enabled}" "${plugins_config}"
    pihole_munin_print_status "‚ö™" "Installing pihole_munin_ plugin file ‚Ä¶
        |   ${TEXT_WHITE}${pihole_munin_path}${TEXT_RESET}" 
    if [ "${dry_run}" -eq 0 ]; then
        cp -f "${script_path}" "${pihole_munin_path}" || {
            pihole_munin_print_status "‚ùå" "Failed to copy plugin to '${pihole_munin_path}'." >&2
            exit 1
        }
        chmod 755 "${pihole_munin_path}" || {
            pihole_munin_print_status "‚ùå" "Failed to set permissions (755) on plugin '${pihole_munin_path}'." >&2
            exit 1
        }
    fi
    pihole_munin_print_status "‚úÖ" "Success."
    for plugin_to_clean in "${plugins_enabled}"/pihole_munin_*; do
        [ ! -e "${plugin_to_clean}" ] && continue
        [ "${plugin_to_clean}" = "${plugins_enabled}/pihole_munin_" ] && continue
        plugins_to_clean="1"
        break
    done
    if [ "$plugins_to_clean" -eq 1 ]; then
        cleaned_any="0"
        for plugin_symlink in "${plugins_enabled}"/pihole_munin_*; do
            [ ! -e "${plugin_symlink}" ] && continue
            plugin_name=$(basename "${plugin_symlink}" | sed 's/^pihole_munin_//')
            if ! printf "%s\n" "${plugins}" | grep -qw "${plugin_name}" && ! printf "%s\n" "${valid_plugins}" | grep -qw "${plugin_name}"; then
                if [ "${cleaned_any}" = "0" ]; then
                    pihole_munin_print_status "üßº" "Cleaning obsolete pihole_munin_ plugin symlinks ‚Ä¶"
                    cleaned_any="1"
                fi
                printf "%b\n" "    ${TEXT_LIGHTBLUE}${plugin_symlink}${TEXT_RESET}"
                if [ "$dry_run" -eq 0 ]; then
                    rm -f "${plugin_symlink}" || {
                        pihole_munin_print_status "‚ùå" "Failed to remove plugin symlink '${plugin_symlink}'." >&2
                        exit 1
                    }
                fi
            fi
        done
        if [ "${cleaned_any}" = "1" ]; then
            pihole_munin_print_status "‚úÖ" "Success."
        fi
    fi
    pihole_munin_check_plugin_file
    pihole_munin_create_config
    pihole_munin_print_status "üü¢" "Enabling selected pihole_munin_ plugins ‚Ä¶"
    for plugin in ${plugins}; do
        if [ "${dry_run}" -eq 0 ]; then
            ln -sf "${pihole_munin_path}" "${plugins_enabled}/pihole_munin_${plugin}" || {
                pihole_munin_print_status "‚ùå" "Failed to create symlink '${plugins_enabled}/pihole_munin_${plugin}''." >&2
                exit 1
            }
        fi
        printf "%b\n" "    ${TEXT_LIGHTBLUE}${plugin}${TEXT_RESET} -> ${TEXT_LIGHTBLUE}${plugins_enabled}/pihole_munin_${plugin}${TEXT_RESET}"
    done
    pihole_munin_print_status "‚úÖ" "Success."
    pihole_munin_suggest_restart
}

###############################################################################
# Flush Plugin State Files
###############################################################################
# Usage:
#   pihole_munin_flush [<option>]
#
# Description:
#   Removes all cached plugin state and seentag files from the plugin state
#   directory, forcing fresh API fetches on the next run.
#   Supports dry run mode to preview actions without making changes.
#
# Arguments:
#   <option>   - Options:
#              -D, dry, --dry-run   Show actions without deleting files
#
# Logic:
#   - Parses options for dry run mode.
#   - Checks for required state directory.
#   - Finds all plugin state files in the state directory.
#   - If no state files are found, prints info message.
#   - Otherwise, prints each file and removes it (unless dry run).
#
# Output:
#   - Prints status and success/error messages.
#   - Removes state files unless dry run is enabled.
###############################################################################

pihole_munin_flush() {
    dry_run="0"
    flushed=0
    for option in "$@"; do
        case "${option}" in
            "-D"|"dry"|"--dry-run") dry_run="1" ;;
        esac
    done
    pihole_munin_check_required_dirs "${pihole_munin_plugstate}"
    statefiles=$(find "${pihole_munin_plugstate}" -maxdepth 1 -type f -name 'pihole_munin_*.state' 2>/dev/null)
    if [ -z "${statefiles}" ]; then
        pihole_munin_print_status "‚ÑπÔ∏è" "No pihole_munin_ plugin state files found."
    else
        pihole_munin_print_status "üöΩ" "Flushing pihole_munin_ plugin state files ‚Ä¶"
        for statefile_to_flush in ${statefiles}; do
            statefile=$(basename "${statefile_to_flush}")
            if [ "$dry_run" -eq 0 ]; then
                if rm -f "${statefile_to_flush}"; then
                    flushed=$((flushed + 1))
                else
                    pihole_munin_print_status "‚ùå" "Failed to remove state file '${statefile_to_flush}'." >&2
                    exit 1
                fi
            fi
            printf "%b\n" "    ${TEXT_LIGHTBLUE}${statefile}${TEXT_RESET}"
        done
        printf "\n [‚ÑπÔ∏è] Flushed %d file%s.\n" \
            "$flushed" "$( [ "$flushed" -eq 1 ] && printf "" || printf "s" )"
        pihole_munin_print_status "‚úÖ" "Success."
    fi
}

###############################################################################
# Uninstall Plugin Function
###############################################################################
# Usage:
#   pihole_munin_uninstall [<plugin> ‚Ä¶] [<option>]
#
# Description:
#   Disables selected pihole_munin_ plugins by removing their symlinks from the
#   Munin plugins directory. If no symlinks remain, removes the plugin file itself.
#   Handles dry run mode, custom plugin paths, and prints status messages.
#
# Arguments:
#   <plugin> ‚Ä¶   - List of plugins to uninstall (optional, defaults to all valid)
#   <option>     - Options:
#                -D, dry, --dry-run         Show actions without making changes
#                -P, path, --plugins-path   Specify custom plugins directory
#
# Logic:
#   - Checks for required directories.
#   - Removes symlinks for each specified plugin.
#   - If no symlinks remain, removes the plugin file.
#   - Advises user to remove plugin from PATH if present.
#   - Suggests restarting munin-node after uninstall.
#   - If symlinks remain, does not remove plugin file to avoid breakage.
#
# Output:
#   - Prints status and success/error messages.
#   - Removes symlinks and plugin file as appropriate.
#   - Returns non-zero on error.
###############################################################################

pihole_munin_uninstall() {
    pihole_munin_header
    shift 2
    parse_install_args "$@"
    pihole_munin_check_required_dirs "${plugins_available}" "${plugins_enabled}"
    pihole_munin_check_plugin_file
    pihole_munin_print_status "üî¥" "Disabling selected pihole_munin_ plugins ‚Ä¶"
    for plugin in ${valid_plugins}; do
        if [ -L "${plugins_enabled}/pihole_munin_${plugin}" ]; then
            if [ "${dry_run}" -eq 0 ]; then
                rm -f "${plugins_enabled}/pihole_munin_${plugin}" || {
                    pihole_munin_print_status "‚ùå" "Failed to remove plugin symlink '${plugins_enabled}/pihole_munin_${plugin}'." >&2
                    exit 1
                }
            fi
            printf "%b\n" "    ${TEXT_LIGHTBLUE}${plugin}${TEXT_RESET} -> ${TEXT_LIGHTBLUE}${plugins_enabled}/pihole_munin_${plugin}${TEXT_RESET}"
        fi
    done
    pihole_munin_print_status "‚úÖ" "Success."
    symlink_count=$(find "${plugins_enabled}" -type l -name 'pihole_munin_*' | wc -l)
    if [ "${symlink_count}" -eq 0 ]; then
        pihole_munin_print_status "üóëÔ∏è" "Uninstalling pihole_munin_ plugin file ‚Ä¶
            |  ${TEXT_WHITE}${pihole_munin_path}${TEXT_RESET}"
        if [ "${dry_run}" -eq 0 ]; then
            rm -f "${pihole_munin_path}" || {
                pihole_munin_print_status "‚ùå" "Failed to remove plugin file '${pihole_munin_path}'." >&2
                exit 1
            }
        fi
    pihole_munin_print_status "‚úÖ" "Success."
    else
        pihole_munin_print_status "‚ÑπÔ∏è" "Not uninstalling pihole_munin_ plugin file.
            |  ${TEXT_GREEN}${pihole_munin_path}${TEXT_RESET}\n
            One or more pihole_munin_ plugins remain enabled.\n
            Not removing the pihole_munin_ plugin file to avoid breakage.\n
            If you wish to remove it, please disable all plugins first."
    fi
    pihole_munin_suggest_restart
 }

###############################################################################
# Safe Write Helper
###############################################################################
# Usage:
#   pihole_munin_safe_write <command> [args...]
#
# Description:
#   Safely runs a write command (such as printf, echo, or sed) and prints an
#   error message if the command fails. Intended for writing to temporary files
#   or config files in a robust manner.
#
# Arguments:
#   <command> [args...]   - The command and arguments to execute for writing.
#
# Logic:
#   - Executes the given command.
#   - If the command fails, prints an error and returns 1.
#
# Output:
#   - Runs the specified write command.
#   - Prints error and returns 1 if the command fails.
###############################################################################

pihole_munin_safe_write() {
    "$@" || { pihole_munin_print_status "‚ùå" "Failed to write to temporary file." >&2; return 1; }
}

###############################################################################
# Safe Move Helper
###############################################################################
# Usage:
#   pihole_munin_safe_move <command> [args...]
#
# Description:
#   Safely runs a move command (such as mv) and prints an error message if the
#   command fails. Intended for moving temporary or config files in a robust manner.
#
# Arguments:
#   <command> [args...]   - The command and arguments to execute for moving.
#
# Logic:
#   - Executes the given command.
#   - If the command fails, prints an error and returns 1.
#
# Output:
#   - Runs the specified move command.
#   - Prints error and returns 1 if the command fails.
###############################################################################

pihole_munin_safe_move() {
    "$@" || { pihole_munin_print_status "‚ùå" "Failed to move temporary file." >&2; return 1; }
}

###############################################################################
# Masked Input Helper
###############################################################################
# Usage:
#   pihole_munin_mask_input
#
# Description:
#   Reads input from the user, masking each character with '*' for privacy.
#   Intended for secure password or sensitive value entry. Handles backspace
#   and enter keys, supports multi-byte input, and restores terminal settings
#   after completion.
#
# Logic:
#   - Disables terminal echo and canonical mode.
#   - Reads input one character at a time, masking with '*'.
#   - Handles backspace to delete characters.
#   - Stops reading on Enter (newline).
#   - Restores terminal settings after input.
#
# Output:
#   - Prints the entered string (unmasked) to stdout.
###############################################################################

pihole_munin_mask_input() {
    input=""
    IFS='
'
    stty -echo -icanon
    while :; do
        input_char=$(dd bs=1 count=1 2>/dev/null | od -An -tx1 | tr -d ' \n')
        case "${input_char}" in
            "0a") break ;;
            "7f"|"08")
                if [ -n "${input}" ]; then
                    input=${input%?}
                    printf '\b \b'
                fi
                ;;
            ??)
                case "${input_char}" in
                    [0-9a-fA-F][0-9a-fA-F])
                        char=$(printf "\\x%s" "${input_char}")
                        input="${input}${char}"
                        printf '*'
                        ;;
                    *) continue ;;
                esac
                ;;
            *) continue ;;
        esac
    done
    pihole_munin_term_cleanup
    printf '%s\n' "${input}"
}

###############################################################################
# Safe Prompt Helper
###############################################################################
# Usage:
#   pihole_munin_safe_prompt
#
# Description:
#   Prompts the user to enter a value twice, masking input for privacy.
#   Confirms that both entries match before proceeding. Intended for secure
#   password or sensitive value entry.
#
# Logic:
#   - Prompts for value and confirmation, masking input with '*'.
#   - If entries do not match, prints error and returns 1.
#   - If entries match, returns success.
#
# Output:
#   - Prints error if entries do not match.
#   - Returns 1 on mismatch, 0 on success.
###############################################################################

pihole_munin_safe_prompt() {
    printf "\nEnter value: "
    first_entry=$(pihole_munin_mask_input)
    printf "Confirm value: "
    second_entry=$(pihole_munin_mask_input)
    if [ "$first_entry" != "$second_entry" ]; then
        pihole_munin_print_status "‚ùå" "Entries do not match." >&2
        return 1
    fi
}

###############################################################################
# Make Temp
###############################################################################
# Usage:
#   pihole_munin_mktemp [<dir>] [<prefix>]
#
# Description:
#   Creates a temporary file in the specified directory with the given prefix.
#   Tries different mktemp syntaxes for compatibility across systems.
#   Prints an error and exits if unable to create the file.
#
# Arguments:
#   <dir>    - Directory to create the temp file in (optional, default: /tmp)
#   <prefix> - Prefix for the temp file name (optional, default: pihole_munin_)
#
# Logic:
#   - Attempts to create a temp file using mktemp with directory and prefix.
#   - Falls back to mktemp -t if the first method fails.
#   - Prints error and exits if both methods fail.
#
# Output:
#   - Prints the path to the created temp file.
#   - Exits with error if creation fails.
###############################################################################

pihole_munin_mktemp() {
    mktemp_dir="${1:-"/tmp"}"
    mktemp_prefix="${2:-"pihole_munin_"}"
    mktemp "${mktemp_dir}/${mktemp_prefix}.XXXXXX" 2>/dev/null || mktemp -t "${mktemp_prefix}.XXXXXX" || {
        pihole_munin_print_status "‚ùå" "Failed to create temporary file in '${mktemp_dir}'." >&2
        exit 1
    }
}

###############################################################################
# Configure Function
###############################################################################
# Usage:
#   pihole_munin_configure <command> [<args>]
#
# Description:
#   Manages Munin plugin configuration variables. Supports listing, adding,
#   and removing variables in the plugin config file. Handles sensitive
#   variables securely and validates plugin lists.
#
# Arguments:
#   <command>   - Action to perform: list, add, remove
#   <args>      - Arguments for the command (variable name, value, etc.)
#
# Logic:
#   - Uses plugins_config or PIHOLE_MUNIN_CONF for config file path.
#   - Creates config file if missing.
#   - "list": Lists all config variables, masking passwords.
#   - "add": Adds or updates a variable, validates plugins, prompts for
#            sensitive values.
#   - "remove": Removes a variable from the config file.
#   - Handles unknown commands with a warning.
#
# Output:
#   - Prints status and success/error messages.
#   - Updates the config file as appropriate.
###############################################################################

pihole_munin_configure() {
    pihole_munin_create_config
    configure_command="${1}"
    shift
    case "${configure_command}" in
        "list")
            [ -f "${config_file}" ] || { pihole_munin_print_status "‚ùå" "Config file '${config_file}' does not exist." >&2; exit 1; }
            pihole_munin_print_status "üîç" "Listing pihole_munin_ plugin config variables ‚Ä¶"
            matches=$(grep -E '^( *env\.| *user\s| *group\s)' "${config_file}")
            [ -z "${matches}" ] && { pihole_munin_print_status "‚ÑπÔ∏è" "No config variables found in '${config_file}'."; exit 0; }
            printf "%s\n" "${matches}" | while IFS= read -r config_line; do
                config_line_stripped=$(printf '%s' "${config_line}" | sed 's/^[[:space:]]*//')
                if printf '%s' "${config_line_stripped}" | grep -qE 'env\.(.*_password|password) '; then
                    list_var=$(printf '%s' "${config_line_stripped}" | awk '{print $1}')
                    list_val=$(printf '%s' "${config_line_stripped}" | cut -d' ' -f2-)
                    list_len=$(printf '%s' "${list_val}" | wc -c)
                    [ "${list_len}" -gt 0 ] && list_len=$((list_len - 1))
                    list_masked=$(printf '%*s' "${list_len}" '' | tr ' ' '*')
                    printf "%b\n" "    ${TEXT_WHITE}${list_var} ${TEXT_RED}${list_masked}${TEXT_RESET}"
                else
                    printf "%b\n" "    ${TEXT_WHITE}${config_line_stripped}${TEXT_RESET}"
                fi
            done
            pihole_munin_print_status "‚úÖ" "Success.\n"
            ;;
        "add")
            [ -z "${1}" ] && {
                pihole_munin_print_status "‚ùå" "No variable name specified for addition." >&2
                exit 1
            }
            add_var="${1}"
            case "${add_var}" in
                "env."*) add_var="${add_var#env.}" ;;
            esac
            shift
            add_val="$*"
            trimmed_value=$(printf '%s' "${add_val}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            if [ "${add_var}" = "plugins" ]; then
                valid_only=$(pihole_munin_validate_input_plugins "${trimmed_value}")
                if [ -z "${valid_only}" ]; then
                    pihole_munin_print_status "‚ùå" "No valid plugins specified for 'plugins' variable." >&2
                    exit 1
                fi
                trimmed_value="${valid_only}"
            fi
            pihole_munin_print_status "‚ûï" "Adding variable to '${config_file}' ‚Ä¶"
            case "${add_var}" in
                "pihole_password")
                    case "${trimmed_value}" in
                        "nopassword"|"none"|"null") : ;;
                        *)
                            pihole_munin_print_status "‚ö†Ô∏è" "Sensitive variable '${add_var}' passed on the command line.\n
                                This may be visible in shell history or process lists.\n" >&2
                            ;;
                    esac
                    if [ -z "${trimmed_value}" ]; then
                        pihole_munin_print_status "‚ö†Ô∏è" "Sensitive variable '${add_var}' detected." >&2
                        pihole_munin_print_status "‚ÑπÔ∏è" "You will be prompted to enter the value securely." >&2
                        if ! pihole_munin_safe_prompt; then
                            exit 1
                        fi
                        trimmed_value="${add_val}"
                    fi
                    ;;
                "app_password")
                    pihole_munin_print_status "‚ö†Ô∏è" "Sensitive variable '${add_var}' passed on the command line.\n
                        This may be visible in shell history or process lists." >&2
                    if [ -z "${trimmed_value}" ]; then
                        pihole_munin_print_status "‚ö†Ô∏è" "Sensitive variable '${add_var}' detected." >&2
                        pihole_munin_print_status "‚ÑπÔ∏è" "You will be prompted to enter the value securely."
                        if ! pihole_munin_safe_prompt; then
                            exit 1
                        fi
                        trimmed_value="${add_val}"
                    fi
                    ;;
            esac
            [ -z "${trimmed_value}" ] && {
                pihole_munin_print_status "‚ùå" "No value specified for variable '${add_var}'." >&2
                exit 1
            }
            case "${add_var}" in
                "user"|"group")
                    add_entry="    ${add_var} ${add_val}"
                    tmp_file=$(pihole_munin_mktemp "${pihole_munin_plugstate}" "pihole_munin_conf_add_${add_var}")
                    pihole_munin_safe_write sed "/^ *${add_var}\s/d" "${config_file}" > "${tmp_file}"
                    ;;
                *)
                    add_entry="    env.${add_var} ${add_val}"
                    tmp_file=$(pihole_munin_mktemp "${pihole_munin_plugstate}" "pihole_munin_conf_add_env_${add_var}")
                    pihole_munin_safe_write sed "/^ *env\.${add_var}\s/d" "${config_file}" > "${tmp_file}"
                    ;;
            esac
            pihole_munin_safe_write printf "%s\n" "${add_entry}" >> "${tmp_file}"
            pihole_munin_safe_move mv "${tmp_file}" "${config_file}"
            printf "%b\n" "${TEXT_WHITE}${add_entry}${TEXT_RESET}"
            pihole_munin_print_status "‚úÖ" "Success.\n"
            ;;
        "remove")
            [ -z "${1}" ] && { pihole_munin_print_status "‚ùå" "No variable name specified for removal." >&2; exit 1; }
            pihole_munin_print_status "‚ûñ" "Removing variable from '${config_file}' ‚Ä¶"
            remove_var="${1}"
            case "${remove_var}" in
                "user")  pattern='^ *user[[:space:]]' ;;
                "group") pattern='^ *group[[:space:]]' ;;
                *)
                    escaped_var=$(printf '%s' "${remove_var}" | sed 's/[][\\.^$*]/\\&/g')
                    pattern="^ *env\.${escaped_var}[[:space:]]"
                    ;;
            esac
            if grep -Eq "${pattern}" "${config_file}"; then
                tmp_file=$(pihole_munin_mktemp "${pihole_munin_plugstate}" "pihole_munin_conf_remove_${remove_var}")
                pihole_munin_safe_write sed "/${pattern}/d" "${config_file}" > "${tmp_file}"
                pihole_munin_safe_move mv "${tmp_file}" "${config_file}"
                printf "%b\n" "    ${TEXT_WHITE}${remove_var}${TEXT_RESET}"
                pihole_munin_print_status "‚úÖ" "Success.\n"
            else
                pihole_munin_print_status "‚ùå" "Variable '${remove_var}' not found in '${config_file}'.\n"
                exit 1
            fi
            ;;
        *)
            pihole_munin_print_status "‚ö†Ô∏è" "Unknown configure command '${configure_command}'." >&2
            ;;
    esac
}

###############################################################################
# Version Comparison Helper
###############################################################################
# Usage:
#   pihole_munin_check <version_a> <version_b>
#
# Description:
#   Compares two version strings (e.g. "1.2.3", "1.2.3-beta") and determines
#   if the first version is newer or equal to the second. Handles semantic
#   versioning and pre-release tags (e.g. beta, rc). Stable releases are
#   always considered newer than pre-releases.
#
# Arguments:
#   $1  version_a   - First version string to compare.
#   $2  version_b   - Second version string to compare.
#
# Logic:
#   - Splits version strings into major, minor, patch, and tag components.
#   - Compares major, minor, and patch numbers numerically.
#   - If numeric parts are equal, compares pre-release tags:
#       * No tag (release) > any tag (pre-release)
#       * If both have tags, compares lexically.
#   - Returns 0 if version_a is newer or equal, 1 if older.
#
# Output:
#   - Returns 0 if version_a >= version_b, 1 otherwise.
###############################################################################

pihole_munin_check() {
    extract_num() { printf '%s' "$1" | grep -oE '^[0-9]+' || printf '0'; }
    extract_tag() { printf '%s' "$1" | grep -oE '[-][a-zA-Z0-9]+' | sed 's/^-//'; }
    IFS=. read -r a b c_extra <<EOF
${1:-"0.0.0"}
EOF
    IFS=. read -r x y z_extra <<EOF
${2:-"0.0.0"}
EOF
    c=$(printf '%s' "${c_extra}" | grep -oE '^[0-9]+')
    z=$(printf '%s' "${z_extra}" | grep -oE '^[0-9]+')
    a=$(extract_num "${a}")
    b=$(extract_num "${b}")
    c=$(extract_num "${c}")
    x=$(extract_num "${x}")
    y=$(extract_num "${y}")
    z=$(extract_num "${z}")
    tag_a=$(extract_tag "${c_extra}")
    tag_x=$(extract_tag "${z_extra}")
    [ "${a}" -gt "${x}" ] && return 0
    [ "${a}" -lt "${x}" ] && return 1
    [ "${b}" -gt "${y}" ] && return 0
    [ "${b}" -lt "${y}" ] && return 1
    [ "${c}" -gt "${z}" ] && return 0
    [ "${c}" -lt "${z}" ] && return 1
    if [ -z "${tag_a}" ] && [ -n "${tag_x}" ]; then
        return 0
    elif [ -n "${tag_a}" ] && [ -z "${tag_x}" ]; then
        return 1
    elif [ -n "${tag_a}" ] && [ -n "${tag_x}" ]; then
        first=$(printf '%s\n' "${tag_a}" "${tag_x}" | sort | head -n1)
        if [ "${tag_a}" = "${tag_x}" ]; then
            return 0
        elif [ "${tag_a}" = "${first}" ]; then
            return 1
        else
            return 0
        fi
    fi
    return 0
}

###############################################################################
# Version Function
###############################################################################
# Usage:
#   pihole_munin_version [<option>]
#
# Description:
#   Prints the current pihole_munin_ plugin version. Optionally checks for
#   updates using a remote DNS TXT record if 'dig' is available, unless
#   the skip option is provided.
#
# Arguments:
#   <option>     - Options:
#                    -S, skip, --skip-version-check   Skip remote version check
#
# Logic:
#   - Parses options for skipping version check.
#   - Prints the current plugin version.
#   - If not skipping and 'dig' is available, checks for updates via DNS TXT.
#   - Compares local and remote version strings.
#   - Prints update info or success message.
#
# Output:
#   - Prints version, update status, and instructions.
#   - Returns non-zero on error.
###############################################################################

pihole_munin_version() {
    skip_check="0"
    for option in "$@"; do
        case "${option}" in
            "-S"|"skip"|"--skip-version-check") skip_check="1" ;;
            *)
                pihole_munin_print_status "‚ö†Ô∏è" "Unknown option '${option}' for version command." >&2
                pihole_munin_help version
                ;;
        esac
    done
    pihole_munin_print_status "üì¶" "Version: ${pihole_munin_version}"
    if [ "${skip_check}" -eq 0 ] && command -v dig >/dev/null 2>&1; then
        remote_version=$(dig +short TXT pihole-munin.sainternet-${branch}.xyz | sed -e 's/[^.0-9]//g')
        pihole_munin_print_status "üîÑ" "Checking for updates ‚Ä¶"
        if [ -n "${remote_version}" ]; then
            if pihole_munin_check "${remote_version}" "${pihole_munin_version}"; then
                printf "%s\n\n" "    ${remote_version}"
                pihole_munin_print_status "üÜï" "A newer version is available."
                pihole_munin_print_status "‚ÑπÔ∏è" \
                    "Run '${script_path} admin update' to update the plugin, or run
                    '${script_path} help admin update' for more information."
            else
                pihole_munin_print_status "‚ÑπÔ∏è" "You are using the latest version."
                pihole_munin_print_status "‚úÖ" "Success."
            fi
        else
            pihole_munin_print_status "‚ùå" "Unable to check for updates via DNS TXT record." >&2
            exit 1
        fi
    fi
}

# Date and time for backup file naming
# Format: YYYY-MM-DD-HH-MM-SS
datetime_timestamp=$(date +%Y-%m-%d-%H-%M-%S)

###############################################################################
# Update/Checkout Plugin Function
###############################################################################
# Usage:
#   pihole_munin_update [<option>]
#   pihole_munin_update checkout [<branch>] [<option>]
#
# Description:
#   Updates or checks out the pihole_munin_ plugin from GitHub.
#   - If called as 'update', performs version comparison and update as before.
#   - If called as 'checkout', installs the latest from the specified branch,
#     skipping version comparison but reporting the current and new version.
#
# Arguments:
#   checkout      - If specified, performs a branch checkout instead of update.
#   <branch>      - Branch to checkout (for 'checkout', default: master)
#   <option>      - Options:
#                   -D, dry, --dry-run         Show actions without making changes
#
# Logic:
#   - Parses options and determines mode (update or checkout).
#   - For 'checkout', fetches from the specified branch, skips version check,
#     but reports current and new version strings.
#   - For 'update', performs version comparison and update as before.
#   - Validates branch existence by checking HTTP status.
#   - Backs up current plugin before installing.
#   - Installs the update and sets permissions.
#   - Suggests restarting munin-node after update.
#
# Output:
#   - Prints status and success/error messages.
#   - Backs up and updates the plugin file.
#   - Returns non-zero on error.
###############################################################################

pihole_munin_update() {
    pihole_munin_header
    dry_run="0"
    mode="update"
    branch="${branch:-"master"}"
    branch_set=""
    for option in "$@"; do
        case "${option}" in
            "checkout") mode="checkout" ;;
            "-D"|"dry"|"--dry-run") dry_run="1" ;;
            *)
                if [ "${mode}" = "checkout" ] && [ -z "${branch_set}" ]; then
                    branch="${option}"
                    branch_set="1"
                fi
                ;;
        esac
    done
    bak_file="$(printf "%s" "pihole_munin_${pihole_munin_version}-${datetime_timestamp}.bak")"
    repo_url="github.com/saint-lascivious/pihole_munin_"
    raw_repo_url="https://${repo_url}/raw/${branch}/pihole_munin_"
    pihole_munin_check_required_dirs "${plugins_available}" "${plugins_enabled}" "${pihole_munin_plugstate}"
    tmp_file=$(pihole_munin_mktemp "${pihole_munin_plugstate}" "pihole_munin_update")
    pihole_munin_check_plugin_file
    branch_status=$(curl -s -o /dev/null -w "%{http_code}" "${raw_repo_url}")
    if [ "${branch_status}" != "200" ]; then
        pihole_munin_print_status "‚ùå" "Branch '${branch}' does not exist." >&2
        rm -f "${tmp_file}"
        exit 1
    fi
    pihole_munin_print_status "‚¨áÔ∏è" "Downloading pihole_munin_ plugin file from '${branch}' branch ‚Ä¶"
    if curl -fsSL "${raw_repo_url}" -o "${tmp_file}"; then
        printf "%s\n" "    ${tmp_file}"
        [ -s "${tmp_file}" ] || {
            pihole_munin_print_status "‚ùå" "Downloaded pihole_munin_ plugin file is empty." >&2
            rm -f "${tmp_file}"
            exit 1
        }
        grep -q '^#!/bin/sh' "${tmp_file}" || {
            pihole_munin_print_status "‚ùå" "Invalid pihole_munin_ plugin file download from '${branch}' branch." >&2
            rm -f "${tmp_file}"
            exit 1
        }
        printf "%b\n" "    ${TEXT_GREEN}${tmp_file}${TEXT_RESET}"
        pihole_munin_print_status "‚úÖ" "Success."
        remote_version=$(grep -E '^version=' "${tmp_file}" | cut -d= -f2)
        local_version=$(grep -E '^version=' "${pihole_munin_path}" | cut -d= -f2)
        version_regex='^[0-9]+(\.[0-9]+){1,2}(-[a-zA-Z0-9]+)?$'
        if [ -z "${local_version}" ]; then
            local_version_display="unknown"
        elif printf '%s' "${local_version}" | grep -Eq "${version_regex}"; then
            local_version_display="${local_version}"
        else
            local_version_display="invalid"
        fi
        if [ -z "${remote_version}" ]; then
            remote_version_display="unknown"
        elif printf '%s' "${remote_version}" | grep -Eq "${version_regex}"; then
            remote_version_display="${remote_version}"
        else
            remote_version_display="invalid"
        fi
        if [ "${mode}" = "update" ]; then
            pihole_munin_print_status "üîÑ" "Comparing versions ‚Ä¶"
            printf "%s\n" \
                "    ${local_version_display} (local)" \
                "    ${remote_version_display} (remote)"
            if [ "${local_version_display}" = "invalid" ] || [ "${remote_version_display}" = "invalid" ]; then
                pihole_munin_print_status "‚ö†Ô∏è" "One or both version strings are invalid." >&2
            fi
            if [ "${local_version_display}" = "unknown" ] || [ "${remote_version_display}" = "unknown" ]; then
                pihole_munin_print_status "‚ö†Ô∏è" "One or both version strings are unknown." >&2
            fi
            if [ "${local_version}" -ge "${remote_version}" ] ||  [ "${local_version_display}" = "invalid" ] \
                || [ "${remote_version_display}" = "invalid" ] || [ "${local_version_display}" = "unknown" ] \
                || [ "${remote_version_display}" = "unknown" ]; then
                if [ -t 0 ]; then
                    printf "\n%s" "    Continue? [y/N] "
                    read -r answer
                    case "${answer}" in
                        [yY]|[yY][eE][sS])
                            pihole_munin_print_status "üöÄ" "Proceeding with update ‚Ä¶"
                            ;;
                        *)
                            pihole_munin_print_status "‚ùå" "Aborted by user." >&2
                            rm -f "${tmp_file}"
                            exit 1
                            ;;
                    esac
                else
                    pihole_munin_print_status "‚ùå" "Non-interactive shell detected, aborting update." >&2
                    rm -f "${tmp_file}"
                    exit 1
                fi
            else
                if ! pihole_munin_check "${remote_version}" "${local_version}"; then
                    pihole_munin_print_status "‚ÑπÔ∏è" "You are already using the latest version."
                    rm -f "${tmp_file}"
                    exit 0
                else
                    pihole_munin_print_status "üÜï" "Remote version is newer, proceeding with update."
                fi
            fi
        else
            pihole_munin_print_status "üîÑ" "Checkout: reporting versions ‚Ä¶"
            printf "%s\n" \
                "    ${local_version_display} (current)" \
                "    ${remote_version_display} (checked out)"
        fi
        pihole_munin_print_status "üíæ" "Backing up '${pihole_munin_path}' ‚Ä¶
            |  ${TEXT_WHITE}${bak_file}${TEXT_RESET}\n"
        if [ "${dry_run}" -eq 0 ]; then
            cp -f "${pihole_munin_path}" "${bak_file}" || {
                pihole_munin_print_status "‚ùå" "Failed to create backup." >&2
                rm -f "${tmp_file}"
                exit 1
            }
            pihole_munin_print_status "‚ÑπÔ∏è" "You can restore this backup at any time.\n
                Example:
                |  ${TEXT_GREEN}${pihole_munin_user}@${pihole_munin_host}${TEXT_RESET}:${TEXT_LIGHTBLUE}~${TEXT_RESET}$ cp -f ${bak_file} ${pihole_munin_path}\n"
        fi
        pihole_munin_print_status "‚úÖ" "Success."
        pihole_munin_print_status "‚öôÔ∏è" "Installing updated pihole_munin_ plugin file ‚Ä¶
            |  ${TEXT_GREEN}${pihole_munin_path}${TEXT_RESET}\n"
        chmod 755 "${tmp_file}" || {
            pihole_munin_print_status "‚ùå" "Failed to set permissions (755) on downloaded file." >&2
            rm -f "${tmp_file}"
            exit 1
        }
        if [ "${dry_run}" -eq 0 ]; then
            mv "${tmp_file}" "${pihole_munin_path}" || {
                pihole_munin_print_status "‚ùå" "Failed to move updated file to '${pihole_munin_path}'." >&2
                rm -f "${tmp_file}"
                exit 1
            }
        fi
        pihole_munin_print_status "‚úÖ" "Success."
        pihole_munin_suggest_restart
    else
        pihole_munin_print_status "‚ùå" "Failed to download pihole_munin_ plugin file from ${branch} branch." >&2
        rm -f "${tmp_file}"
        exit 1
    fi
}

###############################################################################
# Help Function
###############################################################################
# Usage:
#   pihole_munin_help <command> [<subcommand>]
#
# Description:
#   Prints detailed help and usage information for pihole_munin_ commands and
#   subcommands. Handles admin, install, uninstall, update, config, fetch,
#   flush, test, version, and other commands. Provides examples, option lists,
#   and notes for each supported command. If no command is given, prints
#   general help. If an unknown command or subcommand is given, prints a
#   warning and general help.
#
# Arguments:
#   <command>     - Main command or help topic (e.g. admin, install, fetch)
#   <subcommand>  - Subcommand for admin (e.g. add, list, remove, update)
#
# Logic:
#   - Matches command and subcommand to print relevant help text.
#   - Prints usage, description, options, examples, and notes.
#   - If unknown topic, prints warning and general help.
#
# Output:
#   - Prints formatted help and usage information to stdout.
###############################################################################

pihole_munin_help() {
    case "${1}" in
        "-a"|"admin"|"--admin")
            case "${2}" in
                "-A"|"add"|"--add")
                    pihole_munin_print_status "‚ùì" \
                        "${script_path} ${1} ${2} <var> [<val>]\n
                        Add or update a plugin configuration variable.\n
                        Variables SHOULD be entered without the env. prefix, and values SHOULD be
                        without encapsulating quotation.\n
                        You will be prompted to enter the value securely if it is sensitive
                        (e.g. app_password or pihole_password).\n"
                    ;;
                "-i"|"install"|"--install")
                    pihole_munin_print_status "‚ùì" \
                        "${script_path} ${1} ${2} [<plugin> ‚Ä¶] [<option>]\n
                        Install pihole_munin_ and enable plugins.\n
                        This command will install pihole_munin_ and enable the specified plugins.\n
                        If no plugins are specified, the default plugins will be enabled.\n
                        If 'all' is specified as a plugin, all available plugins will be enabled.\n
                        Options:
                        |  -D, dry, --dry-run               Perform a trial run with no changes made.
                        |  -P, path, --plugins-path <dir>   Specify a custom path for pihole_munin_
                        |                                   (default: /usr/share/munin/plugins)\n"
                    ;;
                "-l"|"list"|"--list")
                    pihole_munin_print_status "‚ùì" "${script_path} ${1} ${2}\n
                        List all configured plugin variables.\n
                        Sensitive variables (e.g. passwords) will be masked.\n"
                    ;;
                "-p"|"password"|"--password")
                    pihole_munin_print_status "‚ùì" \
                        "${script_path} ${1} ${2} [<password>]\n
                        Set the Pi-hole password.\n
                        This command will add or update the pihole_password variable in the
                        plugin configuration file.\n"
                    ;;
                "-r"|"remove"|"--remove")
                    pihole_munin_print_status "‚ùì" "${script_path} ${1} ${2} <var>\n
                    Remove a variable from the plugin configuration.\n"
                    ;;
                "-u"|"uninstall"|"--uninstall")
                    pihole_munin_print_status "‚ùì" \
                        "${script_path} ${1} ${2} [<plugin> ‚Ä¶] [<option>]\n
                        Disable plugins and uninstall pihole_munin_.\n
                        This command will remove the specified plugins from the Munin node.\n
                        If no plugins are specified pihole_munin_ will be uninstalled.\n
                        Options:
                        |  -D, dry, --dry-run               Perform a trial run with no changes made.
                        |  -P, path, --plugins-path <dir>   Specify a custom path for pihole_munin_
                        |                                   (default: /usr/share/munin/plugins)\n"
                    ;;
                "-U"|"update"|"--update")
                    pihole_munin_print_status "‚ùì" "${script_path} ${1} ${2} [<option>]\n
                        Update pihole_munin_ to the latest version.\n"
                    pihole_munin_print_status "‚ÑπÔ∏è" \
                        "This command will download the latest version from the GitHub repository
                        and replace the current script.\n
                        Options:
                        |  -D, dry, --dry-run     Perform a trial run with no changes made.\n"
                    ;;
                "" )
                    pihole_munin_print_status "‚ùì" "${script_path} ${1} <subcommand>\n
                        Manage plugin configuration and installation.\n
                        Subcommands:
                        |  -A, add                    Add or update a plugin configuration variable.
                        |  -i, install, --install     Install pihole_munin_ and enable all plugins.
                        |  -l, list                   List all configured plugin variables.
                        |  -p, password               Set the Pi-hole password.
                        |  -r, remove                 Remove a variable from the plugin config.
                        |  -u, uninstall, --uninstall Disable all plugins and uninstall pihole_munin_.
                        |  -U, update                 Update pihole_munin_ to the latest version.\n"
                    ;;
                * )
                    pihole_munin_print_status "‚ö†Ô∏è" "Unknown ${1} subcommand '${2}'" >&2
                    ;;
            esac
            ;;
        "autoconf")
            pihole_munin_print_status "‚ùì" "${script_path} ${1}\n
                A plugin with a capabilities=autoconf magic marker will first be invoked
                with autoconf as the sole argument. When invoked thus the plugin should
                do one of these two:\n
                |  1. Print 'yes' to signal that the plugin thinks it can be useful on this
                |     host\n
                |  2. Print 'no' to signal that the plugin does not think so.\n
                The plugin should always exit 0, even if the response is 'no'.\n
                If the answer was 'yes' and it's not a wildcard plugin, the plugin will
                be linked into the plugins catalog of munin-node.\n"
            ;;
        "-c"|"checkout"|"--checkout")
            pihole_munin_print_status "‚ùì" "${script_path} ${1} [<branch>] [<option>]\n
                Checkout pihole_munin_ from a specified branch.\n
                This command will download the pihole_munin_ plugin file from the
                specified branch and install it, replacing any existing installation.\n
                If no branch is specified, '${branch}' will be used.\n
                Options:
                |  -D, dry, --dry-run     Perform a trial run with no changes made.\n"
            ;;
        "config")
            pihole_munin_print_status "‚ùì" "${script_path} ${1}\n
                The config output describes the plugin and the graph it creates.\n
                The full set of attributes you can use is found in the config reference.\n
                https://guide.munin-monitoring.org/en/master/reference/plugin.html\n"
            ;;
        "fetch")
            pihole_munin_print_status "‚ùì" "${script_path} ${1}\n
                Synonymous with \"\" (no arguments), this is the normal invocation
                of the plugin.\n
                When the node receives a fetch command for a plugin, the plugin is
                invoked without any arguments on the command line and is expected to
                emit one or more 'field.value' attribute values.\n
                One for each thing the plugin observes as defined by the config output.\n
                Plotting of graphs may be disabled by the config output.\n"
            ;;
        "-f"|"flush"|"--flush-state")
            pihole_munin_print_status "‚ùì" \
                "${script_path} ${1} [<option>]\n
                Flush the plugin state files.\n
                This command will remove all cached data for the plugin, forcing a fresh
                fetch on the next run.\n
                Options:
                |  -D, dry, --dry-run      Perform a trial run with no changes made.\n"
            ;;
        "-h"|"help"|"--help")
            pihole_munin_print_status "‚ùì" \
                "${script_path} ${1} <command> [<subcommand>]\n
                Displays general or detailed help for commands and subcommands.\n"
            ;;
        "setpassword")
            pihole_munin_print_status "‚ùì" "${script_path} ${1} [<password>]\n
            Shortcut to set the Pi-hole password.\n
            This command will add or update the pihole_password variable in the
            plugin configuration file.\n"
            ;;
        "suggest")
            pihole_munin_print_status "‚ùì" "${script_path} ${1}\n
                Munin creates one graph per plugin.\n
                To create many graphs from one plugin, you can write a wildcard plugin.\n
                These plugins take one or more bits of configuration from the file name
                it is run as.\n
                The plugin is stored as one file in the directory for available plugins,
                but is linked as multiple files in the directory for enabled plugins.\n
                This creates one graph per link name, using just one plugin as source.\n"
            ;;
        "-v"|"version"|"--version")
            pihole_munin_print_status "‚ùì" "${script_path} ${1} [<option>]\n
                Display the plugin version string.\n
                If not skipped, a check for a newer version will be performed using a
                remote DNS TXT record located at the following domain:
                pihole-munin-master.sainternet.xyz\n
                Options:
                |  -S, skip, --skip-version-check     Skip remote plugin version check.\n"
            ;;
        "")
            pihole_munin_print_status "‚ùì" "${script_path} <command>\n
                Commands:
                |  -a, admin, --admin         Manage plugin configuration and installation.
                |  autoconf                   Check if the plugin can be useful on this host.
                |  -c, checkout, --checkout   Checkout pihole_munin_ from a specified branch.
                |  config                     Generate the plugin configuration.
                |  fetch                      Fetch and format the data for Munin to process.
                |  -f, flush, --flush-state   Flush the plugin state files.
                |  -h, help, --help           Show detailed help information.
                |  setpassword                Shortcut to set the Pi-hole password.
                |  suggest                    List available plugins.
                |  -v, version, --version     Display the plugin version string.\n"
            ;;
        * )
            pihole_munin_print_status "‚ö†Ô∏è" "Unknown help topic '$*'." >&2
            pihole_munin_help
            ;;
    esac
}

###############################################################################
# Argument Parsing and Help Flag Normalization
###############################################################################
# Usage:
#   [script] <command> [<subcommand>] [<args>]
#
# Description:
#   Parses command-line arguments and normalizes the position of the help flag.
#   Ensures that if any help flag (-h, help, --help) is present, it is moved
#   to the front of the argument list for consistent help handling.
#
# Logic:
#   - Iterates through all arguments to detect a help flag.
#   - If help flag is found and not first, rebuilds argument list with help flag first.
#   - Uses 'eval' to reset positional parameters.
#
# Output:
#   - Ensures help flag is always the first argument if present.
###############################################################################

for argument in "$@"; do
    case "${argument}" in
        "-h"|"help"|"--help")
            help_flag="${argument}"
            break
            ;;
    esac
done

if [ -n "${help_flag}" ] && [ "${1}" != "${help_flag}" ]; then
    new_arguments=""
    first="1"
    for argument; do
        if [ "${first}" -eq 1 ] && [ "${argument}" = "${help_flag}" ]; then
            first="0"
            continue
        fi
        new_arguments="${new_arguments:+${new_arguments} }$(printf '%s\n' "${argument}" | sed "s/'/'\\\\''/g; s/^/'/; s/\$/'/")"
    done
    eval "set -- '${help_flag}' ${new_arguments}"
fi

###############################################################################
# Privilege Escalation and Pre-Dispatch
###############################################################################
# Usage:
#   [script] <command> [<subcommand>] [<args>]
#
# Description:
#   Ensures commands requiring root privileges are executed as root.
#   For admin and setpassword commands, checks if root is needed and
#   re-executes via 'sudo' if necessary before main dispatch.
#
# Logic:
#   - Matches admin/setpassword commands and subcommands.
#   - Calls pihole_munin_root to escalate privileges if needed.
#
# Output:
#   - Ensures privileged commands run as root.
###############################################################################

case "${1}" in
    "-a"|"admin"|"--admin")
        case "${2}" in
            "-A"|"add"|"--add") pihole_munin_root "$@" ;;
            "-l"|"list"|"--list") pihole_munin_root "$@" ;;
            "-p"|"password"|"--password") pihole_munin_root "$@" ;;
            "-r"|"remove"|"--remove") pihole_munin_root "$@" ;;
            "-i"|"install"|"--install") pihole_munin_root "$@" ;;
            "-u"|"uninstall"|"--uninstall") pihole_munin_root "$@" ;;
            "-U"|"update"|"--update") pihole_munin_root "$@" ;;
        esac
        ;;
    "-c"|"checkout"|"--checkout") pihole_munin_root "$@" ;;
    "setpassword") pihole_munin_root "$@" ;;
esac

###############################################################################
# Main Command Dispatch Logic
###############################################################################
# Usage:
#   [script] <command> [<subcommand>] [<args>]
#
# Description:
#   Dispatches the main command and subcommand logic for the plugin.
#   Routes each supported command to its corresponding handler function.
#   Handles admin, install, uninstall, update, config, fetch, flush, suggest,
#   version, help, and other commands. Provides fallback to help for unknown
#   or missing commands.
#
# Logic:
#   - Matches first argument to supported commands.
#   - For admin, matches subcommands and shifts arguments as needed.
#   - For help, routes to help handler with topic/subtopic.
#   - For config, fetch, and other plugin commands, calls appropriate handler.
#   - If no command or unknown command, shows help.
#
# Output:
#   - Executes the appropriate handler for each command.
#   - Prints help for unknown or missing commands.
###############################################################################

case "${1}" in
    "-a"|"admin"|"--admin")
        case "${2}" in
            "-A"|"add"|"--add")
                shift 2
                pihole_munin_configure "add" "$@"
                ;;
            "-i"|"install"|"--install") pihole_munin_install "$@" ;;
            "-l"|"list"|"--list") pihole_munin_configure "list" ;;
            "-p"|"password"|"--password")
                shift 2
                pihole_munin_configure "add" "pihole_password" "$@"
                ;;
            "-r"|"remove"|"--remove")
                shift 2
                pihole_munin_configure "remove" "$@"
                ;;
            "-u"|"uninstall"|"--uninstall") pihole_munin_uninstall "$@" ;;
            "-U"|"update"|"--update")
                shift
                pihole_munin_update "update" "$@"
                ;;
            "") pihole_munin_help "${1}" ;;
            *) pihole_munin_help "${1}" "${2}" ;;
        esac
        ;;
    "autoconf") pihole_munin_autoconf ;;
    "-c"|"checkout"|"--checkout")
        shift
        pihole_munin_update "checkout" "$@"
        ;;
    "config")
        pihole_munin_config_handler
        if [ "${MUNIN_CAP_DIRTYCONFIG}" = "1" ]; then
            pihole_munin_fetch_handler
        fi
        ;;
    "fetch") pihole_munin_fetch_handler ;;
    "-f"|"flush"|"--flush-state") pihole_munin_flush "$@" ;;
    "-h"|"help"|"--help")
        case "${2}" in
            "") pihole_munin_help ;;
            "-a"|"admin"|"--admin") pihole_munin_help "${2}" "${3:-}" ;;
            "autoconf"|"config"|"fetch"|"-f"|"flush"|"--flush-state"|"setpassword"|"suggest"|"-v"|"version"|"--version")
                pihole_munin_help "${2}"
                ;;
            "-A"|"add"|"--add"|"-i"|"install"|"--install"|"-l"|"list"|"--list"|"-p"|"password"|"--password"|"-r"|"remove"|"--remove"|"-u"|"uninstall"|"--uninstall"|"-U"|"update"|"--update")
                pihole_munin_help "admin" "${2}"
                ;;
            *)
                pihole_munin_print_status "‚ö†Ô∏è" "Unknown help topic '${2}'." >&2
                pihole_munin_help
                ;;
        esac
        ;;
    "suggest") pihole_munin_suggest ;;
    "setpassword") pihole_munin_configure "add" "pihole_password" "${2:-}" ;;
    "-v"|"version"|"--version")
        shift
        pihole_munin_version "$@"
        ;;
    "") pihole_munin_fetch_handler ;;
    *) pihole_munin_help ;;
esac

###############################################################################
# Picture of a Cat
###############################################################################
# Usage:
#   N/A
#
# Description:
#   Picture of a cat.
#
# Logic:
#   N/A
#
# Output:
#   N/A
###############################################################################
#
#                                   /\_/\
#                                  ( O.O )
#                                   > ^ < ((
#                                  /     \ ))
#                                  \\ | / \/
#                                  ((_|_) _)
#
###############################################################################

exit 0
