#!/bin/sh

#         _  _             _                                     _
#  _ __  (_)| |__    ___  | |  ___      _ __ ___   _   _  _ __  (_) _ __
# | '_ \ | || '_ \  / _ \ | | / _ \    | '_ ` _ \ | | | || '_ \ | || '_ \
# | |_) || || | | || (_) || ||  __/ __ | | | | | || |_| || | | || || | | | __
# | .__/ |_||_| |_| \___/ |_| \___||__||_| |_| |_| \__,_||_| |_||_||_| |_||__|
# |_|

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

###############################################################################
# Contributors
###############################################################################
# - saint-lascivious (Hayden Pearce), 2025
#   https://github.com/saint-lascivious
# - fongd (Derek Fong), 2025
#   https://github.com/fongd
# - Bud, Jae and Tig

###############################################################################
# With Thanks To
###############################################################################
# - https://github.com/dispo2
###############################################################################

###############################################################################
# Initial Setup, Version and Munin Documentation
###############################################################################

# Exit on error
set -e

# Version string components
major_version="6"
minor_version="10"
micro_version="0"
version_tag=""

# Set local version
# May be overridden by environment variable PIHOLE_MUNIN_VERSION
pihole_munin_version="${PIHOLE_MUNIN_VERSION:-${major_version}.${minor_version}.${micro_version}${version_tag}}"

# Munin documentation
: <<=cut
=head1 NAME

pihole_munin_

=head2 VERSION

${pihole_munin_version}

=head1 APPLICABLE SYSTEMS

Pi-hole >= 6.0

=head1 DESCRIPTION

Munin plugins for monitoring various Pi-hole® ≥ 6.0 statistics.

=head1 MAGIC MARKERS

  #%# family=manual
  #%# capabilities=suggest

=head1 WILDCARD PLUGIN

This is a wildcard plugin.

=head2 PLUGINS

Plugins with an asterisk (*) are enabled by default.

  cache*: Shows Pi-hole's cache
  cache_by_type*: Shows Pi-hole's cached records by type
  clients: Shows active and total Pi-hole clients
  dnsmasq: Shows various Pi-hole FTLDNS dnsmasq statistics
  domains: Shows the number of domains being blocked by Pi-hole
  frequency*: Shows Pi-hole's query frequency
  gravity: Shows various Pi-hole gravity database statistics
  overview*: Shows an overview of Pi-hole's DNS traffic
  percent*: Shows Pi-hole's blocked query percentage
  privacy: Shows Pi-hole's privacy level
  queries*: Shows Pi-hole's queries
  queries_by_status*: Shows Pi-hole's queries by status
  queries_by_type*: Shows Pi-hole's queries by record type
  replies*: Shows Pi-hole's replies
  replies_by_type*: Shows Pi-hole's replies by record type
  status: Shows Pi-hole's blocking status
  top_clients: Shows Pi-hole's top clients by query count
  top_domains: Shows Pi-hole's top domains by query count
  unique*: Shows the number of unique domains queried by Pi-hole
  upstreams: Shows the query counts for each of Pi-hole's upstream destinations
  version: Shows the version status of Pi-hole components

You can override which plugins are enabled by setting the 'plugins' variable.

Invalid plugin names will be skipped with a warning.

E.g.

  env.plugins cache clients queries

Note: This affects the 'install', 'test' and 'uninstall' commands if executed via 'munin-run'.

This is somewhat spooky, and ideally should be avoided.

Specify the plugins to be installed via the command line when using the 'admin' command (recommended).

E.g.

  ./pihole_munin_ admin install cache clients queries

If 'all' is specified as a plugin, all available plugins will be enabled.

E.g.

  ./pihole_munin_ admin install all

Or use the PLUGINS environment variable to govern the plugin list when using the 'admin' command.

E.g.

  PLUGINS="cache clients queries" ./pihole_munin_ admin install

=head1 USAGE

Use the 'admin' command to automatically install pihole_munin_ and enable all plugins.

E.g.

  ./pihole_munin_ admin install

Alternatively, you can install manually and link this plugin to /etc/munin/plugins/ as the desired plugin(s) and restart munin-node.

E.g.

  sudo mv pihole_munin_ /usr/share/munin/plugins/pihole_munin_
  sudo chmod +x /usr/share/munin/plugins/pihole_munin_

then to install the default plugins,

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_cache

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_cache_by_type

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_clients

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_frequency

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_overview

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_percent

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_queries

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_queries_by_status

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_queries_by_type

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_replies

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_replies_by_type

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_unique

additiionally, you can install any of the other plugins if desired, e.g.

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_dnsmasq

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_domains

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_gravity

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_privacy

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_status

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_top_clients

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_top_domains

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_upstreams

  sudo ln -s /usr/share/munin/plugins/pihole_munin_ \
    /etc/munin/plugins/pihole_munin_version

and then,

  sudo systemctl restart munin-node.service

=head1 CONFIGURATION

Example configuration for /etc/munin/plugin-conf.d/pihole_munin_

  [pihole_munin_*]
      ### AUTHENTICATION ###

      #### APPLICATION PASSWORD ####

      # A Pi-hole application password may be used to authenticate with the
      # Pi-hole API, this password differs from the web interface password.

      # Example:
      #   env.app_password APP_PASSWORD_HERE

      #### PI-HOLE PASSWORD ####

      # The Pi-hole password may also, but probably shouldn't, be used.

      # Example:
      #   env.pihole_password PIHOLE_PASSWORD_HERE

      #### CLI PASSWORD ####

      # The path at which Pi-hole's CLI password may be found.

      # If found and readable, this password will be used to authenticate
      # with the Pi-hole API if no other password is provided.
      env.cli_password /etc/pihole/cli_pw

      ### API ###

      # These variables are used to construct the base of the API URL.
      env.proto http
      env.host 127.0.0.1
      env.port 80
      env.api /api

      ### ALERTS ###

      # The following variables are used to set the alert thresholds for
      # various plugins.

      # To attempt to remove ambiguity, all <key> field names are the same
      # as the labels used in the graphs, with underscores (_) instead
      # of spaces ( ). These <key> field names are case-sensitive, so
      # ensure that you use the correct case when setting the alert
      # thresholds.

      # To remove any doubt, you can click on the graph in the Munin
      # interface to see the field names used in the graph, and the
      # corresponding internal name.

      # This should always match the label used in the graph, but just
      # in case it doesn't for some reason and you want to set an alert
      # threshold or any other modification, use the internal name.

      # The format for the variables is:
      #   env.<plugin>_<key>_<alert_type>

      # The plugin is the name of the plugin, e.g. cache, clients, etc.

      # The key is the name of the metric, e.g. evicted, active, etc.

      # The alert_type is either crit or warn, for critical and warning alerts
      # respectively.

      # The format for values is either a single value which represents the
      # maximum value before an alert is triggered, or a range of values 
      # separated by a colon, where an alert will be triggered if the value
      # is outside of the specified range.

      # Only individual default values are provided here, the rest are left
      # to the user to configure if desired.

      # percent
      env.percent_percent_blocked_crit 90
      env.percent_percent_blocked_warn 0:85

      # status
      env.status_blocking_status_crit 0:1
      env.status_blocking_status_warn 1:1

      ### PLUGINS ###

      # Plugins with an asterisk (*) are enabled by default.

      # cache*: Shows Pi-hole's cache
      # cache_by_type*: Shows Pi-hole's cached records by type
      # clients: Shows active and total Pi-hole clients
      # dnsmasq: Shows various Pi-hole FTLDNS dnsmasq statistics
      # domains: Shows the number of domains being blocked by Pi-hole
      # frequency*: Shows Pi-hole's query frequency
      # gravity: Shows various Pi-hole gravity database statistics
      # overview*: Shows an overview of Pi-hole's DNS traffic
      # percent*: Shows Pi-hole's blocked query percentage
      # privacy: Shows Pi-hole's privacy level
      # queries*: Shows Pi-hole's queries
      # queries_by_status*: Shows Pi-hole's queries by status
      # queries_by_type*: Shows Pi-hole's queries by record type
      # replies*: Shows Pi-hole's replies
      # replies_by_type*: Shows Pi-hole's replies by record type
      # status: Shows Pi-hole's blocking status
      # top_clients: Shows Pi-hole's top clients by query count
      # top_domains: Shows Pi-hole's top domains by query count
      # unique*: Shows the number of unique domains queried by Pi-hole
      # upstreams: Shows the query counts for each of Pi-hole's upstream destinations
      # version: Shows the version status of Pi-hole components

      # The top N clients and top N domains shown in the top_clients
      # and top_domains plugins may be configured by setting the
      # global top_n variable, or by setting the top_clients_top_n and
      # or top_domains_top_n variables respectively.

      # The format for the variables is:
      #   env.top_n
      #   env.<plugin>_top_n

      # Plugins: top_clients, top_domains

      # The format for the values is a numerical value representing the
      # number of clients or domains to be shown in the graph.

      # The default value is 25, the maximum and minimum values are 100 and 1
      # respectively.

      # You can override which plugins are enabled by setting the 'plugins' variable.

      # Invalid plugin names will be skipped with a warning.

      # Example:
      #   env.plugins cache clients queries

      # Note: This affects the 'install', 'test' and 'uninstall' commands
      # if executed via 'munin-run'.

      # This is somewhat spooky, and ideally should be avoided.

      # Specify the plugins to be installed via the command line when using the
      # 'admin' command (recommended).

      # Example:
      #   ./pihole_munin_ admin install cache clients queries

      # If 'all' is specified as a plugin, all available plugins will be enabled.

      # Example:
      #   ./pihole_munin_ admin install all

      # Or use the PLUGINS environment variable to govern the plugin list
      # when using the 'admin' command.

      # Example:
      #   PLUGINS="cache clients queries" ./pihole_munin_ admin install

      ### GRAPHS ###

      # The following variables are used to set the graphing options.

      #### GRAPH ####

      # The graph value determines wheter graphs are drawn or not.
      env.graph yes

      # The graph value may be overridden on a per-plugin basis by setting the
      # graph_<plugin> variable to the desired value (yes/no).

      #### GRAPH_ARGS ####

      # The graph_args value determines the arguments passed to Munin's
      # graphing engine.
      env.graph_args --lower-limit 0

      # The default graph arguments are:
      #   cache: --lower-limit 0
      #   cache_by_type: --lower-limit 0
      #   clients: --lower-limit 0
      #   dnsmasq: --lower-limit 0
      #   domains: --lower-limit 0
      #   frequency: --lower-limit 0
      #   gravity: --lower-limit 0
      #   overview: --lower-limit 0
      #   percent: --upper-limit 100 --lower-limit 0
      #   privacy: --upper-limit 3 --lower-limit 0
      #   queries: --lower-limit 0
      #   queries_by_status: --lower-limit 0
      #   queries_by_type: --lower-limit 0
      #   replies: --lower-limit 0
      #   replies_by_type: --lower-limit 0
      #   status: --lower-limit -1 --upper-limit 1
      #   top_clients: --lower-limit 0
      #   top_domains: --lower-limit 0
      #   unique: --lower-limit 0
      #   upstreams: --lower-limit 0
      #   version: --lower-limit -1 --upper-limit 1

      # The default graph arguments may be overridden by setting the
      # graph_args_<plugin> variable to the desired arguments.

      #### GRAPH_CATEGORY ####

      # The graph_category value determines the category in which the
      # pihole_munin_* graphs appear in Munin's interface when drawn.
      env.graph_category dns

      # The default graph category may be overridden on a per-plugin basis
      # by setting the graph_category_<plugin> variable to the desired
      # category.

      #### GRAPH_HEIGHT ####

      # The graph_height value determines the height of the graph in Munin's
      # interface.
      env.graph_height 200

      # The graph height may be overridden on a per-plugin basis by setting the
      # graph_height_<plugin> variable to the desired height.

      #### GRAPH_INFO ####

      # The graph_info_* values determine the information displayed in the
      # graph's tooltip in Munin's interface.

      # The default graph information is:
      #   cache: This graph shows Pi-hole's cache, visit \
      #     https://docs.pi-hole.net/ftldns/dns-cache/ for more information
      #   cache_by_type: This graph shows Pi-hole's cached records by type
      #   clients: This graph shows Pi-hole's active and total clients
      #   dnsmasq: This graph shows various Pi-hole dnsmasq statistics
      #   domains: This graph shows Pi-hole's domains being blocked
      #   frequency: This graph shows Pi-hole's query frequency
      #   gravity: This graph shows Pi-hole's gravity database statistics
      #   overview: This graph shows an overview of Pi-hole's DNS traffic
      #   percent: This graph shows Pi-hole's blocked query percentage
      #   privacy: This graph shows Pi-hole's privacy level, visit \
      #     https://docs.pi-hole.net/ftldns/privacylevels/ for more information
      #   queries: This graph shows Pi-hole's queries
      #   queries_by_status: This graph shows Pi-hole's queries by status
      #   queries_by_type: This graph shows Pi-hole's queries by record type
      #   replies: This graph shows Pi-hole's replies
      #   replies_by_type: This graph shows Pi-hole's replies by record type
      #   status: This graph shows Pi-hole's blocking status
      #   top_clients: This graph shows Pi-hole's top clients by query count \
      #     (max <top_n> clients)
      #   top_domains: This graph shows Pi-hole's top domains by query count \
      #     (max <top_n> domains)
      #   upstreams: This graph shows the query counts for each of Pi-hole's \
      #     upstream destinations
      #   unique: This graph shows the number of unique domains queried
      #   version: This graph shows the version status of Pi-hole components

      # The default graph information may be overidden by setting the
      # graph_info_<plugin> variable to the desired information.

      #### GRAPH_SCALE ####

      # The graph_scale value determines whether the graph is scaled to fit the
      # data in Munin's interface.
      env.graph_scale no

      # The graph scaling may be overridden on a per-plugin basis by setting
      # the graph_scale_<plugin> variable to the desired value (yes/no).

      #### GRAPH_TITLE ####

      # The graph_title_* values determine the title of the graph in Munin's
      # interface.

      # The default graph titles are:
      #   cache: Pi-hole cache
      #   cache_by_type: Pi-hole cache by type
      #   clients: Pi-hole clients
      #   dnsmasq: Pi-hole dnsmasq
      #   domains: Pi-hole domains being blocked
      #   frequency: Pi-hole query frequency
      #   gravity: Pi-hole gravity database
      #   overview: Pi-hole overview
      #   percent: Pi-hole percent blocked
      #   privacy: Pi-hole privacy level
      #   queries: Pi-hole queries
      #   queries_by_status: Pi-hole queries by status
      #   queries_by_type: Pi-hole queries by type
      #   replies: Pi-hole replies
      #   replies_by_type: Pi-hole replies by type
      #   status: Pi-hole status
      #   top_clients: Pi-hole top clients
      #   top_domains: Pi-hole top domains
      #   unique: Pi-hole unique domains
      #   upstreams: Pi-hole upstream DNS servers
      #   version: Pi-hole version status

      # The default graph titles may be overridden by setting the
      # graph_title_<plugin> variable to the desired title.

      #### GRAPH_TOTAL ####

      # The graph_total_* variables determines whether a total line is drawn in
      # the graph's legend in Munin's interface.

      # Attribute: graph_total
      # Value: string
      # Type: optional
      # Description: If set, summarizes all the data sources' values and
      #   reports the results in an extra row in the legend beneath the graph.
      #   The value you set here is used as label for that line.
      #   Note that, since Munin version 2.1, using the special undef keyword
      #   disables it (to override in munin.conf).

      # The format for the variables is:
      #   env.graph_total_<plugin>

      # Plugins: cache_by_type, queries, queries_by_status, queries_by_type
      # replies and replies_by_type

      # The format for the values is a string containing the label to be
      # displayed in the graph's legend in Munin's interface.
      # E.g. "total", "sum", "all", etc.

      #### GRAPH_VLABEL ####

      # The graph_vlabel_* values determine the vertical label of the graph
      # in Munin's interface.

      # The default graph vertical labels are:
      #   cache: resource records / second
      #   cache_by_type: resource records / second
      #   clients: clients
      #   dnsmasq: count
      #   domains: domains being blocked
      #   frequency: queries / second
      #   gravity: count
      #   overview: queries in (-) | replies out (+) / second
      #   percent: percent blocked
      #   privacy: show all / 1 / 2 / anonymous
      #   queries: queries / second
      #   queries_by_status: queries / second
      #   queries_by_type: queries / second
      #   replies: replies / second
      #   replies_by_type: replies / second
      #   status: unknown / disabled / enabled
      #   top_clients: queries / second
      #   top_domains: queries / second
      #   unique: domains / second
      #   upstreams: queries / second
      #   version: unknown / up-to-date / update available

      # The default graph vertical labels may be overridden by setting the
      # graph_vlabel_<plugin> variable to the desired label.

      #### GRAPH_WIDTH ####

      # The graph_width value determines the width of the graph in Munin's
      # interface.
      env.graph_width 400

      # The graph width may be overridden on a per-plugin basis by setting the
      # graph_width_<plugin> variable to the desired width.

      #### GRAPH_ZERO ####

      # The graph_zero value determines whether or not graphs with multiple
      # fields should graph key value pairs with a value of zero.
      env.graph_zero yes

      # Attribute: graph_zero
      # Value: yes|no
      # Type: optional
      # Description: If set to yes, graphs with multiple fields will graph
      #   key value pairs with a value of zero. This is useful for graphs
      #   with multiple fields where some fields may not have data for a
      #   given time period, as it ensures that the graph will still show
      #   the zero value for those fields, rather than leaving a gap in the
      #   graph. If set to no, those fields will not be graphed at all.

      # Graph zeroing may be overridden on a per-plugin basis by setting
      # the graph_zero_<plugin> variable to the desired value (yes/no).

      # The format for the variables is:
      #   env.graph_zero_<plugin>

      # Plugins: cache, cache_by_type, dnsmasq, gravity, overview,
      # queries, queries_by_status, queries_by_type, replies and
      # replies_by_type

      # The format for the values is either yes or no.

      ### FIELDS ###

      # The following variables determine how graphed fields are displayed in
      # Munin's interface.

      #### FIELDNAME.COLOUR ####

      # Attribute: {fieldname}.colour
      # Value: Hexadecimal colour code
      # Type: optional
      # Description: Custom specification of colour for drawing curve.
      #   Available since 1.2.5 and 1.3.3.
      # Default: Selected by order sequence from Munin standard colour set

      # The format for the variables is:
      #   env.<plugin>_<key>_colour

      # The plugin is the name of the plugin, e.g. cache, clients, etc.

      # The key is the name of the metric, e.g. evicted, active, etc.

      # The format for the values is three or six hexadecimal digits
      # with or without a leading hash (#) character.
      # E.g. #FF0000, 00FF00, 0000FF, #F00, F0F, 0F0, 0F00FF, etc.

      #### FIELDNAME.DRAW ####

      # Attribute: {fieldname}.draw
      # Value: AREA, LINE, LINE[n], STACK, AREASTACK, LINESTACK, LINESTACK[n]
      # Type: optional
      # Description: Determines how the data points are displayed in the graph.
      #   The LINE takes an optional width suffix, commonly LINE1, LINE2, etc…

      # The *STACK values are specific to munin and makes the first a LINE,
      # LINE[n] or AREA datasource, and the rest as STACK.
      # Default: LINE1 since Munin version 2.0.

      # The format for the variables is:
      #   env.<plugin>_<key>_draw

      # The format for the values is the draw style to be used.
      # E.g. LINE1, LINE2, AREA, STACK, etc.

      #### FIELDNAME.GRAPH ####

      # Attribute: {fieldname}.graph
      # Value: yes|no
      # Type: optional
      # Description: Determines if the data source should be visible in
      #   the generated graph.
      # Default: yes

      # The format for the variables is:
      #   env.<plugin>_<key>_graph

      # The format for the values is either yes or no.

      #### FIELDNAME.INFO ####

      # Attribute: {fieldname}.info
      # Value: html text
      # Type: optional
      # Description: Explanation on the data source in this field. The Info is
      #   displayed in the field description table on the detail web page of
      #   the graph.

      # The format for the variables is:
      #   env.<plugin>_<key>_info

      # The format for the values is a string containing the information to be
      # displayed in the graph's tooltip in Munin's interface.

      #### FIELDNAME.LABEL ####

      # Attribute: {fieldname}.label
      # Value: anything except # and \
      # Type: required
      # Description: The label used in the legend for the graph on the HTML
      #   page.

      # The format for the variables is:
      #   env.<plugin>_<key>_label

      # The format for the values is a string containing the label to be
      # displayed in the graph's legend in Munin's interface.
      # The label can contain any special characters except hash (#) or
      # or forward slash (\).

      #### FIELDNAME.MAX ####

      # Attribute: {fieldname}.max
      # Value: numerical of same data type as the field it belongs to.
      # Type: optional
      # Description: Sets a maximum value. If the fetched value is above "max",
      #   it will be discarded.

      # The format for the variables is:
      #   env.<plugin>_<key>_max

      # The format for the values is a numerical value.

      #### FIELDNAME.MIN ####

      # Attribute: {fieldname}.min
      # Value: numerical of same data type as the field it belongs to.
      # Type: optional
      # Description: Sets a minimum value. If the fetched value is below "min",
      #   it will be discarded.

      # The format for the variables is:
      #   env.<plugin>_<key>_min

      # The format for the values is a numerical value.

      #### FIELDNAME.TYPE ####

      # Attribute: {fieldname}.type
      # Value: GAUGE|COUNTER|DERIVE|ABSOLUTE
      # Type: optional
      # Description: Sets the RRD Data Source Type for this field.
      #   The values must be written in capitals. The type used may
      #   introduce restrictions for {fieldname.value}.
      # Default: GAUGE or DERIVE, depending on the plugin.

      # The default type is GAUGE for most plugins, but DERIVE for plugins
      # that deal with counters, such as replies, queries, etc.

      # The type of the field determines how the data is interpreted
      # by Munin's graphing engine. The type may be one of the following:
      #   GAUGE: A value that can go up and down, e.g. temperature, disk
      #   usage, etc.
      #   COUNTER: A value that only goes up, e.g. number of requests, bytes
      #   sent, etc.
      #   DERIVE: A value that can go up and down, but is derived from a
      #   counter, e.g. network traffic, etc.
      #   ABSOLUTE: A value that is an absolute number, e.g. number of users.

      # The format for the variables is:
      #   env.<plugin>_<key>_type

      # The format for the values is the type of graph to be used.
      # E.g. GAUGE, DERIVE, COUNTER, ABSOLUTE, etc.

      ### MISCELLANEOUS ###

      #### USER AND GROUP ####

      # The user these plugins should run as.
      # The pihole user has access to the CLI password by default.
      user pihole

      # The group these plugins should run as.
      # The pihole group has access to the CLI password by default.
      group pihole

      #### STATEFULNESS ####

      # API responses are cached to reduce the number of requests made to the
      # Pi-hole API. This variable determines the time (in seconds) before
      # cached responses are considered stale.
      env.state_ttl 240

      # The *_state_ttl variables can be used to override the default state_ttl
      # value on a per-plugin basis.

      # The default state ttl may be overridden by setting the
      # <plugin>_state_ttl variable to the desired value.

      # The session_ttl variable determines the time (in seconds) before cached
      # session IDs are considered stale.

      # This variable is only used if session_cache is set to 1 (default 0).
      env.session_ttl 300

      # Persistent session caching is disabled by default, but can be enabled
      # by setting the session_cache variable to 1.
      env.session_cache 0

The plugin can be configured manually, or via the command line using the admin command.

E.g.

  ./pihole_munin_ admin add <var> [<val>]
  ./pihole_munin_ admin remove <var>
  ./pihole_munin_ admin list

Variables SHOULD be entered without the env. prefix, and values SHOULD be without encapsulating quotation.

E.g.

  ./pihole_munin_ admin add graph_category dns
  ./pihole_munin_ admin add clients_active_warn 1:50
  ./pihole_munin_ admin add clients_total_warn 100

Sensitive variables such as the Application or Pi-hole Passwords get a special carve outs in the admin command.

Firstly, if entered without a value, both the 'app_password' and 'pihole_password' variables trigger a prompt to enter (and confirm) the password interactively.

E.g.

  ./pihole_munin_ admin add app_password
  ./pihole_munin_ admin add pihole_password

Secondly, if entered with the value 'nopassword', 'none' or 'null', the 'pihole_password' is set to an empty string (internally).

E.g.

  ./pihole_munin_ admin add pihole_password nopassword
  ./pihole_munin_ admin add pihole_password none
  ./pihole_munin_ admin add pihole_password null

=head1 AUTHOR

saint-lascivious (Hayden Pearce), 2025

=head1 LICENSE

GNU GPLv3
=cut

###############################################################################
# Script Path & Plugin ID Detection
###############################################################################

# Determine the path to the script
case "${0}" in
    /*) script_path="${0}" ;;
    *)
        script_path="$(cd "$(dirname "${0}")" && pwd)/$(basename "${0}")"
        ;;
esac

# Extract the plugin ID from the script name
# (e.g., pihole_munin_cache -> cache)
pihole_munin_plugin_id="$(printf "%s" "${script_path}" | sed -e 's/^.*pihole_munin_//')"

# Default to 'percent' plugin if no ID is found
if [ -z "${pihole_munin_plugin_id}" ]; then
    pihole_munin_plugin_id="percent"
fi

###############################################################################
# Password & Host Setup
###############################################################################

password_to_use=""   # Will hold the password used for API authentication
password_set="0"     # Flag: 1 if password is set, 0 otherwise

host="${host:-"127.0.0.1"}"  # Default host is localhost
is_localhost="0"             # Flag: 1 if host is local

cli_password="${cli_password:-/etc/pihole/cli_pw}"  # Path to CLI password file

###############################################################################
# Colour Output Setup
###############################################################################

use_colour="${USE_COLOUR:-1}"  # Enable colour output by default

# Set colour codes if output is a terminal and TERM is not 'dumb'
if [ "${use_colour}" = "1" ] && [ -t 1 ] && [ -n "${TERM}" ] && [ "${TERM}" != "dumb" ]; then
    # ANSI 256-colour codes
    TEXT_WHITE='\033[38;5;15m'
    TEXT_RED='\033[38;5;196m'
    TEXT_ORANGE='\033[38;5;208m'
    TEXT_YELLOW='\033[38;5;226m'
    TEXT_GREEN_HEADER='\033[38;5;46m'
    TEXT_GREEN='\033[38;5;2m'
    TEXT_LIGHTBLUE='\033[38;5;39m'
    TEXT_BLUE='\033[38;5;21m'
    TEXT_INDIGO='\033[38;5;93m'
    TEXT_VIOLET='\033[38;5;201m'
    TEXT_RESET='\033[0m'
else
    # No colour if not a terminal
    TEXT_WHITE=''
    TEXT_RED=''
    TEXT_ORANGE=''
    TEXT_YELLOW=''
    TEXT_GREEN_HEADER=''
    TEXT_GREEN=''
    TEXT_LIGHTBLUE=''
    TEXT_BLUE=''
    TEXT_INDIGO=''
    TEXT_VIOLET=''
    TEXT_RESET=''
fi

###############################################################################
# Protocol Normalisation
###############################################################################

# If 'proto' is set, normalise to lowercase and validate
if [ -n "${proto+x}" ]; then
    proto_normalised=$(printf '%s' "${proto}" | tr '[:upper:]' '[:lower:]')
    case "${proto_normalised}" in
        "http"|"https") proto="${proto_normalised}" ;;
        *)
            printf "%s\n\n%s\n" \
                "  [❌] API variable 'proto' is set to an invalid value." \
                "  [ℹ️] Please set the 'proto' variable to either 'http' or 'https'." >&2
            exit 1
            ;;
    esac
else
    proto="http"  # Default protocol
fi

###############################################################################
# Password Selection Logic
###############################################################################

# Priority: app_password > pihole_password > CLI password file
if [ -n "${app_password+x}" ]; then
    password_to_use="${app_password}"
    password_set="1"
elif [ -n "${pihole_password+set}" ]; then
    case "${pihole_password}" in
        "nopassword"|"none"|"null")
            password_to_use=""
            password_set="1"
            ;;
        "")
            printf "%s\n\n%s\n%s\n%s\n" \
                "  [❌] API variable 'pihole_password' is set to an empty string." \
                "  [ℹ️] Please set the 'pihole_password' variable to a valid password, or set" \
                "       it to one of 'nopassword', 'none' or 'null' if your Pi-hole password" \
                "       is intentionally blank." >&2
            exit 1
            ;;
        *)
            password_to_use="${pihole_password}"
            password_set="1"
            ;;
    esac
else
    # If no password env var, check if host is local and try CLI password file
    host_normalised=$(printf '%s' "$host" | tr '[:upper:]' '[:lower:]')
    case "${host_normalised}" in
        "127.0.0.1"|"localhost"|"localhost.localdomain"|"::1"|"ip6-localhost"|"ip6-loopback")
            is_localhost="1"
            ;;
    esac
    if [ -r "${cli_password}" ]; then
        if [ -s "${cli_password}" ]; then
            password_to_use=$(cat "${cli_password}")
            password_set="1"
        fi
    fi
fi

###############################################################################
# Terminal Cleanup
###############################################################################

pihole_munin_term_cleanup() {
    # Restore terminal settings and print newline
    stty sane
    printf '\n'
}

###############################################################################
# Abort Handler
###############################################################################

pihole_munin_abort_handler() {
    # Perform terminal cleanup
    pihole_munin_term_cleanup
    # Print abort message and exit with code 130
    printf "%b\n" "  [❌] ${TEXT_RED}Aborted (SIGINT).${TEXT_RESET}" >&2
    exit 130
}

# Shellcheck seems to just give up parsing traps in arbirarily large scripts
# so we have to do this convince it that the functions are used actually used
if [ "${__FUCK_YOU_SHELLCHECK:-}" = "1" ]; then
    pihole_munin_term_cleanup
    pihole_munin_abort_handler
fi

# Trap INT and TERM signals to abort handler
trap pihole_munin_abort_handler INT TERM

###############################################################################
# Munin Field Output Helper
###############################################################################
# Usage:
#   pihole_munin_print <key> <colour> <crit> <draw> <graph> <info> <label> <max> <min> <type> <warn>
#
# Description:
#   Outputs Munin field configuration lines for a single metric key, validating
#   and formatting each attribute as required by Munin's plugin protocol.
#   This function is used to generate the config output for each field in a
#   Munin graph, supporting customisation via environment variables.
#
# Arguments:
#   $1  key_val     - Field name (alphanumeric/underscore, required)
#   $2  colour_val  - Hex colour code (3/6 digits, optional)
#   $3  crit_val    - Critical threshold (number or range, optional)
#   $4  draw_val    - Draw style (LINE[n], AREA, STACK, etc., optional)
#   $5  graph_val   - Graph flag ("yes"/"no", optional)
#   $6  info_val    - Info string (tooltip, optional)
#   $7  label_val   - Label (legend, required, max 19 chars, no '#' or '\')
#   $8  max_val     - Maximum value (number, optional)
#   $9  min_val     - Minimum value (number, optional)
#   $10 type_val    - Data type (GAUGE, COUNTER, DERIVE, ABSOLUTE, optional)
#   $11 warn_val    - Warning threshold (number or range, optional)
#
# Validation:
#   - key_val must match ^[a-zA-Z_][a-zA-Z0-9_]*$
#   - label_val must not be empty, contain '#' or '\', and is truncated to 19 chars
#   - colour_val accepts 3/6 digit hex (with/without '#'), expands 3 digits to 6
#   - crit_val and warn_val accept single value or colon-separated range
#   - draw_val must match Munin draw styles
#   - graph_val must be "yes" or "no"
#   - type_val must be one of GAUGE, COUNTER, DERIVE, ABSOLUTE
#   - max_val and min_val must be numeric
#
# Output:
#   Prints Munin config lines for each valid attribute, e.g.:
#     <key>.colour <hex>
#     <key>.critical <crit>
#     <key>.draw <draw>
#     <key>.graph <yes|no>
#     <key>.info <info>
#     <key>.label <label>
#     <key>.max <max>
#     <key>.min <min>
#     <key>.type <type>
#     <key>.warning <warn>
#
#   Invalid or missing required arguments cause an error and exit.
###############################################################################

pihole_munin_print() {
    key_val="${1}"
    colour_val="${2}"
    crit_val="${3}"
    draw_val="${4}"
    graph_val="${5}"
    info_val="${6}"
    label_val="${7}"
    max_val="${8}"
    min_val="${9}"
    type_val="${10}"
    warn_val="${11}"
    # Validate key and label
    if ! printf %s "${key_val}" | grep -Eq '^[a-zA-Z_][a-zA-Z0-9_]*$'; then
        printf "%s\n" "  [❌] Invalid or missing key." >&2
        exit 1
    fi
    if [ -z "${label_val}" ] || printf %s "${label_val}" | grep -q '[#\\]'; then
        printf "%s\n" "  [❌] Invalid or missing label." >&2
        exit 1
    fi
    # Output colour if valid hex
    if [ -n "${colour_val}" ] && [ -n "$(printf '%s' "${colour_val}" | tr -d '[:space:]')" ]; then
        colour_val="${colour_val#\#}"
        if printf %s "${colour_val}" | grep -Eq '^[0-9A-Fa-f]{3}$'; then
            r=$(printf %s "${colour_val}" | cut -c1)
            g=$(printf %s "${colour_val}" | cut -c2)
            b=$(printf %s "${colour_val}" | cut -c3)
            colour_val="${r}${r}${g}${g}${b}${b}"
        fi
        if printf %s "${colour_val}" | grep -Eq '^[0-9A-Fa-f]{6}$'; then
            printf "%s.colour %s\n" "${key_val}" "${colour_val}"
        fi
    fi
    # Output critical threshold if valid
    if [ -n "${crit_val}" ] && [ -n "$(printf '%s' "${crit_val}" | tr -d '[:space:]')" ]; then
        if printf %s "${crit_val}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)?(:(-?[0-9]+(\.[0-9]*)?)?)?$|^(-?[0-9]+(\.[0-9]*)?):$'; then
            printf "%s.critical %s\n" "${key_val}" "${crit_val}"
        fi
    fi
    # Output draw style if valid
    if [ -n "${draw_val}" ] && [ -n "$(printf '%s' "${draw_val}" | tr -d '[:space:]')" ]; then
        if printf %s "${draw_val}" | grep -Eq '^LINE[0-9]*$|^AREA$|^STACK$|^AREASTACK$|^LINESTACK[0-9]*$'; then
            printf "%s.draw %s\n" "${key_val}" "${draw_val}"
        fi
    fi
    # Output graph flag if valid
    if [ -n "${graph_val}" ] && [ -n "$(printf '%s' "${graph_val}" | tr -d '[:space:]')" ]; then
        case "${graph_val}" in
            "yes"|"no") printf "%s.graph %s\n" "${key_val}" "${graph_val}" ;;
        esac
    fi
    # Output info string if present
    if [ -n "${info_val}" ] && [ -n "$(printf '%s' "${info_val}" | tr -d '[:space:]')" ]; then
        printf "%s.info %s\n" "${key_val}" "${info_val}"
    fi
    # Truncate label if too long
    if [ "${#label_val}" -gt 19 ]; then
        # Truncate to 16 characters and add ellipsis ('...') for a total of 19
        # characters to indicate that the full label is available in the info
        # string or is otherwise known
        label_val="$(printf "%s" "${label_val}" | cut -c1-16)..."
    fi
    # Output label (always required)
    printf "%s.label %s\n" "${key_val}" "${label_val}"
    # Output max/min/type/warn if valid
    if [ -n "${max_val}" ] && [ -n "$(printf '%s' "${max_val}" | tr -d '[:space:]')" ]; then
        if printf %s "${max_val}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)$'; then
            printf "%s.max %s\n" "${key_val}" "${max_val}"
        fi
    fi
    if [ -n "${min_val}" ] && [ -n "$(printf '%s' "${min_val}" | tr -d '[:space:]')" ]; then
        if printf %s "${min_val}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)$'; then
            printf "%s.min %s\n" "${key_val}" "${min_val}"
        fi
    fi
    if [ -n "${type_val}" ] && [ -n "$(printf '%s' "${type_val}" | tr -d '[:space:]')" ]; then
        case "${type_val}" in
            "GAUGE"|"COUNTER"|"DERIVE"|"ABSOLUTE")
                printf "%s.type %s\n" "${key_val}" "${type_val}"
                ;;
        esac
    fi
    if [ -n "${warn_val}" ] && [ -n "$(printf '%s' "${warn_val}" | tr -d '[:space:]')" ]; then
        if printf %s "${warn_val}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)?(:(-?[0-9]+(\.[0-9]*)?)?)?$|^(-?[0-9]+(\.[0-9]*)?):$'; then
            printf "%s.warning %s\n" "${key_val}" "${warn_val}"
        fi
    fi
}

###############################################################################
# API Endpoint Setup
###############################################################################

proto="${proto:-http}"                          # Default protocol
port="${port:-80}"                              # Default port
api="${api:-/api}"                              # Default API path

api_target="${proto}://${host}:${port}${api}"   # Full API base URL
auth_url="${auth_url:-/auth}"                   # Auth endpoint

auth_required="1"                               # Flag: 1 auth required
already_authed="0"                              # Flag: 1 already authed

###############################################################################
# Authentication Check Function
###############################################################################
# Usage:
#   pihole_munin_auth_check
#
# Description:
#   Determines if authentication is required for the Pi-hole API by sending a
#   request to the authentication endpoint. Parses the HTTP response code and
#   checks the session validity in the JSON response. Sets the global flags
#   'auth_required' and 'already_authed' accordingly.
#
# Logic:
#   - Sends a GET request to the API authentication endpoint.
#   - Parses the response code:
#       * 200: Checks if '.session.valid == true' in the JSON body.
#              If valid, sets 'auth_required=0' and 'already_authed=1'.
#       * 401: Indicates authentication is required; leaves flags unchanged.
#       * Other: Prints error and exits.
#
# Output:
#   - Sets 'auth_required' and 'already_authed' global variables.
#   - Prints error and exits on unexpected response codes.
###############################################################################

pihole_munin_auth_check() {
    check_response=$(curl --connect-timeout 5 -k -s -S -L -w "%{response_code}" "${api_target}${auth_url}")
    check_json=$(printf "%s" "${check_response}" | head -c -3)   # Response body
    check_code=$(printf "%s" "${check_response}" | tail -c 3)    # HTTP status code
    case "${check_code}" in
        "200")
            # If session is valid, no authentication required
            if printf "%s" "${check_json}" | jq -e '.session.valid == true' >/dev/null 2>&1; then
                auth_required="0"
                already_authed="1"
            fi
            ;;
        "401") : ;; # Authentication required, do nothing
        *)
            # Unexpected response code
            printf "%s\n" "  [❌] Unepected response from the API, response code was '${check_code}'." >&2
            exit 1
            ;;
    esac
}

###############################################################################
# Session and State Variables
###############################################################################

session_cache="${session_cache:-"0"}"  # Enable (1), disable (0) session cache
seconds_timestamp=$(date +%s)          # Epoch offset for cache TTL checks

# Directory for plugin state files (default: /tmp)
pihole_munin_plugstate="${PIHOLE_MUNIN_PLUGSTATE:-${MUNIN_PLUGSTATE:-/tmp}}"
mkdir -p "${pihole_munin_plugstate}"   # Ensure state directory exists

###############################################################################
# Authentication Function
###############################################################################
# Usage:
#   pihole_munin_auth
#
# Description:
#   Authenticates with the Pi-hole API using the selected password. Supports
#   session caching to avoid repeated authentication requests. If a valid cached
#   session exists, it is reused; otherwise, a new session is requested.
#
# Logic:
#   - Checks for a valid cached session if session_cache is enabled.
#   - If no valid session, authenticates using the password.
#   - On success, extracts and stores the session ID.
#   - If session caching is enabled, saves session ID and timestamp to disk.
#
# Output:
#   - Sets global variable 'pihole_munin_session_sid' with session ID.
#   - Exits with error if authentication fails or no password is set.
###############################################################################

pihole_munin_auth() {
    pihole_munin_session_file="${pihole_munin_plugstate}/pihole_munin_session.state"
    # If session caching is enabled and session file exists
    if [ "${session_cache}" -eq 1 ] && [ -r "${pihole_munin_session_file}" ]; then
        session_time=$(head -n 1 "${pihole_munin_session_file}")  # Read timestamp from file
        # If cached session is still valid (not expired)
        if [ $((seconds_timestamp - session_time)) -lt "${session_ttl:-300}" ]; then
            pihole_munin_session_sid=$(tail -n 1 "${pihole_munin_session_file}")  # Read session ID
            return 0  # Use cached session
        fi
    fi
    # Fail if no password is set
    if [ "${password_set}" -ne 1 ]; then
        printf "%s\n" "  [❌] No App Password, Pi-hole Password or CLI Password." >&2
        exit 1
    fi
    # Authenticate with API using password
    auth_response=$(curl --connect-timeout 5 -k -s -S -L -o - -w "%{response_code}" "${api_target}${auth_url}" -d "{\"password\":\"${password_to_use}\"}")
    auth_response_json=$(printf "%s" "${auth_response}" | head -c -3)  # Extract JSON body
    auth_response_code=$(printf "%s" "${auth_response}" | tail -c 3)   # Extract HTTP status code
    # If authentication fails, exit
    if [ "${auth_response_code}" -ne 200 ]; then
        printf "%s\n" "  [❌] Could not get Session ID, response code was '${auth_response_code}'." >&2
        exit 1
    fi
    # Extract session ID from JSON response
    pihole_munin_session_sid=$(printf "%s" "${auth_response_json}" | jq -r '.session.sid')
    # If session caching is enabled, save session ID and timestamp to file
    if [ -n "${pihole_munin_session_sid}" ] && [ "${session_cache}" -eq 1 ]; then
        { printf "%s\n%s\n" "${seconds_timestamp}" "${pihole_munin_session_sid}"; } > "${pihole_munin_session_file}"
        chmod 600 "${pihole_munin_session_file}"  # Restrict permissions
    fi
}

###############################################################################
# Logout Function
###############################################################################
# Usage:
#   pihole_munin_logout
#
# Description:
#   Logs out the current Pi-hole API session by sending a DELETE request to the
#   authentication endpoint. Skips logout if session caching is enabled or no
#   session is active.
#
# Logic:
#   - If no session ID or session caching is enabled, does nothing.
#   - Sends DELETE request to API to invalidate the session.
#   - Checks response code for success (200/204).
#   - Prints error and exits if logout fails.
#
# Output:
#   - Invalidates the current session if applicable.
#   - Exits with error if logout fails.
###############################################################################

pihole_munin_logout() {
    [ -z "${pihole_munin_session_sid}" ] && return 0  # No session, nothing to do
    [ "${session_cache}" -eq 1 ] && return 0        # If caching, don't logout
    # Send DELETE request to API to logout session
    logout_code=$(curl --connect-timeout 5 -k -s -S -L -o - \
        -w "%{response_code}" \
        -X DELETE "${api_target}${auth_url}" \
        -H "Accept: application/json" \
        -H "sid: ${pihole_munin_session_sid}")
    case "${logout_code}" in
        "200"|"204") : ;;  # Success codes, do nothing
        *)  # Any other code is a failure
            printf "%s\n" "  [❌] Logout failed, response code was '${logout_code}'.\n" >&2
            exit 1
            ;;
    esac
}

###############################################################################
# Safe Variable Evaluation Helper
###############################################################################
# Usage:
#   pihole_munin_safe_eval <outvar> <prefix> <field> <suffix> <default>
#
# Description:
#   Safely evaluates and sets a variable value from dynamically constructed
#   variable names, supporting plugin-specific overrides and caching.
#   If the constructed variable is unset or invalid, sets the output variable
#   to the provided default value. Caches results for efficiency.
#
# Arguments:
#   $1  outvar   - Name of output variable to set
#   $2  prefix   - Prefix for variable name construction (e.g. "cache_")
#   $3  field    - Main variable key (e.g. "evicted")
#   $4  suffix   - Suffix for variable name construction (e.g. "_crit")
#   $5  default  - Default value if variable is unset or invalid
#
# Logic:
#   - If field is empty or contains invalid characters, sets output to default.
#   - Constructs variable name as <prefix><field><suffix>.
#   - Checks for cached value (_cache_<varname>); uses it if present.
#   - Otherwise, sets output to value of constructed variable or default,
#     and caches the result.
#
# Output:
#   - Sets <outvar> to the resolved value or default.
###############################################################################

pihole_munin_safe_eval() {
    safe_eval_outvar="${1}"     # Output variable name
    safe_eval_prefix="${2}"     # Prefix for variable lookup
    safe_eval_field="${3}"      # Main variable key
    safe_eval_suffix="${4}"     # Suffix for variable lookup
    safe_eval_default="${5}"    # Default value if not set
    : "${safe_eval_default:=}"  # Ensure default is set
    # If field is empty or contains invalid chars, use default
    case "${safe_eval_field}" in
        ''|*[!a-zA-Z0-9_]*)
            eval "${safe_eval_outvar}=\"\${safe_eval_default}\""
            return
            ;;
    esac
    varname="${safe_eval_prefix}${safe_eval_field}${safe_eval_suffix}"  # Construct variable name
    cachevar="_cache_${varname}"  # Construct cache variable name
    # If cached value exists, use it
    eval "if [ \"\${${cachevar}+x}\" = x ]; then ${safe_eval_outvar}=\"\${${cachevar}}\"; return; fi"
    # Otherwise, get value or default, cache it, and set output
    eval "__pihole_munin_tmp_val__=\"\${${varname}:-\${safe_eval_default}}\""
    eval "${cachevar}=\"\${__pihole_munin_tmp_val__}\""
    eval "${safe_eval_outvar}=\"\${__pihole_munin_tmp_val__}\""
}

###############################################################################
# JSON Validation Helper
###############################################################################
# Returns 0 if stdin is valid JSON, else non-zero.
###############################################################################

pihole_munin_validate_json() {
    jq empty >/dev/null 2>&1  # Use jq to check for valid JSON
}

###############################################################################
# State Handler
###############################################################################
# Usage:
#   pihole_munin_state_handler <endpoint>
#
# Description:
#   Handles caching of API responses to disk for a given endpoint, reducing
#   redundant API calls and improving efficiency. Validates cached responses
#   as JSON and supports plugin-specific TTL overrides. If the cache is stale
#   or invalid, fetches a fresh response from the API, saves it, and returns it.
#
# Arguments:
#   $1  endpoint   - API endpoint to fetch and cache (e.g. "/info/metrics")
#
# Logic:
#   - Builds a sanitized state file path for the endpoint.
#   - If a valid cache file exists and is within TTL, returns cached JSON.
#   - If cache is stale or invalid, removes it and fetches fresh data.
#   - Handles authentication if required.
#   - Validates API response as JSON before caching.
#   - Saves new response to state file and returns it.
#   - Logs out if authentication was performed and session caching is disabled.
#
# Output:
#   - Prints valid JSON response for the endpoint.
#   - Returns non-zero on error or invalid response.
###############################################################################

pihole_munin_state_handler() {
    # Build state file path (sanitize endpoint for filename)
    pihole_munin_statefile="${pihole_munin_plugstate}/pihole_munin_$(printf "%s" "${1}" \
        | sed -E 's/[^a-zA-Z0-9]+/_/g; s/^_+//; s/_+$//; s/_+/_/g').state"
    # If state file exists, check if cache is still valid
    if [ -f "${pihole_munin_statefile}" ]; then
        state_time=$(head -n 1 "${pihole_munin_statefile}")  # Read timestamp
        state_ttl="${state_ttl:-240}"                        # Default TTL
        # Allow plugin-specific TTL override
        pihole_munin_safe_eval state_ttl "" "${pihole_munin_plugin_id}_state_ttl" "" "${state_ttl}"
        # If cache is still valid
        if [ $((seconds_timestamp - state_time)) -lt "${state_ttl}" ]; then
            cached_response=$(tail -n +2 "${pihole_munin_statefile}")  # Get cached JSON
            # If cached response is valid JSON, use it
            if printf "%s" "${cached_response}" | pihole_munin_validate_json; then
                printf "%s\n" "${cached_response}"
                return
            else
                rm -f "${pihole_munin_statefile}"  # Remove invalid cache
            fi
        fi
    fi
    did_auth="0"  # Track if we authenticated in this call
    pihole_munin_auth_check  # Check if authentication is needed
    # If authentication is required and not already authenticated, do it
    if [ "${auth_required}" -eq 1 ] && [ "${already_authed}" -eq 0 ]; then
        pihole_munin_auth
        did_auth="1"
    fi
    # Fetch fresh response from API
    response=$(curl --connect-timeout 5 -G -k -s -L \
                    -H "sid: ${pihole_munin_session_sid}" \
                    "${api_target}${1}") || exit 1
    # Validate response is JSON
    if ! printf "%s" "${response}" | pihole_munin_validate_json; then
        return 1
    fi
    # Save new response to state file and output it
    {
        printf "%s\n" \
            "${seconds_timestamp}" \
            "${response}"
    } | tee "${pihole_munin_statefile}" | tail -n +2
    # If we authenticated and session caching is off, logout
    if [ "${auth_required}" -eq 1 ] && [ "${did_auth}" -eq 1 ] && [ "${session_cache}" -ne 1 ]; then
        pihole_munin_logout
    fi
}

###############################################################################
# API Endpoint Variables
###############################################################################

dns_blocking_url="${dns_blocking_url:-"/dns/blocking"}"
info_ftl_url="${info_ftl_url:-/info/ftl}"
info_metrics_url="${info_metrics_url:-"/info/metrics"}"
info_version_url="${info_version_url:-"/info/version"}"
stats_query_types_url="${stats_query_types_url:-"/stats/query_types"}"
stats_summary_url="${stats_summary_url:-"/stats/summary"}"
stats_top_clients_url="${stats_top_clients_url:-"/stats/top_clients"}"
stats_top_domains_url="${stats_top_domains_url:-"/stats/top_domains"}"
stats_upstreams_url="${stats_upstreams_url:-"/stats/upstreams"}"

###############################################################################
# Graph Configuration Variables
###############################################################################

graph="${graph:-"yes"}"                         # Enable graphing
graph_args="${graph_args:-"--lower-limit 0"}"   # Graph arguments
graph_category="${graph_category:-"dns"}"       # Graph category
graph_draw="${graph_draw:-"LINE1"}"             # Graph draw style
graph_height="${graph_height:-"200"}"           # Graph height
graph_scale="${graph_scale:-"no"}"              # Graph scale
graph_type="${graph_type:-"GAUGE"}"             # Graph type
graph_width="${graph_width:-"400"}"             # Graph width

###############################################################################
# Graph Zero Helper
###############################################################################
# Usage:
#   pihole_munin_graph_zero <key>
#
# Description:
#   Determines whether zero values should be graphed for a given key in Munin.
#   Checks for a plugin-specific override (graph_zero_<key>), falling back to
#   the global graph_zero setting if not set. Returns success (0) if enabled,
#   otherwise failure (1).
#
# Arguments:
#   $1  key   - The graph key to check for zeroing (e.g. "cache", "clients")
#
# Logic:
#   - Checks for plugin-specific graph_zero override using safe_eval.
#   - If set to "yes", returns 0 (true); otherwise returns 1 (false).
#   - If not set, falls back to global graph_zero variable.
#
# Output:
#   - Returns 0 if zero values should be graphed for the key, else 1.
###############################################################################

pihole_munin_graph_zero() {
    _graph_zero_key="${1}"  # Key to check
    _graph_zero_result=""
    # Try to get plugin-specific graph_zero setting
    pihole_munin_safe_eval _graph_zero_result "" "graph_zero" "_${_graph_zero_key}" ""
    if [ -n "${_graph_zero_result}" ]; then
        [ "${_graph_zero_result}" = "yes" ] && return 0 || return 1
    fi
    # Fallback to global graph_zero setting
    [ "${graph_zero:-"yes"}" = "yes" ]
}

###############################################################################
# Cache Graph Configuration
###############################################################################

pihole_munin_config_cache() {
    # Default cache graph type and vlabel based on type
    graph_type_cache="${graph_type_cache:-"DERIVE"}"
    if [ "${graph_type_cache}" = "DERIVE" ]; then
        cache_vlabel="resource records / second"
    else
        cache_vlabel="resource records"
    fi
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_cache:-${graph}}" \
        "graph_args ${graph_args_cache:-${graph_args}}" \
        "graph_category ${graph_category_cache:-${graph_category}}" \
        "graph_height ${graph_height_cache:-${graph_height}}" \
        "graph_info ${graph_info_cache:-"This graph shows Pi-hole's cache, visit https://docs.pi-hole.net/ftldns/dns-cache/ for more information"}" \
        "graph_scale ${graph_scale_cache:-${graph_scale}}" \
        "graph_title ${graph_title_cache:-"Pi-hole cache"}" \
        "graph_vlabel ${graph_vlabel_cache:-${cache_vlabel}}" \
        "graph_width ${graph_width_cache:-${graph_width}}"
    # Fetch cache metrics from API (cached if possible)
    cache_response=$(pihole_munin_state_handler "${info_metrics_url}") || exit 1
    # For each cache metric key
    for cache_key in "evicted" "expired" "immortal" "inserted"; do
        # Extract value from JSON, default to 0 if missing
        cache_value=$(printf '%s' "${cache_response}" | jq -r --arg k "${cache_key}" '.metrics.dns.cache[$k] // 0')
        # Only print if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "cache" || [ "${cache_value}" -ne 0 ]; then
            # Load per-key config overrides (colour, crit, draw, etc.)
            pihole_munin_safe_eval cache_colour "cache_" "${cache_key}" "_colour" ""
            pihole_munin_safe_eval cache_crit "cache_" "${cache_key}" "_crit" ""
            pihole_munin_safe_eval cache_draw "cache_" "${cache_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval cache_graph "cache_" "${cache_key}" "_graph" "yes"
            # Conditionally append value to info for DERIVE type
            pihole_munin_safe_eval cache_type "cache_" "${cache_key}" "_type" "${graph_type_cache}"
            if [ "${graph_type_cache:-${cache_type}}" = "DERIVE" ]; then
                if [ "${cache_value}" -eq 1 ]; then
                    cache_info="Pi-hole cache ${cache_key} (${cache_value} record)"
                else
                    cache_info="Pi-hole cache ${cache_key} (${cache_value} records)"
                fi
            else
                pihole_munin_safe_eval cache_info "cache_" "${cache_key}" "_info" "Pi-hole cache ${cache_key}"
            fi
            pihole_munin_safe_eval cache_label "cache_" "${cache_key}" "_label" "${cache_key}"
            pihole_munin_safe_eval cache_max "cache_" "${cache_key}" "_max" ""
            pihole_munin_safe_eval cache_min "cache_" "${cache_key}" "_min" "0"
            pihole_munin_safe_eval cache_warn "cache_" "${cache_key}" "_warn" ""
            # Print Munin field config for this cache key
            pihole_munin_print \
                "${cache_key}" \
                "${cache_colour:-}" \
                "${cache_crit:-}" \
                "${cache_draw:-}" \
                "${cache_graph:-}" \
                "${cache_info:-}" \
                "${cache_label:-}" \
                "${cache_max:-}" \
                "${cache_min:-}" \
                "${cache_type:-}" \
                "${cache_warn:-}"
        fi
    done
}

###############################################################################
# Cache by Type Graph Configuration
###############################################################################

pihole_munin_config_cache_by_type() {
    # Default cache by type graph type and vlabel based on type
    graph_type_cache_by_type="${graph_type_cache_by_type:-"DERIVE"}"
    if [ "${graph_type_cache_by_type}" = "DERIVE" ]; then
        cache_by_type_vlabel="resource records / second"
    else
        cache_by_type_vlabel="resource records"
    fi
    # Optionally add a graph_total line if not "undef"
    [ "${graph_total_cache_by_type:-total}" != "undef" ] && graph_total_line="graph_total ${graph_total_cache_by_type:-total}"
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_cache_by_type:-${graph}}" \
        "graph_args ${graph_args_cache_by_type:-${graph_args}}" \
        "graph_category ${graph_category_cache_by_type:-${graph_category}}" \
        "graph_height ${graph_height_cache_by_type:-${graph_height}}" \
        "graph_info ${graph_info_cache_by_type:-"This graph shows Pi-hole's cached records by type"}" \
        "graph_scale ${graph_scale_cache_by_type:-${graph_scale}}" \
        "graph_title ${graph_title_cache_by_type:-"Pi-hole cache by type"}" \
        ${graph_total_line:+"${graph_total_line}"} \
        "graph_vlabel ${graph_vlabel_cache_by_type:-${cache_by_type_vlabel}}" \
        "graph_width ${graph_width_cache_by_type:-${graph_width}}"
    # Fetch cache by type metrics from API
    cache_by_type_response=$(pihole_munin_state_handler "${info_metrics_url}") || exit 1
    # Iterate over each cache type entry in the JSON
    printf "%s" "${cache_by_type_response}" | jq -c '.metrics.dns.cache.content[]' \
    | while read -r cache_by_type_entry; do
        # Extract type name and counts
        cache_by_type_name=$(printf '%s' "${cache_by_type_entry}" | jq -r '.name')
        cache_by_type_valid=$(printf '%s' "${cache_by_type_entry}" | jq -r '.count.valid')
        cache_by_type_stale=$(printf '%s' "${cache_by_type_entry}" | jq -r '.count.stale')
        # For both valid and stale counts
        for cache_by_type_entry in "valid" "stale"; do
            case "${cache_by_type_entry}" in
                "valid")
                    cache_by_type_key="${cache_by_type_name}"
                    cache_by_type_default_label="${cache_by_type_name}"
                    cache_by_type_value="${cache_by_type_valid}"
                    ;;
                "stale")
                    cache_by_type_key="${cache_by_type_name}_STALE"
                    cache_by_type_default_label="${cache_by_type_name} (stale)"
                    cache_by_type_value="${cache_by_type_stale}"
                    ;;
            esac
            # Only print if graph_zero is enabled or value is non-zero
            if pihole_munin_graph_zero "cache_by_type" || [ "${cache_by_type_value}" -ne 0 ]; then
                # Load per-key config overrides
                pihole_munin_safe_eval cache_by_type_colour "cache_by_type_" "${cache_by_type_key}" "_colour" ""
                pihole_munin_safe_eval cache_by_type_crit "cache_by_type_" "${cache_by_type_key}" "_crit" ""
                pihole_munin_safe_eval cache_by_type_draw "cache_by_type_" "${cache_by_type_key}" "_draw" "${graph_draw}"
                pihole_munin_safe_eval cache_by_type_graph "cache_by_type_" "${cache_by_type_key}" "_graph" "yes"
                pihole_munin_safe_eval cache_by_type_type "cache_by_type_" "${cache_by_type_key}" "_type" "${graph_type_cache_by_type}"
                # Conditionally append value to info for DERIVE type
                if [ "${graph_type_cache_by_type:-${cache_by_type_type}}" = "DERIVE" ]; then
                    if [ "${cache_by_type_value}" -eq 1 ]; then
                        cache_by_type_info="Pi-hole cache type ${cache_by_type_default_label} (${cache_by_type_value} record)"
                    else
                        cache_by_type_info="Pi-hole cache type ${cache_by_type_default_label} (${cache_by_type_value} records)"
                    fi
                else
                    pihole_munin_safe_eval cache_by_type_info "cache_by_type_" "${cache_by_type_key}" "_info" "Pi-hole cache type ${cache_by_type_default_label}"
                fi
                pihole_munin_safe_eval cache_by_type_label "cache_by_type_" "${cache_by_type_key}" "_label" "${cache_by_type_default_label}"
                pihole_munin_safe_eval cache_by_type_max "cache_by_type_" "${cache_by_type_key}" "_max" ""
                pihole_munin_safe_eval cache_by_type_min "cache_by_type_" "${cache_by_type_key}" "_min" "0"
                pihole_munin_safe_eval cache_by_type_warn "cache_by_type_" "${cache_by_type_key}" "_warn" ""
                # Print Munin field config for this cache type key
                pihole_munin_print \
                    "${cache_by_type_key}" \
                    "${cache_by_type_colour:-}" \
                    "${cache_by_type_crit:-}" \
                    "${cache_by_type_draw:-}" \
                    "${cache_by_type_graph:-}" \
                    "${cache_by_type_info:-}" \
                    "${cache_by_type_label:-}" \
                    "${cache_by_type_max:-}" \
                    "${cache_by_type_min:-}" \
                    "${cache_by_type_type:-}" \
                    "${cache_by_type_warn:-}"
            fi
        done
    done
}

###############################################################################
# Top N Limit Enforcement
###############################################################################
# Enforce sensible limits on number of top clients/domains to fetch and display
# (default: 25, min: 1, max: 100)

# Top N Limit Enforcement
top_n="${top_n:-25}"
if [ "${top_n}" -gt 100 ]; then
    top_n="100";
elif [ "${top_n}" -lt 1 ]; then
    top_n="1";
fi

top_clients_n="${top_clients_top_n:-${top_n}}"
if [ "${top_clients_n}" -gt 100 ]; then
    top_clients_n="100";
elif [ "${top_clients_n}" -lt 1 ]; then
    top_clients_n="1";
fi

top_domains_n="${top_domains_top_n:-${top_n}}"
if [ "${top_domains_n}" -gt 100 ]; then
    top_domains_n="100";
elif [ "${top_domains_n}" -lt 1 ]; then
    top_domains_n="1";
fi

###############################################################################
# Clients Graph Configuration
###############################################################################

pihole_munin_config_clients() {
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_clients:-${graph}}" \
        "graph_args ${graph_args_clients:-${graph_args}}" \
        "graph_category ${graph_category_clients:-${graph_category}}" \
        "graph_height ${graph_height_clients:-${graph_height}}" \
        "graph_info ${graph_info_clients:-"This graph shows Pi-hole's active and total clients"}" \
        "graph_scale ${graph_scale_clients:-${graph_scale}}" \
        "graph_title ${graph_title_clients:-"Pi-hole clients"}" \
        "graph_vlabel ${graph_vlabel_clients:-"clients"}" \
        "graph_width ${graph_width_clients:-${graph_width}}"
    # Fetch client metrics from API
    clients_response=$(pihole_munin_state_handler "${stats_summary_url}?count=${top_clients_n}" ) || exit 1
    # Iterate over each client key/value pair
    printf "%s" "${clients_response}" | jq -r '.clients | to_entries[] | "\(.key) \(.value)"' \
    | while read -r clients_key clients_value; do
        # Only print if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "clients" || [ "${clients_value}" -ne 0 ]; then
            case "${clients_key}" in
                "active")
                    # Print Munin field config for active clients
                    pihole_munin_print \
                        "${clients_key}" \
                        "${clients_active_colour:-}" \
                        "${clients_active_crit:-}" \
                        "${clients_active_draw:-${graph_draw}}" \
                        "${clients_active_graph:-"yes"}" \
                        "${clients_active_info:-"Pi-hole active clients"}" \
                        "${clients_active_label:-"${clients_key}"}" \
                        "${clients_active_max:-""}" \
                        "${clients_active_min:-"0"}" \
                        "${clients_active_type:-"${graph_type}"}" \
                        "${clients_active_warn:-}"
                    ;;
                "total")
                    # Print Munin field config for total clients
                    pihole_munin_print \
                        "${clients_key}" \
                        "${clients_total_colour:-}" \
                        "${clients_total_crit:-}" \
                        "${clients_total_draw:-${graph_draw}}" \
                        "${clients_total_graph:-"yes"}" \
                        "${clients_total_info:-"Pi-hole total clients"}" \
                        "${clients_total_label:-"${clients_key}"}" \
                        "${clients_total_max:-""}" \
                        "${clients_total_min:-"0"}" \
                        "${clients_total_type:-"${graph_type}"}" \
                        "${clients_total_warn:-}"
                    ;;
            esac
        fi
    done
}

###############################################################################
# Dnsmasq Graph Configuration
###############################################################################

pihole_munin_config_dnsmasq() {
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_dnsmasq:-${graph}}" \
        "graph_args ${graph_args_dnsmasq:-${graph_args}}" \
        "graph_category ${graph_category_dnsmasq:-${graph_category}}" \
        "graph_height ${graph_height_dnsmasq:-${graph_height}}" \
        "graph_info ${graph_info_dnsmasq:-"This graph shows various Pi-hole dnsmasq statistics"}" \
        "graph_scale ${graph_scale_dnsmasq:-${graph_scale}}" \
        "graph_title ${graph_title_dnsmasq:-"Pi-hole dnsmasq"}" \
        "graph_vlabel ${graph_vlabel_dnsmasq:-"count"}" \
        "graph_width ${graph_width_dnsmasq:-${graph_width}}"
    # Fetch dnsmasq metrics from API
    dnsmasq_response=$(pihole_munin_state_handler "${info_ftl_url}?count=${top_domains_n}") || exit 1
    # Iterate over each dnsmasq key/value pair
    printf "%s" "${dnsmasq_response}" | jq -r '.ftl.dnsmasq | to_entries[] | "\(.key) \(.value)"' \
    | while read -r dnsmasq_key dnsmasq_value; do
        default_label=$(printf "%s" "${dnsmasq_key}" | sed 's/_/ /g')  # Human-readable label
        # Only print if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "dnsmasq" || [ "${dnsmasq_value}" -ne 0 ]; then
            # Load per-key config overrides
            pihole_munin_safe_eval dnsmasq_colour "dnsmasq_" "${dnsmasq_key}" "_colour" ""
            pihole_munin_safe_eval dnsmasq_crit "dnsmasq_" "${dnsmasq_key}" "_crit" ""
            pihole_munin_safe_eval dnsmasq_draw "dnsmasq_" "${dnsmasq_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval dnsmasq_graph "dnsmasq_" "${dnsmasq_key}" "_graph" "yes"
            pihole_munin_safe_eval dnsmasq_info "dnsmasq_" "${dnsmasq_key}" "_info" "Pi-hole dnsmasq ${default_label}"
            pihole_munin_safe_eval dnsmasq_label "dnsmasq_" "${dnsmasq_key}" "_label" "${default_label}"
            pihole_munin_safe_eval dnsmasq_max "dnsmasq_" "${dnsmasq_key}" "_max" ""
            pihole_munin_safe_eval dnsmasq_min "dnsmasq_" "${dnsmasq_key}" "_min" "0"
            pihole_munin_safe_eval dnsmasq_type "dnsmasq_" "${dnsmasq_key}" "_type" "${graph_type}"
            pihole_munin_safe_eval dnsmasq_warn "dnsmasq_" "${dnsmasq_key}" "_warn" ""
            # Print Munin field config for this dnsmasq key
            pihole_munin_print \
                "${dnsmasq_key}" \
                "${dnsmasq_colour:-}" \
                "${dnsmasq_crit:-}" \
                "${dnsmasq_draw:-}" \
                "${dnsmasq_graph:-}" \
                "${dnsmasq_info:-}" \
                "${dnsmasq_label:-}" \
                "${dnsmasq_max:-}" \
                "${dnsmasq_min:-}" \
                "${dnsmasq_type:-}" \
                "${dnsmasq_warn:-}"
        fi
    done
}

###############################################################################
# Domains Graph Configuration
###############################################################################

pihole_munin_config_domains() {
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_domains:-${graph}}" \
        "graph_args ${graph_args_domains:-${graph_args}}" \
        "graph_category ${graph_category_domains:-${graph_category}}" \
        "graph_height ${graph_height_domains:-${graph_height}}" \
        "graph_info ${graph_info_domains:-"This graph shows Pi-hole's domains being blocked"}" \
        "graph_scale ${graph_scale_domains:-${graph_scale}}" \
        "graph_title ${graph_title_domains:-"Pi-hole domains being blocked"}" \
        "graph_vlabel ${graph_vlabel_domains:-"domains being blocked"}" \
        "graph_width ${graph_width_domains:-${graph_width}}"
    # Print Munin field config for domains being blocked (single value)
    pihole_munin_print \
        "domains_being_blocked" \
        "${domains_domains_being_blocked_colour:-}" \
        "${domains_domains_being_blocked_crit:-}" \
        "${domains_domains_being_blocked_draw:-${graph_draw}}" \
        "${domains_domains_being_blocked_graph:-"yes"}" \
        "${domains_domains_being_blocked_info:-"Pi-hole domains being blocked"}" \
        "${domains_domains_being_blocked_label:-"domains being blocked"}" \
        "${domains_domains_being_blocked_max:-""}" \
        "${domains_domains_being_blocked_min:-"0"}" \
        "${domains_domains_being_blocked_type:-"${graph_type}"}" \
        "${domains_domains_being_blocked_warn:-}"
}

###############################################################################
# Query Frequency Graph Configuration
###############################################################################

pihole_munin_config_frequency() {
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_frequency:-${graph}}" \
        "graph_args ${graph_args_frequency:-${graph_args}}" \
        "graph_category ${graph_category_frequency:-${graph_category}}" \
        "graph_height ${graph_height_frequency:-${graph_height}}" \
        "graph_info ${graph_info_frequency:-"This graph shows Pi-hole's query frequency"}" \
        "graph_scale ${graph_scale_frequency:-${graph_scale}}" \
        "graph_title ${graph_title_frequency:-"Pi-hole query frequency"}" \
        "graph_vlabel ${graph_vlabel_frequency:-"queries / second"}" \
        "graph_width ${graph_width_frequency:-${graph_width}}"
    # Print Munin field config for query frequency (single value)
    pihole_munin_print \
        "frequency" \
        "${frequency_frequency_colour:-}" \
        "${frequency_frequency_crit:-}" \
        "${frequency_frequency_draw:-${graph_draw}}" \
        "${frequency_frequency_graph:-"yes"}" \
        "${frequency_frequency_info:-"Pi-hole query frequency (queries / second)"}" \
        "${frequency_frequency_label:-"frequency"}" \
        "${frequency_frequency_max:-}" \
        "${frequency_frequency_min:-"0"}" \
        "${frequency_frequency_type:-"${graph_type}"}" \
        "${frequency_frequency_warn:-}"
}

###############################################################################
# Gravity Database Graph Configuration
###############################################################################

pihole_munin_config_gravity() {
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_gravity:-${graph}}" \
        "graph_args ${graph_args_gravity:-${graph_args}}" \
        "graph_category ${graph_category_gravity:-${graph_category}}" \
        "graph_height ${graph_height_gravity:-${graph_height}}" \
        "graph_info ${graph_info_gravity:-"This graph shows Pi-hole's gravity database statistics"}" \
        "graph_scale ${graph_scale_gravity:-${graph_scale}}" \
        "graph_title ${graph_title_gravity:-"Pi-hole gravity database"}" \
        "graph_vlabel ${graph_vlabel_gravity:-"count"}" \
        "graph_width ${graph_width_gravity:-${graph_width}}"
    # Fetch gravity database metrics from API
    gravity_response=$(pihole_munin_state_handler "${info_ftl_url}") || exit 1
    # Iterate over each gravity key to display
    for gravity_key in \
        "domains_allowed" \
        "domains_denied" \
        "groups" \
        "lists" \
        "regex_allowed" \
        "regex_denied"; do
        default_label=$(printf '%s\n' "${gravity_key}" | sed 's/_/ /g')  # Human-readable label
        # Determine jq key path based on gravity_key prefix
        case "${gravity_key}" in
            "domains_"*) gravity_jq_key=".ftl.database.domains.${gravity_key#domains_}" ;;
            "regex_"*)   gravity_jq_key=".ftl.database.regex.${gravity_key#regex_}" ;;
            *)           gravity_jq_key=".ftl.database.${gravity_key}" ;;
        esac
        # Extract value from JSON, default to 0 if missing
        gravity_value=$(printf '%s' "${gravity_response}" | jq -r "${gravity_jq_key} // 0")
        # Only print if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "gravity" || [ "${gravity_value}" -ne 0 ]; then
            # Load per-key config overrides
            pihole_munin_safe_eval gravity_colour "gravity_" "${gravity_key}" "_colour" ""
            pihole_munin_safe_eval gravity_crit "gravity_" "${gravity_key}" "_crit" ""
            pihole_munin_safe_eval gravity_draw "gravity_" "${gravity_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval gravity_graph "gravity_" "${gravity_key}" "_graph" "yes"
            pihole_munin_safe_eval gravity_info "gravity_" "${gravity_key}" "_info" "Pi-hole gravity ${default_label}"
            pihole_munin_safe_eval gravity_label "gravity_" "${gravity_key}" "_label" "${default_label}"
            pihole_munin_safe_eval gravity_max "gravity_" "${gravity_key}" "_max" ""
            pihole_munin_safe_eval gravity_min "gravity_" "${gravity_key}" "_min" "0"
            pihole_munin_safe_eval gravity_type "gravity_" "${gravity_key}" "_type" "${graph_type}"
            pihole_munin_safe_eval gravity_warn "gravity_" "${gravity_key}" "_warn" ""
            # Print Munin field config for this gravity key
            pihole_munin_print \
                "${gravity_key}" \
                "${gravity_colour:-}" \
                "${gravity_crit:-}" \
                "${gravity_draw:-}" \
                "${gravity_graph:-}" \
                "${gravity_info:-}" \
                "${gravity_label:-}" \
                "${gravity_max:-}" \
                "${gravity_min:-}" \
                "${gravity_type:-}" \
                "${gravity_warn:-}"
        fi
    done
}

###############################################################################
# Overview Graph Configuration
###############################################################################

pihole_munin_config_overview() {
    # Default overview graph type and vlabel based on type
    graph_type_overview="${graph_type_overview:-"DERIVE"}"
    if [ "${graph_type_overview}" = "DERIVE" ]; then
        overview_vlabel="queries in (-) | replies out (+) / second"
    else
        overview_vlabel="queries in (-) | replies out (+)"
    fi
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_overview:-${graph}}" \
        "graph_args ${graph_args_overview:-${graph_args}}" \
        "graph_category ${graph_category_overview:-${graph_category}}" \
        "graph_height ${graph_height_overview:-${graph_height}}" \
        "graph_info ${graph_info_overview:-"This graph shows an overview of Pi-hole's DNS traffic"}" \
        "graph_scale ${graph_scale_overview:-${graph_scale}}" \
        "graph_title ${graph_title_overview:-"Pi-hole overview"}" \
        "graph_vlabel ${graph_vlabel_overview:-${overview_vlabel}}" \
        "graph_width ${graph_width_overview:-${graph_width}}"
    # Fetch queries by type and replies by type from API
    overview_queries_by_type_response=$(pihole_munin_state_handler "${stats_query_types_url}" ) || exit 1
    overview_replies_by_type_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    # Get all unique record types from both queries and replies
    overview_all_types=$(
        { printf '%s\n' "${overview_queries_by_type_response}" | jq -r '.types | keys_unsorted[]'; \
            printf '%s\n' "${overview_replies_by_type_response}" | jq -r '.queries.replies | keys_unsorted[]'; \
        } | sort -u
    )
    # For each record type, print config and negative mapping
    for overview_record_type in ${overview_all_types}; do
        # Extract values for queries and replies for this type
        overview_query_val=$(printf '%s\n' "${overview_queries_by_type_response}" | jq -r --arg k "${overview_record_type}" '.types[$k] // 0')
        overview_reply_val=$(printf '%s\n' "${overview_replies_by_type_response}" | jq -r --arg k "${overview_record_type}" '.queries.replies[$k] // 0')
        # Only print if graph_zero is enabled or either value is non-zero
        if pihole_munin_graph_zero "overview" || [ "${overview_query_val}" -ne 0 ] || [ "${overview_reply_val}" -ne 0 ]; then
            # Load per-type config overrides
            pihole_munin_safe_eval overview_colour "overview_" "${overview_record_type}" "_colour" ""
            pihole_munin_safe_eval overview_crit "overview_" "${overview_record_type}" "_crit" ""
            pihole_munin_safe_eval overview_draw "overview_" "${overview_record_type}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval overview_graph "overview_" "${overview_record_type}" "_graph" "yes"
            pihole_munin_safe_eval overview_type "overview_" "${overview_record_type}" "_type" "${graph_type_overview}"
            # Conditionally append values to info for DERIVE type
            if [ "${graph_type_overview:-${overview_type}}" = "DERIVE" ]; then
                # Singular/plural for queries
                if [ "${overview_query_val}" -eq 1 ]; then
                    overview_queries_word="query"
                else
                    overview_queries_word="queries"
                fi
                # Singular/plural for replies
                if [ "${overview_reply_val}" -eq 1 ]; then
                    overview_replies_word="reply"
                else
                    overview_replies_word="replies"
                fi
                overview_info="Pi-hole overview ${overview_record_type} (${overview_query_val} ${overview_queries_word}, ${overview_reply_val} ${overview_replies_word})"
            else
                pihole_munin_safe_eval overview_info "overview_" "${overview_record_type}" "_info" "Pi-hole overview ${overview_record_type}"
            fi
            pihole_munin_safe_eval overview_label "overview_" "${overview_record_type}" "_label" "${overview_record_type}"
            pihole_munin_safe_eval overview_max "overview_" "${overview_record_type}" "_max" ""
            pihole_munin_safe_eval overview_min "overview_" "${overview_record_type}" "_min" "0"
            pihole_munin_safe_eval overview_warn "overview_" "${overview_record_type}" "_warn" ""
            # Print Munin field config for queries (negative direction)
            pihole_munin_print \
                "query_${overview_record_type}" \
                "" \
                "${overview_crit:-}" \
                "${overview_draw:-}" \
                "no" \
                "" \
                "${overview_label:-}" \
                "${overview_max:-}" \
                "${overview_min:-}" \
                "${overview_type:-}" \
                "${overview_warn:-}"
            # Print Munin field config for replies (positive direction)
            pihole_munin_print \
                "${overview_record_type}" \
                "${overview_colour:-}" \
                "${overview_crit:-}" \
                "${overview_draw:-}" \
                "${overview_graph:-}" \
                "${overview_info:-}" \
                "${overview_label:-}" \
                "${overview_max:-}" \
                "${overview_min:-}" \
                "${overview_type:-}" \
                "${overview_warn:-}"
            # Map the negative direction for Munin stacking
            printf "%s.negative %s\n" "${overview_record_type}" "query_${overview_record_type}"
        fi
    done
}

###############################################################################
# Percent Blocked Graph Configuration
###############################################################################

pihole_munin_config_percent() {
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_percent:-${graph}}" \
        "graph_args ${graph_args_percent:-"--upper-limit 100 --lower-limit 0"}" \
        "graph_category ${graph_category_percent:-${graph_category}}" \
        "graph_height ${graph_height_percent:-${graph_height}}" \
        "graph_info ${graph_info_percent:-"This graph shows Pi-hole's blocked query percentage"}" \
        "graph_scale ${graph_scale_percent:-${graph_scale}}" \
        "graph_title ${graph_title_percent:-"Pi-hole percent blocked"}" \
        "graph_vlabel ${graph_vlabel_percent:-"percent blocked"}" \
        "graph_width ${graph_width_percent:-${graph_width}}"
    # Print Munin field config for percent blocked (single value)
    pihole_munin_print \
        "percent_blocked" \
        "${percent_percent_blocked_colour:-}" \
        "${percent_percent_blocked_crit:-"90"}" \
        "${percent_percent_blocked_draw:-${graph_draw}}" \
        "${percent_percent_blocked_graph:-"yes"}" \
        "${percent_percent_blocked_info:-"Pi-hole percent blocked"}" \
        "${percent_percent_blocked_label:-"percent blocked"}" \
        "${percent_percent_blocked_max:-"100"}" \
        "${percent_percent_blocked_min:-"0"}" \
        "${percent_percent_blocked_type:-"${graph_type}"}" \
        "${percent_percent_blocked_warn:-"0:85"}"
}

###############################################################################
# Privacy Level Graph Configuration
###############################################################################

pihole_munin_config_privacy() {
    ftl_response=$(pihole_munin_state_handler "${info_ftl_url}" 2>/dev/null)
    privacy_level_val=$(printf "%s" "${ftl_response}" | jq -r '.ftl.privacy_level // empty')
    # Set info string based on privacy level, with documentation link
    addn_info="See https://docs.pi-hole.net/ftldns/privacylevels/ for more information."
    case "${privacy_level_val}" in
        0)
            privacy_info="Level 0 - show everything: Doesn't hide anything, all statistics are available."
            ;;
        1)
            privacy_info="Level 1 - hide domains: Show and store all domains as hidden. Disables: Top Domains, Top Ads."
            ;;
        2)
            privacy_info="Level 2 - hide domains and clients: Show and store all domains as hidden and clients as 0.0.0.0. Disables: Top Domains, Top Ads, Top Clients, Clients over time."
            ;;
        3)
            privacy_info="Level 3 - anonymous mode: Disable all details except the most anonymous statistics. Disables: Top Domains, Top Ads, Top Clients, Clients over time, Query Log, Long-term database logging."
            ;;
        *)
            privacy_info="Privacy level unknown."
            ;;
    esac
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_privacy:-${graph}}" \
        "graph_args ${graph_args_privacy:-"--upper-limit 3 --lower-limit 0"}" \
        "graph_category ${graph_category_privacy:-${graph_category}}" \
        "graph_height ${graph_height_privacy:-${graph_height}}" \
        "graph_info ${graph_info_privacy:-"This graph shows Pi-hole's privacy level"}" \
        "graph_scale ${graph_scale_privacy:-${graph_scale}}" \
        "graph_title ${graph_title_privacy:-"Pi-hole privacy level"}" \
        "graph_vlabel ${graph_vlabel_privacy:-"show all / 1 / 2 / anonymous"}" \
        "graph_width ${graph_width_privacy:-${graph_width}}"
    # No need for the safe eval handler as there's only one key we care about
    # and we already know what it is
    # Print Munin field config for privacy level
    pihole_munin_print \
        "privacy_level" \
        "${privacy_privacy_level_colour:-}" \
        "${privacy_privacy_level_crit:-}" \
        "${privacy_privacy_level_draw:-${graph_draw}}" \
        "${privacy_privacy_level_graph:-"yes"}" \
        "${privacy_privacy_level_info:-"${privacy_info}  ${addn_info}"}" \
        "${privacy_privacy_level_label:-"privacy level"}" \
        "${privacy_privacy_level_max:-"3"}" \
        "${privacy_privacy_level_min:-"0"}" \
        "${privacy_privacy_level_type:-"${graph_type}"}" \
        "${privacy_privacy_level_warn:-}"
}

###############################################################################
# Queries Graph Configuration
###############################################################################

pihole_munin_config_queries() {
    # Default queries graph type and vlabel based on type
    graph_type_queries="${graph_type_queries:-"DERIVE"}"
    if [ "${graph_type_queries}" = "DERIVE" ]; then
        queries_vlabel="queries / second"
    else
        queries_vlabel="queries"
    fi
    # Optionally add a graph_total line if not "undef"
    [ "${graph_total_queries:-total}" != "undef" ] && graph_total_line="graph_total ${graph_total_queries:-total}"
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_queries:-${graph}}" \
        "graph_args ${graph_args_queries:-${graph_args}}" \
        "graph_category ${graph_category_queries:-${graph_category}}" \
        "graph_height ${graph_height_queries:-${graph_height}}" \
        "graph_info ${graph_info_queries:-"This graph shows Pi-hole's queries"}" \
        "graph_scale ${graph_scale_queries:-${graph_scale}}" \
        "graph_title ${graph_title_queries:-"Pi-hole queries"}" \
        ${graph_total_line:+"${graph_total_line}"} \
        "graph_vlabel ${graph_vlabel_queries:--${queries_vlabel}}" \
        "graph_width ${graph_width_queries:-${graph_width}}"
    # Fetch queries metrics from API
    queries_response=$(pihole_munin_state_handler "${stats_summary_url}") || exit 1
    # For each queries key/label pair
    for queries_key_label in \
        "blocked|queries blocked" \
        "cached|queries cached" \
        "forwarded|queries forwarded"; do
        queries_key=${queries_key_label%%|*}  # Key for JSON lookup
        queries_default_info="Pi-hole ${queries_key_label#*|}"  # Info string
        queries_default_label=$(printf "%s" "${queries_key}" | sed 's/_/ /g')  # Human-readable label
        # Extract value from JSON, default to 0 if missing
        queries_value=$(printf '%s' "${queries_response}" | jq -r --arg k "${queries_key}" '.queries[$k] // 0')
        # Only print if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "queries" || [ "${queries_value}" -ne 0 ]; then
            # Load per-key config overrides
            pihole_munin_safe_eval queries_colour "queries_" "${queries_key}" "_colour" ""
            pihole_munin_safe_eval queries_crit "queries_" "${queries_key}" "_crit" ""
            pihole_munin_safe_eval queries_draw "queries_" "${queries_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval queries_graph "queries_" "${queries_key}" "_graph" "yes"
            pihole_munin_safe_eval queries_type "queries_" "${queries_key}" "_type" "${graph_type_queries}"
            # Conditionally append value to info for DERIVE type
            if [ "${graph_type_queries:-${queries_type}}" = "DERIVE" ]; then
                if [ "${queries_value}" -eq 1 ]; then
                    queries_info="Pi-hole ${queries_key_label#*|} (${queries_value} query)"
                else
                    queries_info="Pi-hole ${queries_key_label#*|} (${queries_value} queries)"
                fi
            else
                pihole_munin_safe_eval queries_info "queries_" "${queries_key}" "_info" "${queries_default_info}"
            fi
            pihole_munin_safe_eval queries_label "queries_" "${queries_key}" "_label" "${queries_default_label}"
            pihole_munin_safe_eval queries_max "queries_" "${queries_key}" "_max" ""
            pihole_munin_safe_eval queries_min "queries_" "${queries_key}" "_min" "0"
            pihole_munin_safe_eval queries_warn "queries_" "${queries_key}" "_warn" ""
            # Print Munin field config for this queries key
            pihole_munin_print \
                "${queries_key}" \
                "${queries_colour:-}" \
                "${queries_crit:-}" \
                "${queries_draw:-}" \
                "${queries_graph:-}" \
                "${queries_info:-}" \
                "${queries_label:-}" \
                "${queries_max:-}" \
                "${queries_min:-}" \
                "${queries_type:-}" \
                "${queries_warn:-}"
        fi
    done
}

###############################################################################
# Queries by Status Graph Configuration
###############################################################################

pihole_munin_config_queries_by_status() {
    # Default queries by status graph type and vlabel based on type
    graph_type_queries_by_status="${graph_type_queries_by_status:-"DERIVE"}"
    if [ "${graph_type_queries_by_status}" = "DERIVE" ]; then
        queries_by_status_vlabel="queries / second"
    else
        queries_by_status_vlabel="queries"
    fi
    # Optionally add a graph_total line if not "undef"
    [ "${graph_total_queries_by_status:-total}" != "undef" ] && graph_total_line="graph_total ${graph_total_queries_by_status:-total}"
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_queries_by_status:-${graph}}" \
        "graph_args ${graph_args_queries_by_status:-${graph_args}}" \
        "graph_category ${graph_category_queries_by_status:-${graph_category}}" \
        "graph_height ${graph_height_queries_by_status:-${graph_height}}" \
        "graph_info ${graph_info_queries_by_status:-"This graph shows Pi-hole's queries by status"}" \
        "graph_scale ${graph_scale_queries_by_status:-${graph_scale}}" \
        "graph_title ${graph_title_queries_by_status:-"Pi-hole queries by status"}" \
        ${graph_total_line:+"${graph_total_line}"} \
        "graph_vlabel ${graph_vlabel_queries_by_status:-${queries_by_status_vlabel}}" \
        "graph_width ${graph_width_queries_by_status:-${graph_width}}"
    # Fetch queries by status metrics from API
    queries_by_status_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    # Iterate over each status key/value pair
    printf "%s" "${queries_by_status_response}" | jq -r '.queries.status | to_entries[] | "\(.key) \(.value)"' \
    | while read -r queries_by_status_key queries_by_status_value; do
        # Only print if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "queries_by_status" || [ "${queries_by_status_value}" -ne 0 ]; then
            # Load per-key config overrides
            pihole_munin_safe_eval queries_by_status_colour "queries_by_status_" "${queries_by_status_key}" "_colour" ""
            pihole_munin_safe_eval queries_by_status_crit "queries_by_status_" "${queries_by_status_key}" "_crit" ""
            pihole_munin_safe_eval queries_by_status_draw "queries_by_status_" "${queries_by_status_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval queries_by_status_graph "queries_by_status_" "${queries_by_status_key}" "_graph" "yes"
            pihole_munin_safe_eval queries_by_status_type "queries_by_status_" "${queries_by_status_key}" "_type" "${graph_type_queries_by_status}"
            # Conditionally append value to info for DERIVE type
            if [ "${graph_type_queries_by_status:-${queries_by_status_type}}" = "DERIVE" ]; then
                if [ "${queries_by_status_value}" -eq 1 ]; then
                    queries_by_status_info="Pi-hole query status ${queries_by_status_key} (${queries_by_status_value} query)"
                else
                    queries_by_status_info="Pi-hole query status ${queries_by_status_key} (${queries_by_status_value} queries)"
                fi
            else
                pihole_munin_safe_eval queries_by_status_info "queries_by_status_" "${queries_by_status_key}" "_info" "Pi-hole query status ${queries_by_status_key}"
            fi
            pihole_munin_safe_eval queries_by_status_label "queries_by_status_" "${queries_by_status_key}" "_label" "${queries_by_status_key}"
            pihole_munin_safe_eval queries_by_status_max "queries_by_status_" "${queries_by_status_key}" "_max" ""
            pihole_munin_safe_eval queries_by_status_min "queries_by_status_" "${queries_by_status_key}" "_min" "0"
            pihole_munin_safe_eval queries_by_status_warn "queries_by_status_" "${queries_by_status_key}" "_warn" ""
            # Print Munin field config for this status key
            pihole_munin_print \
                "${queries_by_status_key}" \
                "${queries_by_status_colour:-}" \
                "${queries_by_status_crit:-}" \
                "${queries_by_status_draw:-}" \
                "${queries_by_status_graph:-}" \
                "${queries_by_status_info:-}" \
                "${queries_by_status_label:-}" \
                "${queries_by_status_max:-}" \
                "${queries_by_status_min:-}" \
                "${queries_by_status_type:-}" \
                "${queries_by_status_warn:-}"
        fi
    done
}

###############################################################################
# Queries by Type Graph Configuration
###############################################################################

pihole_munin_config_queries_by_type() {
    # Default queries by type graph type and vlabel based on type
    graph_type_queries_by_type="${graph_type_queries_by_type:-"DERIVE"}"
    if [ "${graph_type_queries_by_type}" = "DERIVE" ]; then
        queries_by_type_vlabel="queries / second"
    else
        queries_by_type_vlabel="queries"
    fi
    # Optionally add a graph_total line if not "undef"
    [ "${graph_total_queries_by_type:-total}" != "undef" ] && graph_total_line="graph_total ${graph_total_queries_by_type:-total}"
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_queries_by_type:-${graph}}" \
        "graph_args ${graph_args_queries_by_type:-${graph_args}}" \
        "graph_category ${graph_category_queries_by_type:-${graph_category}}" \
        "graph_height ${graph_height_queries_by_type:-${graph_height}}" \
        "graph_info ${graph_info_queries_by_type:-"This graph shows Pi-hole's queries by record type"}" \
        "graph_scale ${graph_scale_queries_by_type:-${graph_scale}}" \
        "graph_title ${graph_title_queries_by_type:-"Pi-hole queries by type"}" \
        ${graph_total_line:+"${graph_total_line}"} \
        "graph_vlabel ${graph_vlabel_queries_by_type:-${queries_by_type_vlabel}}" \
        "graph_width ${graph_width_queries_by_type:-${graph_width}}"
    # Fetch queries by type metrics from API
    queries_by_type_response=$(pihole_munin_state_handler "${stats_query_types_url}" ) || exit 1
    # Iterate over each type key/value pair
    printf "%s" "${queries_by_type_response}" | jq -r '.types | to_entries[] | "\(.key) \(.value)"' \
    | while read -r queries_by_type_key queries_by_type_value; do
        # Only print if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "queries_by_type" || [ "${queries_by_type_value}" -ne 0 ]; then
            # Load per-key config overrides
            pihole_munin_safe_eval queries_by_type_colour "queries_by_type_" "${queries_by_type_key}" "_colour" ""
            pihole_munin_safe_eval queries_by_type_crit "queries_by_type_" "${queries_by_type_key}" "_crit" ""
            pihole_munin_safe_eval queries_by_type_draw "queries_by_type_" "${queries_by_type_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval queries_by_type_graph "queries_by_type_" "${queries_by_type_key}" "_graph" "yes"
            pihole_munin_safe_eval queries_by_type_type "queries_by_type_" "${queries_by_type_key}" "_type" "${graph_type_queries_by_type}"
            # Conditionally append value to info for DERIVE type
            if [ "${graph_type_queries_by_type:-${queries_by_type_type}}" = "DERIVE" ]; then
                if [ "${queries_by_type_value}" -eq 1 ]; then
                    queries_by_type_info="Pi-hole query type ${queries_by_type_key} (${queries_by_type_value} query)"
                else
                    queries_by_type_info="Pi-hole query type ${queries_by_type_key} (${queries_by_type_value} queries)"
                fi
            else
                pihole_munin_safe_eval queries_by_type_info "queries_by_type_" "${queries_by_type_key}" "_info" "Pi-hole query type ${queries_by_type_key}"
            fi
            pihole_munin_safe_eval queries_by_type_label "queries_by_type_" "${queries_by_type_key}" "_label" "${queries_by_type_key}"
            pihole_munin_safe_eval queries_by_type_max "queries_by_type_" "${queries_by_type_key}" "_max" ""
            pihole_munin_safe_eval queries_by_type_min "queries_by_type_" "${queries_by_type_key}" "_min" "0"
            pihole_munin_safe_eval queries_by_type_warn "queries_by_type_" "${queries_by_type_key}" "_warn" ""
            # Print Munin field config for this type key
            pihole_munin_print \
                "${queries_by_type_key}" \
                "${queries_by_type_colour:-}" \
                "${queries_by_type_crit:-}" \
                "${queries_by_type_draw:-}" \
                "${queries_by_type_graph:-}" \
                "${queries_by_type_info:-}" \
                "${queries_by_type_label:-}" \
                "${queries_by_type_max:-}" \
                "${queries_by_type_min:-}" \
                "${queries_by_type_type:-}" \
                "${queries_by_type_warn:-}"
        fi
    done
}

###############################################################################
# Replies Graph Configuration
###############################################################################

pihole_munin_config_replies() {
    # Default replies graph type and vlabel based on type
    graph_type_replies="${graph_type_replies:-"DERIVE"}"
    if [ "${graph_type_replies}" = "DERIVE" ]; then
        replies_vlabel="replies / second"
    else
        replies_vlabel="replies"
    fi
    # Optionally add a graph_total line if not "undef"
    [ "${graph_total_replies:-total}" != "undef" ] && graph_total_line="graph_total ${graph_total_replies:-total}"
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_replies:-${graph}}" \
        "graph_args ${graph_args_replies:-${graph_args}}" \
        "graph_category ${graph_category_replies:-${graph_category}}" \
        "graph_height ${graph_height_replies:-${graph_height}}" \
        "graph_info ${graph_info_replies:-"This graph shows Pi-hole's replies"}" \
        "graph_scale ${graph_scale_replies:-${graph_scale}}" \
        "graph_title ${graph_title_replies:-"Pi-hole replies"}" \
        ${graph_total_line:+"${graph_total_line}"} \
        "graph_vlabel ${graph_vlabel_replies:-${replies_vlabel}}" \
        "graph_width ${graph_width_replies:-${graph_width}}"
    # Fetch replies metrics from API
    replies_response=$(pihole_munin_state_handler "${info_metrics_url}" ) || exit 1
    # For each replies key to display
    for replies_key in "auth" "forwarded" "local" "optimized" "unanswered"; do
        # Extract value from JSON, default to 0 if missing
        replies_value=$(printf '%s\n' "${replies_response}" | jq -r --arg k "${replies_key}" '.metrics.dns.replies[$k] // 0')
        # Only print if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "replies" || [ "${replies_value}" -ne 0 ]; then
            # Load per-key config overrides
            pihole_munin_safe_eval replies_colour "replies_" "${replies_key}" "_colour" ""
            pihole_munin_safe_eval replies_crit "replies_" "${replies_key}" "_crit" ""
            pihole_munin_safe_eval replies_draw "replies_" "${replies_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval replies_graph "replies_" "${replies_key}" "_graph" "yes"
            pihole_munin_safe_eval replies_type "replies_" "${replies_key}" "_type" "${graph_type_replies}"
            # Conditionally append value to info for DERIVE type
            if [ "${graph_type_replies:-${replies_type}}" = "DERIVE" ]; then
                if [ "${replies_value}" -eq 1 ]; then
                    replies_info="Pi-hole ${replies_key} replies (${replies_value} reply)"
                else
                    replies_info="Pi-hole ${replies_key} replies (${replies_value} replies)"
                fi
            else
                pihole_munin_safe_eval replies_info "replies_" "${replies_key}" "_info" "Pi-hole ${replies_key} replies"
            fi
            pihole_munin_safe_eval replies_label "replies_" "${replies_key}" "_label" "${replies_key}"
            pihole_munin_safe_eval replies_max "replies_" "${replies_key}" "_max" ""
            pihole_munin_safe_eval replies_min "replies_" "${replies_key}" "_min" "0"
            pihole_munin_safe_eval replies_warn "replies_" "${replies_key}" "_warn" ""
            # Print Munin field config for this replies key
            pihole_munin_print \
                "${replies_key}" \
                "${replies_colour:-}" \
                "${replies_crit:-}" \
                "${replies_draw:-}" \
                "${replies_graph:-}" \
                "${replies_info:-}" \
                "${replies_label:-}" \
                "${replies_max:-}" \
                "${replies_min:-}" \
                "${replies_type:-}" \
                "${replies_warn:-}"
        fi
    done
}

###############################################################################
# Replies by Type Graph Configuration
###############################################################################

pihole_munin_config_replies_by_type() {
    # Default replies by type graph type and vlabel based on type
    graph_type_replies_by_type="${graph_type_replies_by_type:-"DERIVE"}"
    if [ "${graph_type_replies_by_type}" = "DERIVE" ]; then
        replies_by_type_vlabel="replies / second"
    else
        replies_by_type_vlabel="replies"
    fi
    # Optionally add a graph_total line if not "undef"
    [ "${graph_total_replies_by_type:-total}" != "undef" ] && graph_total_line="graph_total ${graph_total_replies_by_type:-total}"
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_replies_by_type:-${graph}}" \
        "graph_args ${graph_args_replies_by_type:-${graph_args}}" \
        "graph_category ${graph_category_replies_by_type:-${graph_category}}" \
        "graph_height ${graph_height_replies_by_type:-${graph_height}}" \
        "graph_info ${graph_info_replies_by_type:-"This graph shows Pi-hole's replies by record type"}" \
        "graph_scale ${graph_scale_replies_by_type:-${graph_scale}}" \
        "graph_title ${graph_title_replies_by_type:-"Pi-hole replies by type"}" \
        ${graph_total_line:+"${graph_total_line}"} \
        "graph_vlabel ${graph_vlabel_replies_by_type:-${replies_by_type_vlabel}}" \
        "graph_width ${graph_width_replies_by_type:-${graph_width}}"
    # Fetch replies by type metrics from API
    replies_by_type_response=$(pihole_munin_state_handler "${stats_summary_url}") || exit 1
    # Iterate over each type key/value pair
    printf "%s" "${replies_by_type_response}" | jq -r '.queries.replies | to_entries[] | "\(.key) \(.value)"' \
    | while read -r replies_by_type_key replies_by_type_value; do
        # Only print if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "replies_by_type" || [ "${replies_by_type_value}" -ne 0 ]; then
            # Load per-key config overrides
            pihole_munin_safe_eval replies_by_type_colour "replies_by_type_" "${replies_by_type_key}" "_colour" ""
            pihole_munin_safe_eval replies_by_type_crit "replies_by_type_" "${replies_by_type_key}" "_crit" ""
            pihole_munin_safe_eval replies_by_type_draw "replies_by_type_" "${replies_by_type_key}" "_draw" "${graph_draw}"
            pihole_munin_safe_eval replies_by_type_graph "replies_by_type_" "${replies_by_type_key}" "_graph" "yes"
            pihole_munin_safe_eval replies_by_type_type "replies_by_type_" "${replies_by_type_key}" "_type" "${graph_type_replies_by_type}"
            # Conditionally append value to info for DERIVE type
            if [ "${graph_type_replies_by_type:-${replies_by_type_type}}" = "DERIVE" ]; then
                if [ "${replies_by_type_value}" -eq 1 ]; then
                    replies_by_type_info="Pi-hole reply type ${replies_by_type_key} (${replies_by_type_value} reply)"
                else
                    replies_by_type_info="Pi-hole reply type ${replies_by_type_key} (${replies_by_type_value} replies)"
                fi
            else
                pihole_munin_safe_eval replies_by_type_info "replies_by_type_" "${replies_by_type_key}" "_info" "Pi-hole reply type ${replies_by_type_key}"
            fi
            pihole_munin_safe_eval replies_by_type_label "replies_by_type_" "${replies_by_type_key}" "_label" "${replies_by_type_key}"
            pihole_munin_safe_eval replies_by_type_max "replies_by_type_" "${replies_by_type_key}" "_max" ""
            pihole_munin_safe_eval replies_by_type_min "replies_by_type_" "${replies_by_type_key}" "_min" "0"
            pihole_munin_safe_eval replies_by_type_warn "replies_by_type_" "${replies_by_type_key}" "_warn" ""
            # Print Munin field config for this type key
            pihole_munin_print \
                "${replies_by_type_key}" \
                "${replies_by_type_colour:-}" \
                "${replies_by_type_crit:-}" \
                "${replies_by_type_draw:-}" \
                "${replies_by_type_graph:-}" \
                "${replies_by_type_info:-}" \
                "${replies_by_type_label:-}" \
                "${replies_by_type_max:-}" \
                "${replies_by_type_min:-}" \
                "${replies_by_type_type:-}" \
                "${replies_by_type_warn:-}"
        fi
    done
}

###############################################################################
# Status Graph Configuration
###############################################################################

pihole_munin_config_status() {
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_status:-${graph}}" \
        "graph_args ${graph_args_status:-"--lower-limit -1 --upper-limit 1"}" \
        "graph_height ${graph_height_status:-${graph_height}}" \
        "graph_info ${graph_info_status:-"This graph shows Pi-hole's blocking status"}" \
        "graph_category ${graph_category_status:-${graph_category}}" \
        "graph_scale ${graph_scale_status:-${graph_scale}}" \
        "graph_title ${graph_title_status:-"Pi-hole status"}" \
        "graph_vlabel ${graph_vlabel_status:-"unknown / disabled / enabled"}" \
        "graph_width ${graph_width_status:-${graph_width}}"
    # Print Munin field config for blocking status (single value)
    pihole_munin_print \
        "blocking_status" \
        "${status_blocking_status_colour:-}" \
        "${status_blocking_status_crit:-"0:1"}" \
        "${status_blocking_status_draw:-${graph_draw}}" \
        "${status_blocking_status_graph:-"yes"}" \
        "${status_blocking_status_info:-"Pi-hole blocking status"}" \
        "${status_blocking_status_label:-"blocking status"}" \
        "${status_blocking_status_max:-"1"}" \
        "${status_blocking_status_min:-"-1"}" \
        "${status_blocking_status_type:-"${graph_type}"}" \
        "${status_blocking_status_warn:-"1:1"}"
}

###############################################################################
# Reverse PTR Lookup Helper
###############################################################################
# Usage: pihole_munin_rev_ptr <ip[:port]>
# Performs reverse DNS lookup for an IP, caches results in state dir with TTL.
###############################################################################

pihole_munin_rev_ptr() {
    ip_port="$1"
    reverse_lookup_cache="${pihole_munin_plugstate}/pihole_munin_rev_ptr.state"
    rev_ptr_ttl="${rev_ptr_ttl:-86400}"  # TTL in seconds (default: 24 hours)
    now=$(date +%s)
    # Remove brackets for IPv6 [::1]:5353
    ip_port=$(printf "%s" "${ip_port}" | sed 's/^\[\(.*\)\]$/\1/')
    # Extract IP from IP:PORT
    if printf "%s" "${ip_port}" | grep -Eq '^\[?[0-9a-fA-F:]+\]?:[0-9]+$'; then
        ip=$(printf "%s" "${ip_port}" | sed 's/\(.*\):[0-9]\+$/\1/')
    elif printf "%s" "${ip_port}" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(:[0-9]+)?$'; then
        ip=$(printf "%s" "${ip_port}" | cut -d: -f1)
    else
        ip="${ip_port}"
    fi
    # Check cache first (handle migration from old format)
    if grep -q "^${ip} " "${reverse_lookup_cache}" 2>/dev/null; then
        cached_line=$(grep "^${ip} " "${reverse_lookup_cache}" | head -n1)
        fields=$(printf "%s" "${cached_line}" | awk '{print NF}')
        if [ "${fields}" -eq 2 ]; then
            # Old format: <ip> <hostname>
            cached_val=$(printf "%s" "${cached_line}" | cut -d' ' -f2)
            cached_time="${now}"
            # Rewrite entry with timestamp
            grep -v "^${ip} " "${reverse_lookup_cache}" > "${reverse_lookup_cache}.tmp"
            printf "%s %s %s\n" "${ip}" "${cached_time}" "${cached_val}" >> "${reverse_lookup_cache}.tmp"
            mv "${reverse_lookup_cache}.tmp" "${reverse_lookup_cache}"
        elif [ "${fields}" -ge 3 ]; then
            # New format: <ip> <timestamp> <hostname>
            cached_time=$(printf "%s" "${cached_line}" | awk '{print $2}')
            cached_val=$(printf "%s" "${cached_line}" | cut -d' ' -f3-)
        fi
        # If cache is still valid, use it
        if [ -n "${cached_time}" ] && [ $((now - cached_time)) -lt "${rev_ptr_ttl}" ]; then
            if [ "${cached_val}" = "-" ]; then
                printf "%s\n" "${ip_port}"
            else
                printf "%s\n" "${cached_val}"
            fi
            return
        fi
        # Otherwise, remove stale entry
        grep -v "^${ip} " "${reverse_lookup_cache}" > "${reverse_lookup_cache}.tmp" && mv "${reverse_lookup_cache}.tmp" "${reverse_lookup_cache}"
    fi
    # Do reverse lookup
    hostname=$(getent hosts "${ip}" 2>/dev/null | awk '{print $2}' | head -n1)
    if [ -z "${hostname}" ]; then
        dig_output=$(dig +time=10 +short -x "${ip}" 2>&1)
        dig_status=$?
        # Only accept dig output if it looks like a valid hostname (not empty, not error)
        if [ "${dig_status}" -eq 0 ] && [ -n "${dig_output}" ] && ! printf "%s" "${dig_output}" | grep -q '^;;'; then
            hostname=$(printf "%s" "${dig_output}" | head -n1)
        fi
    fi
    # Cache result (negative only if both failed and dig did not timeout)
    if [ -n "${hostname}" ] && ! printf "%s" "${hostname}" | grep -q '^;;'; then
        printf "%s %s %s\n" "${ip}" "${now}" "${hostname}" >> "${reverse_lookup_cache}"
        printf "%s\n" "${hostname}"
    else
        if [ "${dig_status:-0}" -eq 0 ] && [ -z "${hostname}" ]; then
            printf "%s %s -\n" "${ip}" "${now}" >> "${reverse_lookup_cache}"
        fi
        printf "%s\n" "${ip_port}"
    fi
}

###############################################################################
# Top Clients Graph Configuration
###############################################################################

pihole_munin_config_top_clients() {
    # Default top clients graph type and vlabel based on type
    graph_type_top_clients="${graph_type_top_clients:-"DERIVE"}"
    if [ "${graph_type_top_clients}" = "DERIVE" ]; then
        top_clients_vlabel="queries / second"
    else
        top_clients_vlabel="queries"
    fi
    [ "${graph_total_top_clients:-total}" != "undef" ] && graph_total_line="graph_total ${graph_total_top_clients:-total}"
    top_clients_response=$(pihole_munin_state_handler "${stats_top_clients_url}") || exit 1
    # Output Munin graph config header
    printf "%s\n" \
        "graph ${graph_top_clients:-${graph}}" \
        "graph_args ${graph_args_top_clients:-${graph_args}}" \
        "graph_category ${graph_category_top_clients:-${graph_category}}" \
        "graph_height ${graph_height_top_clients:-${graph_height}}" \
        "graph_info ${graph_info_top_clients:-"This graph shows Pi-hole's top clients by query count (max ${top_clients_n} clients)"}" \
        "graph_scale ${graph_scale_top_clients:-${graph_scale}}" \
        "graph_title ${graph_title_top_clients:-"Pi-hole top clients"}" \
        ${graph_total_line:+"${graph_total_line}"} \
        "graph_vlabel ${graph_vlabel_top_clients:-${top_clients_vlabel}}" \
        "graph_width ${graph_width_top_clients:-${graph_width}}"
    # Print Munin field definitions for top N clients from API
    printf "%s" "${top_clients_response}" | jq -r ".clients[] | \"\(.name) \(.count)\"" | awk 'NF == 2' |
    while read -r raw_key raw_value; do
        top_clients_key="$(printf "%s" "${raw_key}" | tr -c 'a-zA-Z0-9' '_')"
        case "${top_clients_key}" in
            [0-9]*) top_clients_key="top_clients_${top_clients_key}" ;;
        esac
        default_label="${raw_key}"
        default_info="Pi-hole top client ${raw_key}"
        pihole_munin_safe_eval top_clients_colour "top_clients_" "${top_clients_key}" "_colour" ""
        pihole_munin_safe_eval top_clients_crit "top_clients_" "${top_clients_key}" "_crit" ""
        pihole_munin_safe_eval top_clients_draw "top_clients_" "${top_clients_key}" "_draw" "${graph_draw}"
        pihole_munin_safe_eval top_clients_graph "top_clients_" "${top_clients_key}" "_graph" "yes"
        pihole_munin_safe_eval top_clients_type "top_clients_" "${top_clients_key}" "_type" "${graph_type_top_clients}"
        # Info string: singular/plural for DERIVE, else allow override
        if [ "${graph_type_top_clients:-${top_clients_type}}" = "DERIVE" ]; then
            if [ "${raw_value}" -eq 1 ]; then
                top_clients_info="${default_info} (${raw_value} query)"
            else
                top_clients_info="${default_info} (${raw_value} queries)"
            fi
        else
            pihole_munin_safe_eval top_clients_info "top_clients_" "${top_clients_key}" "_info" "${default_info}"
        fi
        pihole_munin_safe_eval top_clients_label "top_clients_" "${top_clients_key}" "_label" "${default_label}"
        pihole_munin_safe_eval top_clients_max "top_clients_" "${top_clients_key}" "_max" ""
        pihole_munin_safe_eval top_clients_min "top_clients_" "${top_clients_key}" "_min" "0"
        pihole_munin_safe_eval top_clients_warn "top_clients_" "${top_clients_key}" "_warn" ""
        # Print Munin field config for this client key
        pihole_munin_print \
            "${top_clients_key}" \
            "${top_clients_colour:-}" \
            "${top_clients_crit:-}" \
            "${top_clients_draw:-}" \
            "${top_clients_graph:-}" \
            "${top_clients_info:-}" \
            "${top_clients_label:-}" \
            "${top_clients_max:-}" \
            "${top_clients_min:-}" \
            "${top_clients_type:-}" \
            "${top_clients_warn:-}"
    done
    # If no clients, output a placeholder field
    if ! printf "%s" "${top_clients_response}" | jq -e '.clients | length > 0' >/dev/null 2>&1; then
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No clients" \
            "none" \
            "" \
            "0" \
            "${graph_type:-${graph_type_top_clients}}" \
            ""
    fi
}

###############################################################################
# Top Domains Graph Configuration
###############################################################################

pihole_munin_config_top_domains() {
    # Default top domains graph type and vlabel based on type
    graph_type_top_domains="${graph_type_top_domains:-"DERIVE"}"
    if [ "${graph_type_top_domains}" = "DERIVE" ]; then
        top_domains_vlabel="queries / second"
    else
        top_domains_vlabel="queries"
    fi
    [ "${graph_total_top_domains:-total}" != "undef" ] && graph_total_line="graph_total ${graph_total_top_domains:-total}"
    top_domains_response=$(pihole_munin_state_handler "${stats_top_domains_url}") || exit 1
    # Output Munin graph config header
    printf "%s\n" \
        "graph ${graph_top_domains:-${graph}}" \
        "graph_args ${graph_args_top_domains:-${graph_args}}" \
        "graph_category ${graph_category_top_domains:-${graph_category}}" \
        "graph_height ${graph_height_top_domains:-${graph_height}}" \
        "graph_info ${graph_info_top_domains:-"This graph shows Pi-hole's top domains by query count (max ${top_domains_n} domains)"}" \
        "graph_scale ${graph_scale_top_domains:-${graph_scale}}" \
        "graph_title ${graph_title_top_domains:-"Pi-hole top domains"}" \
        ${graph_total_line:+"${graph_total_line}"} \
        "graph_vlabel ${graph_vlabel_top_domains:-${top_domains_vlabel}}" \
        "graph_width ${graph_width_top_domains:-${graph_width}}"
    # Print Munin field definitions for top N domains from API
    printf "%s" "${top_domains_response}" | jq -r ".domains[] | \"\(.domain) \(.count)\"" | awk 'NF == 2' |
    while read -r raw_key raw_value; do
        top_domains_key="$(printf "%s" "${raw_key}" | tr -c 'a-zA-Z0-9' '_')"
        case "${top_domains_key}" in
            [0-9]*) top_domains_key="top_domains_${top_domains_key}" ;;
        esac
        default_label="${raw_key}"
        default_info="Pi-hole top domain ${raw_key}"
        pihole_munin_safe_eval top_domains_colour "top_domains_" "${top_domains_key}" "_colour" ""
        pihole_munin_safe_eval top_domains_crit "top_domains_" "${top_domains_key}" "_crit" ""
        pihole_munin_safe_eval top_domains_draw "top_domains_" "${top_domains_key}" "_draw" "${graph_draw}"
        pihole_munin_safe_eval top_domains_graph "top_domains_" "${top_domains_key}" "_graph" "yes"
        pihole_munin_safe_eval top_domains_type "top_domains_" "${top_domains_key}" "_type" "${graph_type_top_domains}"
        # Info string: singular/plural for DERIVE, else allow override
        if [ "${graph_type_top_domains:-${top_domains_type}}" = "DERIVE" ]; then
            if [ "${raw_value}" -eq 1 ]; then
                top_domains_info="${default_info} (${raw_value} query)"
            else
                top_domains_info="${default_info} (${raw_value} queries)"
            fi
        else
            pihole_munin_safe_eval top_domains_info "top_domains_" "${top_domains_key}" "_info" "${default_info}"
        fi
        pihole_munin_safe_eval top_domains_label "top_domains_" "${top_domains_key}" "_label" "${default_label}"
        pihole_munin_safe_eval top_domains_max "top_domains_" "${top_domains_key}" "_max" ""
        pihole_munin_safe_eval top_domains_min "top_domains_" "${top_domains_key}" "_min" "0"
        pihole_munin_safe_eval top_domains_warn "top_domains_" "${top_domains_key}" "_warn" ""
        # Print Munin field config for this domain key
        pihole_munin_print \
            "${top_domains_key}" \
            "${top_domains_colour:-}" \
            "${top_domains_crit:-}" \
            "${top_domains_draw:-}" \
            "${top_domains_graph:-}" \
            "${top_domains_info:-}" \
            "${top_domains_label:-}" \
            "${top_domains_max:-}" \
            "${top_domains_min:-}" \
            "${top_domains_type:-}" \
            "${top_domains_warn:-}"
    done
    # If no domains, output a placeholder field
    if ! printf "%s" "${top_domains_response}" | jq -e '.domains | length > 0' >/dev/null 2>&1; then
        pihole_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No domains" \
            "none" \
            "" \
            "0" \
            "${graph_type:-${graph_type_top_domains}}" \
            ""
    fi
}

###############################################################################
# Unique Domains Graph Configuration
###############################################################################

pihole_munin_config_unique() {
    # Default unique domains graph type and vlabel based on type
    graph_type_unique="${graph_type_unique:-"DERIVE"}"
    if [ "${graph_type_unique}" = "DERIVE" ]; then
        unique_vlabel="domains / second"
    else
        unique_vlabel="domains"
    fi
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_unique:-${graph}}" \
        "graph_args ${graph_args_unique:-${graph_args}}" \
        "graph_category ${graph_category_unique:-${graph_category}}" \
        "graph_height ${graph_height_unique:-${graph_height}}" \
        "graph_info ${graph_info_unique:-"This graph shows the number of unique domains queried by Pi-hole"}" \
        "graph_scale ${graph_scale_unique:-${graph_scale}}" \
        "graph_title ${graph_title_unique:-"Pi-hole unique domains"}" \
        "graph_vlabel ${graph_vlabel_unique:-${unique_vlabel}}" \
        "graph_width ${graph_width_unique:-${graph_width}}"
    # Fetch unique domains value for info string if needed
    unique_response=$(pihole_munin_state_handler "${stats_summary_url}" 2>/dev/null)
    unique_domains_val=$(printf "%s" "${unique_response}" | jq -r '.queries.unique_domains // empty')
    # Conditionally append value to info for DERIVE type
    pihole_munin_safe_eval unique_type "unique_" "unique_domains" "_type" "${graph_type_unique}"
    if [ "${graph_type_unique:-${unique_type}}" = "DERIVE" ]; then
        if [ "${unique_domains_val}" = "1" ]; then
            unique_info="Pi-hole unique domains (1 domain)"
        elif [ -n "${unique_domains_val}" ]; then
            unique_info="Pi-hole unique domains (${unique_domains_val} domains)"
        else
            unique_info="Pi-hole unique domains"
        fi
    else
        pihole_munin_safe_eval unique_info "unique_" "unique_domains" "_info" "Pi-hole unique domains"
    fi
    # Print Munin field config for unique domains (single value)
    pihole_munin_print \
        "unique_domains" \
        "${unique_unique_domains_colour:-}" \
        "${unique_unique_domains_crit:-}" \
        "${unique_unique_domains_draw:-${graph_draw}}" \
        "${unique_unique_domains_graph:-"yes"}" \
        "${unique_info:-}" \
        "${unique_unique_domains_label:-"unique domains"}" \
        "${unique_unique_domains_max:-}" \
        "${unique_unique_domains_min:-"0"}" \
        "${unique_type:-}" \
        "${unique_unique_domains_warn:-}"
}

###############################################################################
# Upstreams Graph Configuration
###############################################################################

pihole_munin_config_upstreams() {
    # Default upstreams graph type and vlabel based on type
    graph_type_upstreams="${graph_type_upstreams:-"DERIVE"}"
    if [ "${graph_type_upstreams}" = "DERIVE" ]; then
        upstreams_vlabel="queries / second"
    else
        upstreams_vlabel="queries"
    fi
    # Optionally add a graph_total line if not "undef"
    [ "${graph_total_upstreams:-total}" != "undef" ] && graph_total_line="graph_total ${graph_total_upstreams:-total}"
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_upstreams:-${graph}}" \
        "graph_args ${graph_args_upstreams:-${graph_args}}" \
        "graph_category ${graph_category_upstreams:-${graph_category}}" \
        "graph_height ${graph_height_upstreams:-${graph_height}}" \
        "graph_info ${graph_info_upstreams:-"This graph shows the query counts for each of Pi-hole's upstream destinations"}" \
        "graph_scale ${graph_scale_upstreams:-${graph_scale}}" \
        "graph_title ${graph_title_upstreams:-"Pi-hole upstream servers"}" \
        ${graph_total_line:+"${graph_total_line}"} \
        "graph_vlabel ${graph_vlabel_upstreams:--${upstreams_vlabel}}" \
        "graph_width ${graph_width_upstreams:-${graph_width}}"
    upstreams_response=$(pihole_munin_state_handler "${stats_upstreams_url}") || exit 1
    # This is not the greatest query percentile calculation in the World, no.
    # This is just a tribute.
    upstreams_total=$(printf '%s' "${upstreams_response}" | jq '[.upstreams[].count // 0] | add')
    printf "%s" "${upstreams_response}" | jq -c '.upstreams[]' | while read -r upstream; do
        raw_name=$(printf '%s' "${upstream}" | jq -r '.name // empty')
        raw_ip=$(printf '%s' "${upstream}" | jq -r '.ip // empty')
        raw_port=$(printf '%s' "${upstream}" | jq -r '.port // 0')
        upstream_count=$(printf '%s' "${upstream}" | jq -r '.count // 0')
        # Calculate percentage using upstreams_total
        percent="0"
        if [ "${upstreams_total}" -gt 0 ]; then
            percent=$(awk "BEGIN { printf \"%.2f\", (${upstream_count}/${upstreams_total})*100 }")
        fi
        # Build key: prefer name, else IP
        if [ -n "${raw_name}" ] && [ "${raw_name}" != "null" ]; then
            upstreams_key=$(printf "%s" "${raw_name}" | tr -c 'a-zA-Z0-9' '_')
        else
            upstreams_key=$(printf "%s" "${raw_ip}" | tr -c 'a-zA-Z0-9' '_')
        fi
        # Prefix numeric keys to avoid Munin issues
        case "${upstreams_key}" in
            [0-9]*) upstreams_key="upstreams_${upstreams_key}" ;;
        esac
        # Port string for label/info
        port_str=""
        if [ -n "${raw_port}" ] && printf "%s" "${raw_port}" | grep -Eq '^[0-9]+$' && [ "${raw_port}" -gt 0 ] && [ "${raw_port}" -le 65535 ] && [ "${raw_port}" -ne 53 ]; then
            port_str=":${raw_port}"
        fi
        # Build label and info: prefer name, then rev_ptr, then IP
        if [ -n "${raw_name}" ] && [ "${raw_name}" != "null" ]; then
            default_label="${raw_name}${port_str}"
            default_info="Pi-hole upstream server ${raw_name}${port_str} (${raw_ip}${port_str}"
        else
            rev_label=$(pihole_munin_rev_ptr "${raw_ip}")
            default_label="${rev_label}${port_str}"
            default_info="Pi-hole upstream server ${rev_label}${port_str} (${raw_ip}${port_str}"
        fi
        pihole_munin_safe_eval upstreams_colour "upstreams_" "${upstreams_key}" "_colour" ""
        pihole_munin_safe_eval upstreams_crit "upstreams_" "${upstreams_key}" "_crit" ""
        pihole_munin_safe_eval upstreams_draw "upstreams_" "${upstreams_key}" "_draw" "${graph_draw}"
        pihole_munin_safe_eval upstreams_graph "upstreams_" "${upstreams_key}" "_graph" "yes"
        pihole_munin_safe_eval upstreams_type "upstreams_" "${upstreams_key}" "_type" "${graph_type_upstreams}"
        # Info string: for DERIVE, combine IP and count in one parenthesis if name/rev_ptr, else just append count
        if [ "${graph_type_upstreams:-${upstreams_type}}" = "DERIVE" ]; then
            if [ -n "${raw_name}" ] && [ "${raw_name}" != "null" ]; then
                # Name or rev_ptr, combine ip and count in one parenthesis
                if [ "${upstream_count}" -eq 1 ]; then
                    upstreams_info="${default_info}, ${upstream_count} query, ${percent}% of total)"
                else
                    upstreams_info="${default_info}, ${upstream_count} queries, ${percent}% of total)"
                fi
            else
                # Only IP/rev_ptr, just append count
                if [ "${upstream_count}" -eq 1 ]; then
                    upstreams_info="${default_info} (${upstream_count} query, ${percent}% of total)"
                else
                    upstreams_info="${default_info} (${upstream_count} queries, ${percent}% of total)"
                fi
            fi
        else
            # Non-DERIVE: use default info, close parenthesis if needed
            pihole_munin_safe_eval upstreams_info "upstreams_" "${upstreams_key}" "_info" "${default_info})"
        fi
        pihole_munin_safe_eval upstreams_label "upstreams_" "${upstreams_key}" "_label" "${default_label}"
        pihole_munin_safe_eval upstreams_max "upstreams_" "${upstreams_key}" "_max" ""
        pihole_munin_safe_eval upstreams_min "upstreams_" "${upstreams_key}" "_min" "0"
        pihole_munin_safe_eval upstreams_warn "upstreams_" "${upstreams_key}" "_warn" ""
        # Print Munin field config for this upstream key
        pihole_munin_print \
            "${upstreams_key}" \
            "${upstreams_colour:-}" \
            "${upstreams_crit:-}" \
            "${upstreams_draw:-}" \
            "${upstreams_graph:-}" \
            "${upstreams_info:-}" \
            "${upstreams_label:-}" \
            "${upstreams_max:-}" \
            "${upstreams_min:-}" \
            "${upstreams_type:-}" \
            "${upstreams_warn:-}"
    done
}

###############################################################################
# Version Graph Configuration
###############################################################################
# Docker version monitoring is now disabled by default.
# To enable, set: env.version_enable_docker yes
###############################################################################

pihole_munin_config_version() {
    # Docker version monitoring toggle (default: no)
    version_enable_docker="${version_enable_docker:-no}"
    # Print Munin graph config lines, using plugin-specific overrides if set
    printf "%s\n" \
        "graph ${graph_version:-${graph}}" \
        "graph_args ${graph_args_version:-"--lower-limit -1 --upper-limit 1"}" \
        "graph_category ${graph_category_version:-${graph_category}}" \
        "graph_height ${graph_height_version:-${graph_height}}" \
        "graph_info ${graph_info_version:-"This graph shows the version status of Pi-hole components"}" \
        "graph_scale ${graph_scale_version:-${graph_scale}}" \
        "graph_title ${graph_title_version:-"Pi-hole version"}" \
        "graph_vlabel ${graph_vlabel_version:-"unknown / up-to-date / update available"}" \
        "graph_width ${graph_width_version:-${graph_width}}"
    version_response=$(pihole_munin_state_handler "/info/version" 2>/dev/null)
    for pihole_module in core web ftl docker; do
        # Skip docker unless enabled
        if [ "${pihole_module}" = "docker" ] && [ "${version_enable_docker}" != "yes" ]; then
            continue
        fi
        label="version_${pihole_module}"
        # Build info string from API data if available
        info=""
        if [ -n "${version_response}" ]; then
            case "${pihole_module}" in
                "core"|"web"|"ftl")
                    local_ver=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.local.version // empty")
                    remote_ver=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.remote.version // empty")
                    branch=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.local.branch // empty")
                    hash=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.local.hash // empty")
                    remote_hash=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.remote.hash // empty")
                    date=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.local.date // empty")
                    info="Branch: ${branch}, Local: ${local_ver} (${hash})"
                    [ -n "${date}" ] && info="${info}, Date: ${date}"
                    info="${info}; Remote: ${remote_ver} (${remote_hash})"
                    ;;
                "docker")
                    local_ver=$(printf '%s' "${version_response}" | jq -r ".version.docker.local // empty")
                    remote_ver=$(printf '%s' "${version_response}" | jq -r ".version.docker.remote // empty")
                    info="Local: ${local_ver}; Remote: ${remote_ver}"
                    ;;
            esac
        fi
        default_info="Pi-hole ${pihole_module} version status"
        [ -n "${info}" ] && default_info="${default_info} (${info})"
        pihole_munin_safe_eval version_colour "version_" "${pihole_module}" "_colour" ""
        pihole_munin_safe_eval version_crit "version_" "${pihole_module}" "_crit" ""
        pihole_munin_safe_eval version_draw "version_" "${pihole_module}" "_draw" "${graph_draw}"
        pihole_munin_safe_eval version_graph "version_" "${pihole_module}" "_graph" "yes"
        pihole_munin_safe_eval version_info "version_" "${pihole_module}" "_info" "${default_info}"
        pihole_munin_safe_eval version_label "version_" "${pihole_module}" "_label" "${pihole_module}"
        pihole_munin_safe_eval version_max "version_" "${pihole_module}" "_max" "1"
        pihole_munin_safe_eval version_min "version_" "${pihole_module}" "_min" "-1"
        pihole_munin_safe_eval version_type "version_" "${pihole_module}" "_type" "${graph_type}"
        pihole_munin_safe_eval version_warn "version_" "${pihole_module}" "_warn" ""
        # Print Munin field config for this version key
        pihole_munin_print \
            "${label}" \
            "${version_colour:-}" \
            "${version_crit:-}" \
            "${version_draw:-}" \
            "${version_graph:-}" \
            "${version_info:-}" \
            "${version_label:-}" \
            "${version_max:-}" \
            "${version_min:-}" \
            "${version_type:-}" \
            "${version_warn:-}"
    done
}

###############################################################################
# Dependency Check Function
###############################################################################
# Usage:
#   pihole_munin_check_dependencies
#
# Description:
#   Checks for the presence of required command-line dependencies needed by
#   the plugin. Iterates through a list of required commands and verifies
#   each is available in the system PATH. Prints an error and returns 1 if
#   any dependency is missing.
#
# Dependencies Checked:
#   - awk
#   - curl
#   - dig
#   - grep
#   - jq
#   - mktemp
#   - sed
#
# Logic:
#   - For each dependency, checks if the command exists.
#   - If any dependency is missing, prints an error and returns 1.
#   - If all dependencies are present, returns 0.
#
# Output:
#   - Prints error message for each missing dependency.
#   - Returns 1 if any dependency is missing, else 0.
###############################################################################

pihole_munin_check_dependencies() {
    plugin_dependencies="awk curl dig grep jq mktemp sed"  # List of required commands
    # Loop through each dependency and check if it's available
    for plugin_dependency in ${plugin_dependencies}; do
        if ! command -v "${plugin_dependency}" >/dev/null 2>&1; then
            # Print error if dependency is missing
            printf "%s\n" "  [❌] '${plugin_dependency}' is not installed or not in PATH." >&2
            return 1  # Return error status
        fi
    done
}

###############################################################################
# Plugin Config Handler
###############################################################################

pihole_munin_config_handler() {
    # Select the correct config function based on plugin ID
    case "${pihole_munin_plugin_id}" in
        "cache") pihole_munin_config_cache ;;
        "cache_by_type") pihole_munin_config_cache_by_type ;;
        "clients") pihole_munin_config_clients ;;
        "dnsmasq") pihole_munin_config_dnsmasq ;;
        "domains") pihole_munin_config_domains ;;
        "frequency") pihole_munin_config_frequency ;;
        "gravity") pihole_munin_config_gravity ;;
        "overview") pihole_munin_config_overview ;;
        "percent") pihole_munin_config_percent ;;
        "privacy") pihole_munin_config_privacy ;;
        "queries") pihole_munin_config_queries ;;
        "queries_by_status") pihole_munin_config_queries_by_status ;;
        "queries_by_type") pihole_munin_config_queries_by_type ;;
        "replies") pihole_munin_config_replies ;;
        "replies_by_type") pihole_munin_config_replies_by_type ;;
        "status") pihole_munin_config_status ;;
        "top_clients") pihole_munin_config_top_clients ;;
        "top_domains") pihole_munin_config_top_domains ;;
        "unique") pihole_munin_config_unique ;;
        "upstreams") pihole_munin_config_upstreams ;;
        "version") pihole_munin_config_version ;;
        *)
            # Print error for unknown plugin ID and exit
            printf "%s\n" "  [❌] Unable to generate config for unknown plugin ID '${pihole_munin_plugin_id}'." >&2
            exit 1
            ;;
    esac
}

###############################################################################
# Fetch Cache Metrics
###############################################################################

pihole_munin_fetch_cache() {
    if [ -z "${cache_response}" ]; then
        # Get cache metrics from API
        cache_response=$(pihole_munin_state_handler "${info_metrics_url}" ) || exit 1
    fi
    # For each cache metric key
    for cache_key in "evicted" "expired" "immortal" "inserted"; do
        # Extract value from JSON, default to 0 if missing
        cache_value=$(printf '%s' "${cache_response}" | jq -r --arg k "${cache_key}" '.metrics.dns.cache[$k] // 0')
        # Only output if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "cache" || [ "${cache_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${cache_key}" "${cache_value}"
        fi
    done
}

###############################################################################
# Fetch Cache by Type Metrics
###############################################################################

pihole_munin_fetch_cache_by_type() {
    if [ -z "${cache_by_type_response}" ]; then
        # Get cache by type metrics from API
        cache_by_type_response=$(pihole_munin_state_handler "${info_metrics_url}" ) || exit 1
    fi
    # Iterate over each cache type entry in the JSON
    printf "%s" "${cache_by_type_response}" | jq -c '.metrics.dns.cache.content[]' \
    | while read -r cache_by_type_entry; do
        # Extract type name and counts
        cache_by_type_name=$(printf '%s' "${cache_by_type_entry}" | jq -r '.name')
        cache_by_type_valid=$(printf '%s' "${cache_by_type_entry}" | jq -r '.count.valid')
        cache_by_type_stale=$(printf '%s' "${cache_by_type_entry}" | jq -r '.count.stale')
        # For both valid and stale counts
        for cache_by_type_entry in "valid" "stale"; do
            case "${cache_by_type_entry}" in
                "valid")
                    cache_by_type_key="${cache_by_type_name}"
                    cache_by_type_value="${cache_by_type_valid}"
                    ;;
                "stale")
                    cache_by_type_key="${cache_by_type_name}_STALE"
                    cache_by_type_value="${cache_by_type_stale}"
                    ;;
            esac
            # Only output if graph_zero is enabled or value is non-zero
            if pihole_munin_graph_zero "cache_by_type" || [ "${cache_by_type_value}" -ne 0 ]; then
                printf "%s.value %s\n" "${cache_by_type_key}" "${cache_by_type_value}"
            fi
        done
    done
}

###############################################################################
# Fetch Clients Metrics
###############################################################################

pihole_munin_fetch_clients() {
    if [ -z "${clients_response}" ]; then
        # Get client metrics from API
        clients_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    fi
    # Iterate over each client key/value pair
    printf "%s" "${clients_response}" | jq -r '.clients | to_entries[] | "\(.key) \(.value)"' \
    | while read -r clients_key clients_value; do
        # Only output if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "clients" || [ "${clients_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${clients_key}" "${clients_value}"
        fi
    done
}

###############################################################################
# Fetch Dnsmasq Metrics
###############################################################################

pihole_munin_fetch_dnsmasq() {
    if [ -z "${dnsmasq_response}" ]; then
        # Get dnsmasq metrics from API
        dnsmasq_response=$(pihole_munin_state_handler "${info_ftl_url}" ) || exit 1
    fi
    # Iterate over each dnsmasq key/value pair
    printf "%s" "${dnsmasq_response}" | jq -r '.ftl.dnsmasq | to_entries[] | "\(.key) \(.value)"' \
    | while read -r dnsmasq_key dnsmasq_value; do
        # Only output if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "dnsmasq" || [ "${dnsmasq_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${dnsmasq_key}" "${dnsmasq_value}"
        fi
    done
}

###############################################################################
# Fetch Domains Being Blocked
###############################################################################

pihole_munin_fetch_domains() {
    if [ -z "${domains_response}" ]; then
        # Get domains metrics from API
        domains_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    fi
    # Output domains_being_blocked value
    printf "%s" "${domains_response}" | jq -r '.gravity | "\("domains_being_blocked.value") \(.domains_being_blocked)"'
}

###############################################################################
# Fetch Query Frequency
###############################################################################

pihole_munin_fetch_frequency() {
    if [ -z "${frequency_response}" ]; then
        # Get frequency metrics from API
        frequency_response=$(pihole_munin_state_handler "${stats_summary_url}") || exit 1
    fi
    # Output frequency value, rounded to two decimals
    printf "%s" "${frequency_response}" | jq -r '.queries | "frequency.value \(.frequency | tonumber | . * 100 | round | . / 100)"'
}

###############################################################################
# Fetch Gravity Database Metrics
###############################################################################

pihole_munin_fetch_gravity() {
    if [ -z "${gravity_response}" ]; then
        # Get gravity database metrics from API
        gravity_response=$(pihole_munin_state_handler "${info_ftl_url}") || exit 1
    fi
    # For each gravity key to display
    for gravity_key in "groups" "lists" "domains_allowed" "domains_denied" "regex_allowed" "regex_denied"; do
        # Determine jq key path based on gravity_key prefix
        case "${gravity_key}" in
            "domains_"*)
                gravity_jq_key=".ftl.database.domains.${gravity_key#domains_}"
                ;;
            "regex_"*)
                gravity_jq_key=".ftl.database.regex.${gravity_key#regex_}"
                ;;
            *)
                gravity_jq_key=".ftl.database.${gravity_key}"
                ;;
        esac
        # Extract value from JSON, default to 0 if missing
        gravity_value=$(printf '%s' "${gravity_response}" | jq -r "${gravity_jq_key} // 0")
        # Only output if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "gravity" || [ "${gravity_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${gravity_key}" "${gravity_value}"
        fi
    done
}

###############################################################################
# Fetch Overview Metrics (queries and replies by type)
###############################################################################

pihole_munin_fetch_overview() {
    if [ -z "${overview_queries_by_type_response}" ]; then
        # Get queries by type from API
        overview_queries_by_type_response=$(pihole_munin_state_handler "${stats_query_types_url}" ) || exit 1
    fi
    if [ -z "${overview_replies_by_type_response}" ]; then
        # Get replies by type from API
        overview_replies_by_type_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    fi
    # Collect all unique record types from both queries and replies
    overview_all_types=$(
        { printf '%s\n' "${overview_queries_by_type_response}" | jq -r '.types | keys_unsorted[]'; \
            printf '%s\n' "${overview_replies_by_type_response}" | jq -r '.queries.replies | keys_unsorted[]'; \
        } | sort -u
    )
    # For each record type, print both query and reply values
    for overview_record_type in ${overview_all_types}; do
        overview_query_val=$(printf '%s\n' "${overview_queries_by_type_response}" | jq -r --arg k "${overview_record_type}" '.types[$k] // 0')
        overview_reply_val=$(printf '%s\n' "${overview_replies_by_type_response}" | jq -r --arg k "${overview_record_type}" '.queries.replies[$k] // 0')
        # Only output if graph_zero is enabled or either value is non-zero
        if pihole_munin_graph_zero "overview" || [ "${overview_query_val}" -ne 0 ] || [ "${overview_reply_val}" -ne 0 ]; then
            printf "query_%s.value %s\n" "${overview_record_type}" "${overview_query_val}"
            printf "%s.value %s\n" "${overview_record_type}" "${overview_reply_val}"
        fi
    done
}

###############################################################################
# Fetch Percent Blocked
###############################################################################

pihole_munin_fetch_percent() {
    percent_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    # Output percent_blocked value, rounded to two decimals
    printf "%s" "${percent_response}" | jq -r '.queries | "percent_blocked.value \(.percent_blocked | tonumber | . * 100 | round / 100)"'
}

###############################################################################
# Fetch Privacy Level
###############################################################################

pihole_munin_fetch_privacy() {
    if [ -z "${ftl_response}" ]; then
        # Get FTL metrics from API
        ftl_response=$(pihole_munin_state_handler "${info_ftl_url}" ) || exit 1
    fi
    # Output privacy_level value
    printf "%s" "${ftl_response}" | jq -r '"privacy_level.value \(.ftl.privacy_level)"'
}

###############################################################################
# Fetch Queries Metrics
###############################################################################

pihole_munin_fetch_queries() {
    if [ -z "${queries_response}" ]; then
        # Get queries metrics from API
        queries_response=$(pihole_munin_state_handler "${stats_summary_url}") || exit 1
    fi
    # For each queries key to display
    for queries_key in "blocked" "cached" "forwarded"; do
        queries_value=$(printf '%s' "${queries_response}" | jq -r --arg k "${queries_key}" '.queries[$k] // 0')
        # Only output if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "queries" || [ "${queries_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${queries_key}" "${queries_value}"
        fi
    done
}

###############################################################################
# Fetch Queries by Status Metrics
###############################################################################

pihole_munin_fetch_queries_by_status() {
    if [ -z "${queries_by_status_response}" ]; then
        # Get queries by status metrics from API
        queries_by_status_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    fi
    # Iterate over each status key/value pair
    printf "%s" "${queries_by_status_response}" | jq -r '.queries.status | to_entries[] | "\(.key) \(.value)"' \
    | while read -r queries_by_status_key queries_by_status_value; do
        # Only output if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "queries_by_status" || [ "${queries_by_status_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${queries_by_status_key}" "${queries_by_status_value}"
        fi
    done
}

###############################################################################
# Fetch Queries by Type Metrics
###############################################################################

pihole_munin_fetch_queries_by_type() {
    if [ -z "${queries_by_type_response}" ]; then
        # Get queries by type metrics from API
        queries_by_type_response=$(pihole_munin_state_handler "${stats_query_types_url}" ) || exit 1
    fi
    # Iterate over each type key/value pair
    printf "%s" "${queries_by_type_response}" | jq -r '.types | to_entries[] | "\(.key) \(.value)"' \
    | while read -r queries_by_type_key queries_by_type_value; do
        # Only output if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "queries_by_type" || [ "${queries_by_type_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${queries_by_type_key}" "${queries_by_type_value}"
        fi
    done
}

###############################################################################
# Fetch Replies Metrics
###############################################################################

pihole_munin_fetch_replies() {
    if [ -z "${replies_response}" ]; then
        # Get replies metrics from API
        replies_response=$(pihole_munin_state_handler "${info_metrics_url}") || exit 1
    fi
    # For each replies key to display
    for replies_key in "auth" "forwarded" "local" "optimized" "unanswered"; do
        replies_value=$(printf '%s\n' "${replies_response}" \
            | jq -r --arg k "${replies_key}" '.metrics.dns.replies[$k] // 0')
        # Only output if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "replies" || [ "${replies_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${replies_key}" "${replies_value}"
        fi
    done
}

###############################################################################
# Fetch Replies by Type Metrics
###############################################################################

pihole_munin_fetch_replies_by_type() {
    if [ -z "${replies_by_type_response}" ]; then
        # Get replies by type metrics from API
        replies_by_type_response=$(pihole_munin_state_handler "${stats_summary_url}" ) || exit 1
    fi
    # Iterate over each type key/value pair
    printf "%s" "${replies_by_type_response}" | jq -r '.queries.replies | to_entries[] | "\(.key) \(.value)"' \
    | while read -r replies_by_type_key replies_by_type_value; do
        # Only output if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "replies_by_type" || [ "${replies_by_type_value}" -ne 0 ]; then
            printf "%s.value %s\n" "${replies_by_type_key}" "${replies_by_type_value}"
        fi
    done
}

###############################################################################
# Fetch Blocking Status
###############################################################################

pihole_munin_fetch_status() {
    if [ -z "${status_response}" ]; then
        # Get blocking status from API
        status_response=$(pihole_munin_state_handler "${dns_blocking_url}" ) || exit 1
    fi
    # Output blocking status as numeric value for Munin
    printf "%s" "${status_response}" | jq -r '.blocking' \
    | while read -r status_key; do
        case "${status_key}" in
            "enabled") status_value="1" ;;
            "disabled") status_value="0" ;;
            *) status_value="-1" ;;
        esac
        printf "blocking_status.value %s\n" "${status_value}"
    done
}

###############################################################################
# Fetch Top Clients Metrics (stateless, API-only)
###############################################################################

pihole_munin_fetch_top_clients() {
    if [ -z "${top_clients_response}" ]; then
        # Get top clients metrics from API
        top_clients_response=$(pihole_munin_state_handler "${stats_top_clients_url}") || exit 1
    fi
    # Output values for Munin, only current top N from API
    printf "%s" "${top_clients_response}" | jq -r ".clients[] | \"\(.name) \(.count)\"" | awk 'NF == 2' |
    while read -r client num_queries; do
        top_clients_key="$(printf "%s" "${client}" | tr -c 'a-zA-Z0-9' '_')"
        case "${top_clients_key}" in
            [0-9]*) top_clients_key="top_clients_${top_clients_key}" ;;
        esac
        printf "%s.value %s\n" "${top_clients_key}" "${num_queries}"
    done
    # If no clients, output a placeholder field
    if ! printf "%s" "${top_clients_response}" | jq -e '.clients | length > 0' >/dev/null 2>&1; then
        printf "none.value 0\n"
    fi
}

###############################################################################
# Fetch Top Domains Metrics (stateless, API-only)
###############################################################################

pihole_munin_fetch_top_domains() {
    if [ -z "${top_domains_response}" ]; then
        # Get top domains metrics from API
        top_domains_response=$(pihole_munin_state_handler "${stats_top_domains_url}") || exit 1
    fi
    # Output values for Munin, only current top N from API
    printf "%s" "${top_domains_response}" | jq -r ".domains[] | \"\(.domain) \(.count)\"" | awk 'NF == 2' |
    while read -r domain num_queries; do
        top_domains_key="$(printf "%s" "${domain}" | tr -c 'a-zA-Z0-9' '_')"
        case "${top_domains_key}" in
            [0-9]*) top_domains_key="top_domains_${top_domains_key}" ;;
        esac
        printf "%s.value %s\n" "${top_domains_key}" "${num_queries}"
    done
    # If no domains, output a placeholder field
    if ! printf "%s" "${top_domains_response}" | jq -e '.domains | length > 0' >/dev/null 2>&1; then
        printf "none.value 0\n"
    fi
}

###############################################################################
# Fetch Unique Domains
###############################################################################

pihole_munin_fetch_unique() {
    if [ -z "${unique_response}" ]; then
        # Get unique domains metrics from API
        unique_response=$(pihole_munin_state_handler "${stats_summary_url}") || exit 1
    fi
    # Output unique_domains value
    printf "%s" "${unique_response}" | jq -r '.queries | "unique_domains.value \(.unique_domains)"'
}

###############################################################################
# Fetch Upstreams Metrics
###############################################################################

pihole_munin_fetch_upstreams() {
    if [ -z "${upstreams_response}" ]; then
        # Get upstreams metrics from API
        upstreams_response=$(pihole_munin_state_handler "${stats_upstreams_url}") || exit 1
    fi
    # Iterate over each upstream entry
    printf "%s" "${upstreams_response}" | jq -c '.upstreams[]' | while read -r upstream; do
        raw_name=$(printf '%s' "${upstream}" | jq -r '.name // empty')  # Upstream name
        raw_ip=$(printf '%s' "${upstream}" | jq -r '.ip // empty')      # Upstream IP
        # Use name if available, else IP, sanitize for Munin key
        if [ -n "${raw_name}" ] && [ "${raw_name}" != "null" ]; then
            upstreams_key=$(printf "%s" "${raw_name}" | tr -c 'a-zA-Z0-9' '_')
        else
            upstreams_key=$(printf "%s" "${raw_ip}" | tr -c 'a-zA-Z0-9' '_')
        fi
        # Prefix numeric keys to avoid Munin issues
        case "${upstreams_key}" in
            [0-9]*) upstreams_key="upstreams_${upstreams_key}" ;;
        esac
        upstream_count=$(printf '%s' "${upstream}" | jq -r '.count // 0')
        # Only output if graph_zero is enabled or value is non-zero
        if pihole_munin_graph_zero "upstreams" || [ "${upstream_count}" -ne 0 ]; then
            printf "%s.value %s\n" "${upstreams_key}" "${upstream_count}"
        fi
    done
}

###############################################################################
# Fetch Version Metrics
###############################################################################
# Docker version monitoring is now disabled by default.
# To enable, set: env.version_enable_docker yes
###############################################################################

pihole_munin_fetch_version() {
    if [ -z "${version_response}" ]; then
        # Get version metrics from API
        version_response=$(pihole_munin_state_handler "${info_version_url}" 2>/dev/null)
    fi
    # Docker version monitoring toggle (default: no)
    version_enable_docker="${version_enable_docker:-no}"
    # For each Pi-hole module, determine status:
    # -1 unknown, 0 up-to-date, 1 update available
    for pihole_module in core web ftl docker; do
        # Skip docker unless enabled
        if [ "${pihole_module}" = "docker" ] && [ "${version_enable_docker}" != "yes" ]; then
            continue
        fi
        status="-1"
        case "${pihole_module}" in
            "core"|"web"|"ftl")
                local_ver=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.local.version // empty")
                remote_ver=$(printf '%s' "${version_response}" | jq -r ".version.${pihole_module}.remote.version // empty")
                if [ -n "${local_ver}" ] && [ -n "${remote_ver}" ]; then
                    if [ "${local_ver}" = "${remote_ver}" ]; then
                        status="0"
                    else
                        status="1"
                    fi
                fi
                ;;
            "docker")
                local_ver=$(printf '%s' "${version_response}" | jq -r ".version.docker.local // empty")
                remote_ver=$(printf '%s' "${version_response}" | jq -r ".version.docker.remote // empty")
                if [ -n "${local_ver}" ] && [ -n "${remote_ver}" ]; then
                    if [ "${local_ver}" = "${remote_ver}" ]; then
                        status="0"
                    else
                        status="1"
                    fi
                fi
                ;;
        esac
        printf "version_%s.value %s\n" "${pihole_module}" "${status}"
    done
}

###############################################################################
# Fetch Handler: Calls the correct fetch function for the plugin ID
###############################################################################

pihole_munin_fetch_handler() {
    case "${pihole_munin_plugin_id}" in
        "cache") pihole_munin_fetch_cache ;;
        "cache_by_type") pihole_munin_fetch_cache_by_type ;;
        "clients") pihole_munin_fetch_clients ;;
        "dnsmasq") pihole_munin_fetch_dnsmasq ;;
        "domains") pihole_munin_fetch_domains ;;
        "frequency") pihole_munin_fetch_frequency ;;
        "gravity") pihole_munin_fetch_gravity ;;
        "overview") pihole_munin_fetch_overview ;;
        "percent") pihole_munin_fetch_percent ;;
        "privacy") pihole_munin_fetch_privacy ;;
        "queries") pihole_munin_fetch_queries ;;
        "queries_by_status") pihole_munin_fetch_queries_by_status ;;
        "queries_by_type") pihole_munin_fetch_queries_by_type ;;
        "replies") pihole_munin_fetch_replies ;;
        "replies_by_type") pihole_munin_fetch_replies_by_type ;;
        "status") pihole_munin_fetch_status ;;
        "top_clients") pihole_munin_fetch_top_clients ;;
        "top_domains") pihole_munin_fetch_top_domains ;;
        "unique") pihole_munin_fetch_unique ;;
        "upstreams") pihole_munin_fetch_upstreams ;;
        "version") pihole_munin_fetch_version ;;
        *)
            # Unknown plugin ID
            printf "%s\n" "  [❌] Unable to fetch data for unknown plugin ID '${pihole_munin_plugin_id}'." >&2
            exit 1
            ;;
    esac
}

###############################################################################
# Munin Autoconf
###############################################################################
# Checks if plugin can run on this system
###############################################################################

pihole_munin_autoconf() {
    # Check required dependencies
    if ! pihole_munin_check_dependencies >/dev/null 2>&1; then
        printf "no (missing dependencies)\n"
        exit 0
    fi
    # If running on localhost, check for Pi-hole command
    if { [ "${is_localhost}" -eq 1 ]; } && ! command -v pihole >/dev/null 2>&1; then
        printf "no (not a Pi-hole host)\n"
        exit 0
    fi
    # Check if password is set
    if [ "${password_set}" -eq 0 ]; then
        printf "no (no password set)\n"
        exit 0
    fi
    # All checks passed
    printf "yes\n"
}

###############################################################################
# Normalise Plugins
###############################################################################
# Cleans up plugin list string
###############################################################################

pihole_munin_normalise_plugins() {
    # Remove comments, empty lines, and normalize commas and newlines
    # to spaces, and squeeze multiple spaces into one
    printf "%s\n" "${1}" \
        | sed 's/#.*//;/^[[:space:]]*$/d' \
        | tr ',\n' ' ' \
        | tr -s ' '
}

###############################################################################
# Plugin Lists
###############################################################################

# All valid plugins
valid_plugins="cache cache_by_type clients dnsmasq domains frequency gravity overview percent privacy queries queries_by_status queries_by_type replies replies_by_type status top_clients top_domains unique upstreams version"

# Default plugins list, anonymous plugins which aren't "boring"/mostly static
default_plugins="cache cache_by_type frequency overview percent queries queries_by_status queries_by_type replies replies_by_type unique"

# Support user-defined plugins via PLUGINS environment variable
if [ -n "${PLUGINS+x}" ]; then
    # If PLUGINS is "all", enable all valid plugins
    if printf '%s' "${PLUGINS}" | grep -qw "all"; then
        plugins="${valid_plugins}"
    else
        # Otherwise, normalise the user-defined plugins list
        plugins=$(pihole_munin_normalise_plugins "${PLUGINS}")
    fi
else
    # If PLUGINS is not set, use the default plugins list
    plugins="${default_plugins}"
fi

###############################################################################
# Suggest Plugins
###############################################################################
# Prints all valid plugins, one per line
###############################################################################

pihole_munin_suggest() {
    for plugin in ${valid_plugins}; do
        printf "%s\n" "${plugin}"
    done
}

###############################################################################
# Filter Valid Plugins
###############################################################################
# Filters input list to only valid plugins
# Warns about unknown plugins if 'warn' is passed as second argument
###############################################################################

pihole_munin_filter_valid_plugins() {
    input_plugin_list="${1}"
    warn_unknown="${2}"
    filtered_plugins=""
    for candidate_plugin in ${input_plugin_list}; do
        is_valid_plugin="0"
        for known_plugin in ${valid_plugins}; do
            if [ "${candidate_plugin}" = "${known_plugin}" ]; then
                is_valid_plugin="1"
                break
            fi
        done
        if [ "${is_valid_plugin}" -eq 1 ]; then
            filtered_plugins="${filtered_plugins} ${candidate_plugin}"
        elif [ "${warn_unknown}" = "warn" ]; then
            printf "  [⚠️] Unknown plugin '%s', skipping.\n" "${candidate_plugin}" >&2
        fi
    done
    # Trim leading/trailing spaces and print result
    printf "%s\n" "$(printf '%s' "${filtered_plugins}" | sed 's/^ *//;s/ *$//')"
}

###############################################################################
# Print Valid Plugins (with warning for unknowns)
###############################################################################

pihole_munin_valid_plugins() {
    pihole_munin_filter_valid_plugins "$plugins" "warn"
}

###############################################################################
# Validate Input Plugins
###############################################################################
# Normalises and filters input plugin list
###############################################################################

pihole_munin_validate_input_plugins() {
    input_plugins=$(pihole_munin_normalise_plugins "${1}")
    pihole_munin_filter_valid_plugins "$input_plugins" "warn"
}

###############################################################################
# Root Privilege Helper
###############################################################################
# Re-executes script as root if needed
###############################################################################

pihole_munin_root() {
    if [ "$(id -u)" -ne 0 ]; then
        if command -v sudo >/dev/null 2>&1; then
            printf "%s\n" "  [🛡️] Acquiring root privileges …"
            exec sudo "$(command -v -- "${script_path}")" "$@" || {
                printf "%s\n" "  [❌] Failed to acquire root privileges." >&2
                exit 1
            }
        else
            printf "%s\n" "  [❌] 'sudo' command not found." >&2
            exit 1
        fi
    fi
}

# RFC 3339 timestamp for script header
rfc3339_timestamp=$(date --rfc-3339=seconds)

###############################################################################
# Obligatory Obnoxious ASCII (and Unicode Emoji) Header
###############################################################################

pihole_munin_header() {
    printf "%b\n%b\n%b\n%b\n%b\n%b\n\n%b\n\n%b\n\n" \
        "${TEXT_RED}          _  _             _                                     _${TEXT_RESET}" \
        "${TEXT_ORANGE}   _ __  (_)| |__    ___  | |  ___      _ __ ___   _   _  _ __  (_) _ __${TEXT_RESET}" \
        "${TEXT_YELLOW}  | '_ \\ | || '_ \\  / _ \\ | | / _ \\    | '_ \` _ \\ | | | || '_ \\ | || '_ \\\\${TEXT_RESET}" \
        "${TEXT_GREEN_HEADER}  | |_) || || | | || (_) || ||  __/ __ | | | | | || |_| || | | || || | | | __${TEXT_RESET}" \
        "${TEXT_LIGHTBLUE}  | .__/ |_||_| |_| \\___/ |_| \\___||__||_| |_| |_| \\__,_||_| |_||_||_| |_||__|${TEXT_RESET}" \
        "${TEXT_BLUE}  |_|${TEXT_RESET}" \
        "  [📦] ${TEXT_INDIGO}Version: ${pihole_munin_version}${TEXT_RESET}" \
        "  [⏱️] ${TEXT_VIOLET}Date: ${rfc3339_timestamp}${TEXT_RESET}"
}

###############################################################################
# Safe Path Normalization
###############################################################################
# Cleans up paths by removing duplicate slashes and trailing slashes
###############################################################################

pihole_munin_safe_path() {
    printf "%s" "$1" | sed -E 's:/+:/:g; s:/*$::'
}

###############################################################################
# Parse install arguments
###############################################################################
# Sets dry_run, plugins list, and custom path options.
# Supports 'all' shortcode to enable all valid plugins.
###############################################################################

parse_install_args() {
    dry_run="0"
    plugins_arg=""
    custom_path=""
    # Loop through all arguments
    while [ $# -gt 0 ]; do
        case "${1}" in
            "-D"|"dry"|"--dry-run") dry_run="1" ;; # Enable dry run mode
            "-P"|"path"|"--plugins-path")
                # Next argument is custom path
                shift
                custom_path="${1}"
                ;;
            *)
                plugins_arg="${plugins_arg} ${1}" ;; # Collect plugin names
        esac
        shift
    done
    # Trim whitespace from plugin argument list
    plugins_arg=$(printf '%s' "${plugins_arg}" | sed 's/^ *//;s/ *$//')
    # Expand 'all' shortcode to all valid plugins
    # This allows users to specify 'all' to enable every plugin
    if printf '%s' "${plugins_arg}" | grep -qw "all"; then
        plugins_arg="${valid_plugins}"
    fi
    # Validate plugins if specified, else use all valid plugins
    # This filters out any unknown plugin names and warns if none are valid
    if [ -n "${plugins_arg}" ]; then
        plugins=$(pihole_munin_validate_input_plugins "${plugins_arg}")
        plugins=$(printf '%s' "${plugins}" | sed 's/^ *//;s/ *$//')
        [ -z "${plugins}" ] && {
            printf "%s\n" "  [❌] No valid plugins specified." >&2
            exit 1
        }
    else
        plugins=$(pihole_munin_valid_plugins)
    fi
    # If custom_path is set, override plugins_available and related paths
    # This allows installation to a user-specified plugins directory
    if [ -n "${custom_path}" ]; then
        plugins_available="$(pihole_munin_safe_path "${custom_path}")"
        pihole_munin_path="${plugins_available}/pihole_munin_"
    fi
}

###############################################################################
# Directory Setup
###############################################################################

plugins_available="$(pihole_munin_safe_path "${PLUGINS_AVAILABLE:-/usr/share/munin/plugins}")"
plugins_enabled="$(pihole_munin_safe_path "${PLUGINS_ENABLED:-/etc/munin/plugins}")"
plugins_config="$(pihole_munin_safe_path "${PLUGINS_CONFIG:-/etc/munin/plugin-conf.d}")"
pihole_munin_path="${plugins_available}/pihole_munin_"

pihole_munin_user="${SUDO_USER:-$USER}"
pihole_munin_host="$(hostname)"

###############################################################################
# Required Directory Check Helper
###############################################################################
# Usage: pihole_munin_check_required_dirs <dir1> <dir2> …
# Prints status and exits if any directory is missing.
###############################################################################

pihole_munin_check_required_dirs() {
    dry_run="${dry_run:-0}"
    printf "  %s Checking required directories …\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[🗂️]" || printf "[🗂️] (DRY RUN)" )"
    for required_dir in "$@"; do
        [ -d "${required_dir}" ] || {
            printf "%s\n" "  [❌] Missing directory '${required_dir}'." >&2
            exit 1
        }
        printf "%b\n" "       ${TEXT_LIGHTBLUE}${required_dir}${TEXT_RESET}"
    done
    printf "\n  %s Success.\n\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
}

###############################################################################
# Plugin File Check Helper
###############################################################################
# Checks if the plugin file exists, exits with error if it doesn't
###############################################################################

pihole_munin_check_plugin_file() {
    dry_run="${dry_run:-0}"
    printf "  %s Checking plugin file …\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[📄]" || printf "[📄] (DRY RUN)")"
    [ -f "${pihole_munin_path}" ] || {
        printf "%s\n" "  [❌] Plugin file '${pihole_munin_path}' does not exist." >&2
        exit 1
    }
    printf "%b\n\n  %s Success.\n\n" \
        "       ${TEXT_GREEN}${pihole_munin_path}${TEXT_RESET}" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
}

###############################################################################
# Restart Suggestion
###############################################################################
# Suggests restarting Munin node
###############################################################################

pihole_munin_restart_node_suggestion() {
    printf "\n%s\n\n%s\n%b\n\n" \
        "  [ℹ️] Please restart the Munin node." \
        "       Example:" \
        "       ${TEXT_GREEN}${pihole_munin_user}@${pihole_munin_host}${TEXT_RESET}:${TEXT_LIGHTBLUE}~${TEXT_RESET}$ ${TEXT_WHITE}sudo systemctl restart munin-node.service${TEXT_RESET}"
}

###############################################################################
# Install Plugin Function
###############################################################################
# Usage:
#   pihole_munin_install [<plugin> …] [<option>]
#
# Description:
#   Installs the pihole_munin_ plugin and enables selected plugins by creating
#   symlinks in the Munin plugins directory. Handles directory creation,
#   cleans up old symlinks, sets permissions, and prints status messages.
#   Supports dry run mode and custom plugin paths.
#
# Arguments:
#   <plugin> …   - List of plugins to enable (optional, defaults to all valid)
#   <option>     - Options:
#                -D, dry, --dry-run         Show actions without making changes
#                -P, path, --plugins-path   Specify custom plugins directory
#
# Logic:
#   - Ensures required directories exist, creates if missing.
#   - Copies plugin file and sets permissions (unless dry run).
#   - Removes old plugin symlinks if present.
#   - Enables plugins by creating symlinks.
#   - Suggests adding plugin to PATH if not present.
#   - Suggests restarting munin-node after install.
#
# Output:
#   - Prints status and success/error messages.
#   - Creates symlinks for enabled plugins.
#   - Returns non-zero on error.
###############################################################################

pihole_munin_install() {
    pihole_munin_header
    shift 2  # Skip first two arguments (if any)
    parse_install_args "$@"
    plugins_to_clean="0"
    # Ensure custom plugins_available directory exists if set
    if [ ! -d "${plugins_available}" ]; then
        if [ "${dry_run}" -eq 0 ]; then
            mkdir -p "${plugins_available}" || {
                printf "%s\n" "  [❌] Failed to create directory '${plugins_available}'." >&2
                exit 1
            }
        fi
    fi
    # Check for required directories
    pihole_munin_check_required_dirs "${plugins_available}" "${plugins_enabled}" "${plugins_config}"
    printf "  %s Installing pihole_munin_ …\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[⚪]" || printf "[⚪] (DRY RUN)")"
    # Copy plugin and set permissions unless dry run
    if [ "${dry_run}" -eq 0 ]; then
        cp -f "${script_path}" "${pihole_munin_path}" || {
            printf "%s\n" "  [❌] Failed to copy plugin." >&2
            exit 1
        }
        chmod 755 "${pihole_munin_path}" || {
            printf "%s\n" "  [❌] Failed to set permissions." >&2
            exit 1
        }
    fi
    printf "%b\n\n  %s Success.\n\n" \
        "       ${TEXT_GREEN}${pihole_munin_path}${TEXT_RESET}" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
    # Check for old plugin symlinks to clean
    for plugin_to_clean in "${plugins_enabled}"/pihole_munin_*; do
        [ ! -e "${plugin_to_clean}" ] && continue
        [ "${plugin_to_clean}" = "${plugins_enabled}/pihole_munin_" ] && continue
        plugins_to_clean="1"
        break
    done
    # Remove old plugin symlinks if needed
    if [ "$plugins_to_clean" -eq 1 ]; then
        cleaned_any="0"
        for plugin_symlink in "${plugins_enabled}"/pihole_munin_*; do
            [ ! -e "${plugin_symlink}" ] && continue
            plugin_name=$(basename "${plugin_symlink}" | sed 's/^pihole_munin_//')
            # Remove if not in new plugin list AND not a valid plugin
            if ! printf "%s\n" "${plugins}" | grep -qw "${plugin_name}" && ! printf "%s\n" "${valid_plugins}" | grep -qw "${plugin_name}"; then
                # Print header only once, when first obsolete symlink is found
                if [ "${cleaned_any}" = "0" ]; then
                    printf "\n  %s Cleaning obsolete plugin symlinks …\n" \
                        "$( [ "${dry_run}" -eq 0 ] && printf "[🧼]" || printf "[🧼] (DRY RUN)" )"
                    cleaned_any="1"
                fi
                printf "%b\n" "       ${TEXT_LIGHTBLUE}${plugin_symlink}${TEXT_RESET}"
                if [ "$dry_run" -eq 0 ]; then
                    rm -f "${plugin_symlink}" || {
                        printf "%s\n" "  [❌] Failed to remove plugin '${plugin_symlink}'\n" >&2
                        exit 1
                    }
                fi
            fi
        done
        if [ "${cleaned_any}" = "1" ]; then
            printf "\n  %s Success.\n\n" \
                "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
        fi
    fi
    # Check plugin file exists
    pihole_munin_check_plugin_file
    # Enable plugins by creating symlinks
    printf "  %s Enabling pihole_munin_ plugins …\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[🟢]" || printf "[🟢] (DRY RUN)" )"
    for plugin in ${plugins}; do
        if [ "${dry_run}" -eq 0 ]; then
            ln -sf "${pihole_munin_path}" "${plugins_enabled}/pihole_munin_${plugin}" || {
                printf "%s\n" "  [❌] Failed to create symlink '${plugins_enabled}/pihole_munin_${plugin}'." >&2
                exit 1
            }
        fi
        printf "%b\n" "       ${TEXT_LIGHTBLUE}${plugins_enabled}/pihole_munin_${plugin}${TEXT_RESET}"
    done
    printf "\n  %s Success.\n\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
    if [ "${dry_run}" -eq 0 ]; then
        # Suggest adding plugin to PATH if not present
        if ! printf "%s" ":$PATH:" | grep -q ":${pihole_munin_path}:"; then
            printf "%s\n%s\n\n%s\n%b\n%b\n\n%s\n\n%s\n%s\n\n%b\n\n%s\n\n%s\n%b\n\n%s\n%s\n" \
                "  [ℹ️] You can add '${pihole_munin_path}'" \
                "       to your \$PATH to run pihole_munin_ as a regular command." \
                "       Example:" \
                "       ${TEXT_GREEN}${pihole_munin_user}@${pihole_munin_host}${TEXT_RESET}:${TEXT_LIGHTBLUE}~${TEXT_RESET}$ ${TEXT_WHITE}P_M_PATH=\"/usr/share/munin/plugins/pihole_munin_\" && \\" \
                "       export PATH=\"\$PATH:\$PIHOLE_MUNIN_PATH\"${TEXT_RESET}" \
                "       This will only last until you close your terminal." \
                "       To add it permanently, add the following line to your shell profile" \
                "       (e.g. ~/.bashrc or ~/.profile)." \
                "       ${TEXT_WHITE}export PATH=\"\$PATH:${pihole_munin_path}\"${TEXT_RESET}" \
                "       Then restart your terminal or source the file." \
                "       Example:" \
                "       ${TEXT_GREEN}${pihole_munin_user}@${pihole_munin_host}${TEXT_RESET}:${TEXT_LIGHTBLUE}~${TEXT_RESET}$ ${TEXT_WHITE}source ~/.bashrc${TEXT_RESET}" \
                "       This will add pihole_munin_ to your \$PATH in all future terminal" \
                "       sessions."
        fi
        # Suggest restarting munin-node
        pihole_munin_restart_node_suggestion
    fi
}

###############################################################################
# Flush Plugin State Files
###############################################################################
# Usage:
#   pihole_munin_flush [<option>]
#
# Description:
#   Removes all cached plugin state and seentag files from the plugin state
#   directory, forcing fresh API fetches on the next run.
#   Supports dry run mode to preview actions without making changes.
#
# Arguments:
#   <option>   - Options:
#              -D, dry, --dry-run   Show actions without deleting files
#
# Logic:
#   - Parses options for dry run mode.
#   - Checks for required state directory.
#   - Finds all plugin state files in the state directory.
#   - If no state files are found, prints info message.
#   - Otherwise, prints each file and removes it (unless dry run).
#
# Output:
#   - Prints status and success/error messages.
#   - Removes state files unless dry run is enabled.
###############################################################################

pihole_munin_flush() {
    dry_run="0"
    flushed=0
    # Parse options for dry run
    for option in "$@"; do
        case "${option}" in
            "-D"|"dry"|"--dry-run") dry_run="1" ;;
        esac
    done
    # Check for required directories
    pihole_munin_check_required_dirs "${pihole_munin_plugstate}"
    # Find all .state files
    statefiles=$(find "${pihole_munin_plugstate}" -maxdepth 1 -type f -name 'pihole_munin_*.state' 2>/dev/null)
    if [ -z "${statefiles}" ]; then
        printf "%s\n" "  [ℹ️] No state files to flush in '${pihole_munin_plugstate}'."
    else
        printf "\n  %s Flushing plugin state files …\n" \
            "$( [ "${dry_run}" -eq 0 ] && printf "[🚽]" || printf "[🚽] (DRY RUN)" )"
        for statefile_to_flush in ${statefiles}; do
            # Truncate path for terminal width, show basename only
            statefile=$(basename "${statefile_to_flush}")
            if [ "$dry_run" -eq 0 ]; then
                if rm -f "${statefile_to_flush}"; then
                    flushed=$((flushed + 1))
                else
                    printf "%s\n" "  [❌] Failed to remove statefile '${statefile_to_flush}'" >&2
                    exit 1
                fi
            fi
            printf "%b\n" "       ${TEXT_LIGHTBLUE}${statefile}${TEXT_RESET}"
        done
        printf "\n  %s Success.\n" \
            "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
        printf "\n  [ℹ️] Flushed %d file%s.\n" \
            "$flushed" "$( [ "$flushed" -eq 1 ] && printf "" || printf "s" )"
    fi
}

###############################################################################
# Uninstall Plugin Function
###############################################################################
# Usage:
#   pihole_munin_uninstall [<plugin> …] [<option>]
#
# Description:
#   Disables selected pihole_munin_ plugins by removing their symlinks from the
#   Munin plugins directory. If no symlinks remain, removes the plugin file itself.
#   Handles dry run mode, custom plugin paths, and prints status messages.
#
# Arguments:
#   <plugin> …   - List of plugins to uninstall (optional, defaults to all valid)
#   <option>     - Options:
#                -D, dry, --dry-run         Show actions without making changes
#                -P, path, --plugins-path   Specify custom plugins directory
#
# Logic:
#   - Checks for required directories.
#   - Removes symlinks for each specified plugin.
#   - If no symlinks remain, removes the plugin file.
#   - Advises user to remove plugin from PATH if present.
#   - Suggests restarting munin-node after uninstall.
#   - If symlinks remain, does not remove plugin file to avoid breakage.
#
# Output:
#   - Prints status and success/error messages.
#   - Removes symlinks and plugin file as appropriate.
#   - Returns non-zero on error.
###############################################################################

pihole_munin_uninstall() {
    pihole_munin_header
    shift 2
    parse_install_args "$@"
    # Check for required directories
    pihole_munin_check_required_dirs "${plugins_available}" "${plugins_enabled}"
    printf "  %s Disabling pihole_munin_ plugins …\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[🔴]" || printf "[🔴] (DRY RUN)" )"
    # Remove symlinks for each plugin
    for plugin in ${valid_plugins}; do
        if [ -L "${plugins_enabled}/pihole_munin_${plugin}" ]; then
            if [ "${dry_run}" -eq 0 ]; then
                rm -f "${plugins_enabled}/pihole_munin_${plugin}" || {
                    printf "%s\n" "  [❌] Failed to remove symlink '${plugins_enabled}/pihole_munin_${plugin}'." >&2
                    exit 1
                }
            fi
            printf "%b\n" "       ${TEXT_LIGHTBLUE}${plugins_enabled}/pihole_munin_${plugin}${TEXT_RESET}"
        fi
    done
    printf "\n  %s Success.\n\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
    # Count remaining symlinks
    symlink_count=$(find "${plugins_enabled}" -type l -name 'pihole_munin_*' | wc -l)
    if [ "${symlink_count}" -eq 0 ]; then
        # Check plugin file exists
        pihole_munin_check_plugin_file
        # Remove plugin file if no symlinks remain
        printf "  %s Uninstalling pihole_munin_ …\n" \
            "$( [ "${dry_run}" -eq 0 ] && printf "[🗑️]" || printf "[🗑️] (DRY RUN)")"
        if [ "${dry_run}" -eq 0 ]; then
            rm -f "${pihole_munin_path}" || {
                printf "%s\n" "  [❌] Failed to remove plugin file." >&2
                exit 1
            }
        fi
        # Print uninstall success message
        printf "%b\n\n  %s Success.\n\n" \
            "       ${TEXT_GREEN}${pihole_munin_path}${TEXT_RESET}" \
            "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
        if [ "${dry_run}" -eq 0 ]; then
            # Advise user to remove plugin from PATH if present
            if printf "%s" ":$PATH:" | grep -q ":${pihole_munin_path}:"; then
                printf "%s\n\n%s\n%s\n%s\n\n%s\n\n%s\n%b\n\n%s\n%s\n" \
                    "  [⚠️] Your \$PATH contains '${pihole_munin_path}'." \
                    "       To remove it permanently, edit your shell profile" \
                    "       (e.g. ~/.bashrc or ~/.profile) and remove any line that adds" \
                    "       '${pihole_munin_path}' to your \$PATH." \
                    "       Then restart your terminal or source the file." \
                    "       Example:" \
                    "       ${TEXT_GREEN}${pihole_munin_user}@${pihole_munin_host}${TEXT_RESET}:${TEXT_LIGHTBLUE}~${TEXT_RESET}$ source ~/.bashrc" \
                    "       This will remove pihole_munin_ from your \$PATH in all future terminal" \
                    "       sessions."
            fi
            # Suggest restarting munin-node
            pihole_munin_restart_node_suggestion
        fi
    else
        # If symlinks remain, do not remove plugin file
        printf "%s\n%s\n" \
            "  [ℹ️] Some pihole_munin_ plugins remain, not removing" \
            "       '${pihole_munin_path}' to avoid breakage."
    fi
}

###############################################################################
# Safe Write
###############################################################################
# Safely run a write command, print error if it fails
###############################################################################

pihole_munin_safe_write() {
    "$@" || { printf "%s\n" "  [❌] Failed to write to temporary file." >&2; return 1; }
}

###############################################################################
# Safe Move
###############################################################################
# Safely run a move command, print error if it fails
###############################################################################

pihole_munin_safe_move() {
    "$@" || { printf "%s\n" "  [❌] Failed to move temporary file." >&2; return 1; }
}

###############################################################################
# Mask Input
###############################################################################
# Reads input from user, masks with '*' (for passwords)
###############################################################################

pihole_munin_mask_input() {
    input=""
    IFS='
'
    stty -echo -icanon  # Disable echo and canonical mode
    while :; do
        input_char=$(dd bs=1 count=1 2>/dev/null | od -An -tx1 | tr -d ' \n')
        case "${input_char}" in
            "0a") break ;;
            "7f"|"08")
                if [ -n "${input}" ]; then
                    input=${input%?}
                    printf '\b \b'
                fi
                ;;
            ??)
                case "${input_char}" in
                    [0-9a-fA-F][0-9a-fA-F])
                        char=$(printf "\\x%s" "${input_char}")
                        input="${input}${char}"
                        printf '*'
                        ;;
                    *) continue ;;
                esac
                ;;
            *) continue ;;
        esac
    done
    pihole_munin_term_cleanup  # Restore terminal settings
    printf '%s\n' "${input}"
}

###############################################################################
# Safe Prompt
###############################################################################
# Prompt for masked input twice, confirm they match
###############################################################################

pihole_munin_safe_prompt() {
    printf "\nEnter value: "
    first_entry=$(pihole_munin_mask_input)
    printf "Confirm value: "
    second_entry=$(pihole_munin_mask_input)
    if [ "$first_entry" != "$second_entry" ]; then
        printf "%s\n" "  [❌] Entered values do not match." >&2
        return 1
    fi
}

###############################################################################
# Make Temp
###############################################################################
# Usage:
#   pihole_munin_mktemp [<dir>] [<prefix>]
#
# Description:
#   Creates a temporary file in the specified directory with the given prefix.
#   Tries different mktemp syntaxes for compatibility across systems.
#   Prints an error and exits if unable to create the file.
#
# Arguments:
#   <dir>    - Directory to create the temp file in (optional, default: /tmp)
#   <prefix> - Prefix for the temp file name (optional, default: pihole_munin_)
#
# Logic:
#   - Attempts to create a temp file using mktemp with directory and prefix.
#   - Falls back to mktemp -t if the first method fails.
#   - Prints error and exits if both methods fail.
#
# Output:
#   - Prints the path to the created temp file.
#   - Exits with error if creation fails.
###############################################################################

pihole_munin_mktemp() {
    mktemp_dir="${1:-/tmp}"
    mktemp_prefix="${2:-pihole_munin_}"
    # Try different mktemp syntaxes for compatibility
    mktemp "${mktemp_dir}/${mktemp_prefix}.XXXXXX" 2>/dev/null || mktemp -t "${mktemp_prefix}.XXXXXX" || {
        printf "%s\n" "  [❌] Unable to create temporary file '${mktemp_prefix}'." >&2
        exit 1
    }
}

###############################################################################
# Configure Function
###############################################################################
# Usage:
#   pihole_munin_configure <command> [<args>]
#
# Description:
#   Manages Munin plugin configuration variables. Supports listing, adding,
#   and removing variables in the plugin config file. Handles sensitive
#   variables securely and validates plugin lists.
#
# Arguments:
#   <command>   - Action to perform: list, add, remove
#   <args>      - Arguments for the command (variable name, value, etc.)
#
# Logic:
#   - Uses plugins_config or PIHOLE_MUNIN_CONF for config file path.
#   - Creates config file if missing.
#   - "list": Lists all config variables, masking passwords.
#   - "add": Adds or updates a variable, validates plugins, prompts for sensitive values.
#   - "remove": Removes a variable from the config file.
#   - Handles unknown commands with a warning.
#
# Output:
#   - Prints status and success/error messages.
#   - Updates the config file as appropriate.
###############################################################################

pihole_munin_configure() {
    config_file="${plugins_config}/pihole_munin_"
    [ -n "${PIHOLE_MUNIN_CONF}" ] && config_file="${PIHOLE_MUNIN_CONF}"
    # Create config file if missing
    if [ ! -f "${config_file}" ]; then
        pihole_munin_safe_write printf "[pihole_munin_*]\n" > "${config_file}"
    fi
    configure_command="${1}"
    shift
    case "${configure_command}" in
        "list")
            # List config variables in the config file
            [ -f "${config_file}" ] || { printf "%s\n" "  [❌] Configuration file not found." >&2; exit 1; }
            printf  "%s\n" "  [🔍] Listing variables in '${config_file}' …"
            matches=$(grep -E '^( *env\.| *user\s| *group\s)' "${config_file}")
            [ -z "${matches}" ] && { printf "\n%s\n" "  [ℹ️] No config variables found in '${config_file}'."; exit 0; }
            printf "%s\n" "${matches}" | while IFS= read -r config_line; do
                # Mask password variables
                if printf '%s' "${config_line}" | grep -qE 'env\.(.*_password|password) '; then
                    list_var=$(printf '%s' "${config_line}" | awk '{print $1}')
                    list_val=$(printf '%s' "${config_line}" | cut -d' ' -f2-)
                    list_len=$(printf '%s' "${list_val}" | wc -c)
                    [ "${list_len}" -gt 0 ] && list_len=$((list_len - 1))
                    list_masked=$(printf '%*s' "${list_len}" '' | tr ' ' '*')
                    printf "%s%s\n" "       ${list_var}" " ${list_masked}"
                else
                    printf "%s\n" "   ${config_line}"
                fi
            done
            printf "\n%s\n" "  [✅] Success."
            ;;
        "add")
            # Add a variable to the config file
            [ -z "${1}" ] && {
                printf "%s\n" "  [❌] No variable specified for addition." >&2
                exit 1
            }
            add_var="${1}"
            case "${add_var}" in
                "env."*) add_var="${add_var#env.}" ;;  # Remove env. prefix if present
            esac
            shift
            add_val="$*"
            trimmed_value=$(printf '%s' "${add_val}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            # Validate plugins if adding plugins variable
            if [ "${add_var}" = "plugins" ]; then
                valid_only=$(pihole_munin_validate_input_plugins "${trimmed_value}")
                if [ -z "${valid_only}" ]; then
                    printf "\n%s\n\n" "  [❌] No valid plugins found in input. Aborting." >&2
                    exit 1
                fi
                trimmed_value="${valid_only}"
            fi
            printf "%s\n" "  [➕] Adding variable to '${config_file}' …"
            # Handle sensitive variables (passwords)
            case "${add_var}" in
                "pihole_password")
                    case "${trimmed_value}" in
                        "nopassword"|"none"|"null") : ;;
                        *)
                            printf "\n%s\n\n%s\n" \
                                "  [⚠️] Sensitive variable '${add_var}' passed on the command line." \
                                "       This may be visible in shell history or process lists." >&2
                            ;;
                    esac
                    if [ -z "${trimmed_value}" ]; then
                        printf "\n%s\n\n%s\n\n" \
                            "  [⚠️] Sensitive variable '${add_var}' detected." \
                            "  [ℹ️] You will be prompted to enter the value securely." >&2
                        if ! pihole_munin_safe_prompt; then
                            exit 1
                        fi
                        trimmed_value="${add_val}"
                    fi
                    ;;
                "app_password")
                    printf "\n%s\n\n%s\n" \
                        "  [⚠️] Sensitive variable '${add_var}' passed on the command line." \
                        "       This may be visible in shell history or process lists." >&2
                    if [ -z "${trimmed_value}" ]; then
                        printf "\n%s\n\n%s\n\n" \
                            "  [⚠️] Sensitive variable '${add_var}' detected." \
                            "  [ℹ️] You will be prompted to enter the value securely." >&2
                        if ! pihole_munin_safe_prompt; then
                            exit 1
                        fi
                        trimmed_value="${add_val}"
                    fi
                    ;;
            esac
            [ -z "${trimmed_value}" ] && {
                printf "%s\n" "  [❌] Value for '${add_var}' is empty or whitespace only." >&2
                exit 1
            }
            # Prepare entry and remove any previous entry for the same variable
            case "${add_var}" in
                "user"|"group")
                    add_entry="    ${add_var} ${add_val}"
                    tmp_file=$(pihole_munin_mktemp "${pihole_munin_plugstate}" "pihole_munin_conf_add_${add_var}")
                    pihole_munin_safe_write sed "/^ *${add_var}\s/d" "${config_file}" > "${tmp_file}"
                    ;;
                *)
                    add_entry="    env.${add_var} ${add_val}"
                    tmp_file=$(pihole_munin_mktemp "${pihole_munin_plugstate}" "pihole_munin_conf_add_env_${add_var}")
                    pihole_munin_safe_write sed "/^ *env\.${add_var}\s/d" "${config_file}" > "${tmp_file}"
                    ;;
            esac
            # Write new entry and move temp file to config
            pihole_munin_safe_write printf "%s\n" "${add_entry}" >> "${tmp_file}"
            pihole_munin_safe_move mv "${tmp_file}" "${config_file}"
            printf "%s\n\n%s\n" \
                "       ${add_var}" \
                "  [✅] Success."
            ;;
        "remove")
            # Remove a variable from the config file
            [ -z "${1}" ] && { printf "  [❌] No variable specified for removal.\n" >&2; exit 1; }
            printf "%s\n" "  [➖] Removing variable from '${config_file}' …"
            remove_var="${1}"
            case "${remove_var}" in
                "user")  pattern='^ *user[[:space:]]' ;;
                "group") pattern='^ *group[[:space:]]' ;;
                *)
                    escaped_var=$(printf '%s' "${remove_var}" | sed 's/[][\\.^$*]/\\&/g')
                    pattern="^ *env\.${escaped_var}[[:space:]]"
                    ;;
            esac
            if grep -Eq "${pattern}" "${config_file}"; then
                tmp_file=$(pihole_munin_mktemp "${pihole_munin_plugstate}" "pihole_munin_conf_remove_${remove_var}")
                pihole_munin_safe_write sed "/${pattern}/d" "${config_file}" > "${tmp_file}"
                pihole_munin_safe_move mv "${tmp_file}" "${config_file}"
                printf "%s\n\n%s\n" \
                    "       ${remove_var}" \
                    "  [✅] Success."
            else
                printf "\n%s\n\n" "  [⚠️] Variable '${remove_var}' not found in '${config_file}'."
            fi
            ;;
        *)
            # Unknown command
            printf "\n%s\n\n" "  [⚠️] Unknown command '${configure_command}'." >&2
            ;;
    esac
}

###############################################################################
# Version Comparison Logic Overview
###############################################################################
# This function compares two version strings (e.g. "1.2.3", "1.2.3-beta").
#
# Version comparison and progression rules:
#   1. Major, minor, and patch numbers are compared numerically in order.
#      - Higher major wins; if equal, compare minor; if equal, compare patch.
#   2. If numeric parts are equal, pre-release tags (e.g. "-beta", "-rc") are
#      checked:
#      - A release (no tag) is always considered newer than any pre-release.
#        Example: "1.2.3" > "1.2.3-beta"
#      - If both have tags, they are compared lexically (alphabetically).
#        Example: "1.2.3-rc" > "1.2.3-beta" (because "rc" > "beta")
#   3. If both tags are identical, the versions are considered equal.
#
# Returns:
#   0 if the first version is newer or equal to the second,
#   1 if the first version is older.
#
# This logic ensures that stable releases are always preferred over
# pre-releases, and provides a simple ordering for common tags.
###############################################################################

pihole_munin_check() {
    # Helper: extract numeric part, default to 0 if missing
    extract_num() { printf '%s' "$1" | grep -oE '^[0-9]+' || printf '0'; }
    # Helper: extract pre-release tag (e.g. beta, rc), empty if none
    extract_tag() { printf '%s' "$1" | grep -oE '[-][a-zA-Z0-9]+' | sed 's/^-//'; }
    # Split version strings into components
    IFS=. read -r a b c_extra <<EOF
${1:-0.0.0}
EOF
    IFS=. read -r x y z_extra <<EOF
${2:-0.0.0}
EOF
    # Extract numeric patch and tag
    c=$(printf '%s' "${c_extra}" | grep -oE '^[0-9]+')
    z=$(printf '%s' "${z_extra}" | grep -oE '^[0-9]+')
    a=$(extract_num "${a}")
    b=$(extract_num "${b}")
    c=$(extract_num "${c}")
    x=$(extract_num "${x}")
    y=$(extract_num "${y}")
    z=$(extract_num "${z}")
    tag_a=$(extract_tag "${c_extra}")
    tag_x=$(extract_tag "${z_extra}")
    # Compare major, minor, patch
    [ "${a}" -gt "${x}" ] && return 0
    [ "${a}" -lt "${x}" ] && return 1
    [ "${b}" -gt "${y}" ] && return 0
    [ "${b}" -lt "${y}" ] && return 1
    [ "${c}" -gt "${z}" ] && return 0
    [ "${c}" -lt "${z}" ] && return 1
    # If numeric parts equal, compare tags
    # No tag (release) is newer than any tag (pre-release)
    if [ -z "${tag_a}" ] && [ -n "${tag_x}" ]; then
        return 0  # release > pre-release
    elif [ -n "${tag_a}" ] && [ -z "${tag_x}" ]; then
        return 1  # pre-release < release
    elif [ -n "${tag_a}" ] && [ -n "${tag_x}" ]; then
        # Lexical compare tags (e.g. rc > beta)
        first=$(printf '%s\n%s\n' "${tag_a}" "${tag_x}" | sort | head -n1)
        if [ "${tag_a}" = "${tag_x}" ]; then
            return 0
        elif [ "${tag_a}" = "${first}" ]; then
            return 1
        else
            return 0
        fi
    fi
    return 0  # Equal
}

###############################################################################
# Version Function
###############################################################################
# Usage:
#   pihole_munin_version [<option>]
#
# Description:
#   Prints the current pihole_munin_ plugin version. Optionally checks for
#   updates using a remote DNS TXT record if 'dig' is available, unless
#   the skip option is provided.
#
# Arguments:
#   <option>     - Options:
#                    -S, skip, --skip-version-check   Skip remote version check
#
# Logic:
#   - Parses options for skipping version check.
#   - Prints the current plugin version.
#   - If not skipping and 'dig' is available, checks for updates via DNS TXT.
#   - Compares local and remote version strings.
#   - Prints update info or success message.
#
# Output:
#   - Prints version, update status, and instructions.
#   - Returns non-zero on error.
###############################################################################

pihole_munin_version() {
    skip_check="0"
    # Parse options
    for option in "$@"; do
        case "${option}" in
            "-S"|"skip"|"--skip-version-check") skip_check="1" ;;
            *)
                printf "\n%s\n\n" "  [⚠️] Unknown option '${option}'."
                pihole_munin_help version
                ;;
        esac
    done
    printf "%s\n" "  [📦] Version: ${pihole_munin_version}"
    # If not skipping, check for updates using dig
    if [ "${skip_check}" -eq 0 ] && command -v dig >/dev/null 2>&1; then
        # Check for updates from a TXT record at sainternet.xyz using dig
        remote_version=$(dig +short TXT pihole-munin.sainternet.xyz | sed -e 's/[^.0-9]//g')
        printf "\n%s\n" "  [🔄] Checking for updates …"
        if [ -n "${remote_version}" ]; then
            if pihole_munin_check "${remote_version}" "${pihole_munin_version}"; then
                # Remote version is newer
                printf "%s\n\n%s\n\n%s\n%s\n" \
                "       ${remote_version}" \
                "  [🆕] A newer version is available." \
                "  [ℹ️] Run '${script_path} admin update' to update the plugin, or run" \
                "       '${script_path} help admin update' for more information."
            else
                # Local version is up-to-date
                printf "\n%s\n\n%s\n" "  [✅] Success." \
                    "  [ℹ️] You are using the latest version."
            fi
        else
            # Unable to check for updates
            printf "%s\n" "  [❌] Unable to check for updates." >&2
            exit 1
        fi
    fi
}

# Date and time for backup file naming
# Format: YYYY-MM-DD-HH-MM-SS
datetime_timestamp=$(date +%Y-%m-%d-%H-%M-%S)

###############################################################################
# Update Plugin Function
###############################################################################
# Usage:
#   pihole_munin_update [<option>]
#
# Description:
#   Updates the pihole_munin_ plugin to the latest version from GitHub.
#   Downloads the latest script, checks version numbers, backs up the current
#   plugin, and installs the update. Handles dry run mode, validates the
#   downloaded script, and prints status messages.
#
# Arguments:
#   <option>     - Options:
#                -D, dry, --dry-run         Show actions without making changes
#
# Logic:
#   - Checks for required directories and plugin file.
#   - Downloads the latest script from GitHub.
#   - Validates the downloaded script.
#   - Compares local and remote version numbers.
#   - Prompts user if local version is newer or version strings are invalid.
#   - Backs up the current plugin before updating.
#   - Installs the update and sets permissions.
#   - Suggests restarting munin-node after update.
#
# Output:
#   - Prints status and success/error messages.
#   - Backs up and updates the plugin file.
#   - Returns non-zero on error.
###############################################################################

pihole_munin_update() {
    pihole_munin_header
    repo_url="github.com/saint-lascivious/pihole_munin_"
    raw_url="https://${repo_url}/raw/master/pihole_munin_"
    bak_file="$(printf "%s" "pihole_munin_${pihole_munin_version}-${datetime_timestamp}.bak")"
    # Parse options for dry run
    for option in "$@"; do
        case "${option}" in
            "-D"|"dry"|"--dry-run") dry_run="1" ;;
        esac
    done
   # Check for required directories
    pihole_munin_check_required_dirs "${plugins_available}" "${plugins_enabled}" "${pihole_munin_plugstate}"
     # Create a temporary file for the download
    tmp_file=$(pihole_munin_mktemp "${pihole_munin_plugstate}" "pihole_munin_update")
    # Check plugin file exists
    pihole_munin_check_plugin_file
    printf "  %s Fetching pihole_munin_ from '%s' …\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[⬇️]" || printf "[⬇️] (DRY RUN)" )" \
        "${repo_url}"
    # Download the latest script
    if curl -fsSL "${raw_url}" -o "${tmp_file}"; then
        printf "%s\n" "       ${tmp_file}"
        [ -s "${tmp_file}" ] || {
            printf "%s\n" "  [❌] Downloaded is empty." >&2
            rm -f "${tmp_file}"
            exit 1
        }
        grep -q '^#!/usr/bin/env sh' "${tmp_file}" || {
            printf "%s\n" "  [❌] Downloaded file is not a valid script." >&2
            rm -f "${tmp_file}"
            exit 1
        }
        printf "%b\n\n  %s Success.\n\n" \
            "       ${TEXT_GREEN}${tmp_file}${TEXT_RESET}" \
            "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
        # Extract version numbers from local and remote scripts
        remote_version=$(grep -E '^version=' "${tmp_file}" | cut -d= -f2)
        local_version=$(grep -E '^version=' "${pihole_munin_path}" | cut -d= -f2)
        version_regex='^[0-9]+(\.[0-9]+){1,2}$'
        # Display version info
        if [ -z "${local_version}" ]; then
            local_version_display="unknown"
        elif printf '%s' "${local_version}" | grep -Eq "${version_regex}"; then
            local_version_display="${local_version}"
        else
            local_version_display="invalid"
        fi
        if [ -z "${remote_version}" ]; then
            remote_version_display="unknown"
        elif printf '%s' "${remote_version}" | grep -Eq "${version_regex}"; then
            remote_version_display="${remote_version}"
        else
            remote_version_display="invalid"
        fi
        printf "  %s Checking versions …\n%s\n%s\n" \
            "$( [ "${dry_run}" -eq 0 ] && printf "[🔄]" || printf "[🔄] (DRY RUN)" )" \
            "       local version: ${local_version_display}" \
            "       remote version: ${remote_version_display}"
        # Warn if version strings are invalid or unknown
        if [ "${local_version_display}" = "invalid" ] || [ "${remote_version_display}" = "invalid" ]; then
            printf "\n%s\n\n" "  [⚠️] One or both version strings are invalid."
        fi
        if [ "${local_version_display}" = "unknown" ] || [ "${remote_version_display}" = "unknown" ]; then
            printf "\n%s\n\n" "  [⚠️] One or both version strings are unknown."
        fi
        # If local version is newer or equal, or version strings are invalid/unknown, prompt user
        if [ "${local_version}" -ge "${remote_version}" ] ||  [ "${local_version_display}" = "invalid" ] \
            || [ "${remote_version_display}" = "invalid" ] || [ "${local_version_display}" = "unknown" ] \
            || [ "${remote_version_display}" = "unknown" ]; then
            if [ -t 0 ]; then
                printf "\n%s" "       Continue? [y/N] "
                read -r answer
                case "${answer}" in
                    [yY]|[yY][eE][sS])
                        printf "\n%s\n\n" "  [🚀] Proceeding with update …"
                        ;;
                    *)
                        printf "%b\n" "  [❌] ${TEXT_RED}Aborted by user (interactive session).${TEXT_RESET}" >&2
                        rm -f "${tmp_file}"
                        exit 1
                        ;;
                esac
            else
                printf "%b\n" "  [❌] ${TEXT_RED}Aborted (non-interactive session).${TEXT_RESET}" >&2
                rm -f "${tmp_file}"
                exit 1
            fi
        else
            # If remote version is not newer, exit
            if ! pihole_munin_check "${remote_version}" "${local_version}"; then
                printf "\n%s\n" "  [ℹ️] You are using the latest version of pihole_munin_."
                rm -f "${tmp_file}"
                exit 0
            else
                printf "\n%s\n" "  [🆕] A newer version is available."
            fi
        fi
        # Backup current plugin
        printf "\n  %s\n" "%s Backing up '${pihole_munin_path}' …" \
            "$( [ "${dry_run}" -eq 0 ] && printf "[🗄️]" || printf "[🗄️] (DRY RUN)" )"
        if [ "${dry_run}" -eq 0 ]; then
            cp -f "${pihole_munin_path}" "${bak_file}" || {
                printf "%s\n" "  [❌] Failed to back up existing script." >&2
                rm -f "${tmp_file}"
                exit 1
            }
            printf "%s\n\n%s\n\n%s\n\n%s\n%b\n" \
                "       ${bak_file}" \
                "  [✅] Success." \
                "  [ℹ️] You can restore this backup at any time." \
                "  Example:" \
                "    ${TEXT_GREEN}${pihole_munin_user}@${pihole_munin_host}${TEXT_RESET}:${TEXT_LIGHTBLUE}~${TEXT_RESET}$ cp -f ${bak_file} ${pihole_munin_path}"
        else
            printf "%s\n\n%s\n" \
                "       ${bak_file}" \
                "  [✅] (DRY RUN) Success."
        fi
        # Install update
        printf "\n  %s Installing update …\n" \
            "$( [ "${dry_run}" -eq 0 ] && printf "[🛠️]" || printf "[🛠️] (DRY RUN)")"
        chmod 755 "${tmp_file}" || {
            printf "%s\n" "  [❌] Failed to set permissions on update." >&2
            rm -f "${tmp_file}"
            exit 1
        }
        if [ "${dry_run}" -eq 0 ]; then
            mv "${tmp_file}" "${pihole_munin_path}" || {
                printf "%s\n" "  [❌] Failed to install updated plugin." >&2
                rm -f "${tmp_file}"
                exit 1
            }
        fi
        # Print update success message
        printf "%b\n\n  %s Success.\n\n" \
            "       ${TEXT_GREEN}${pihole_munin_path}${TEXT_RESET}" \
            "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
        if [ "${dry_run}" -eq 0 ]; then
            # Suggest restarting munin-node
            pihole_munin_restart_node_suggestion
        fi
    else
        # Download failed
        printf "%s\n" "  [❌] Failed to fetch pihole_munin_." >&2
        rm -f "${tmp_file}"
        exit 1
    fi
}

###############################################################################
# Test Plugins Function
###############################################################################
# Usage:
#   pihole_munin_test [<option>]
#
# Description:
#   Tests all enabled pihole_munin_ plugins using munin-run. Runs both config
#   and fetch commands for each plugin, reporting any errors. Supports dry run
#   mode to preview actions, and verbose/trace output for debugging.
#
# Arguments:
#   <option>     - Options:
#                -D, dry, --dry-run     Show actions without making changes
#                -T, trace, --trace     Show detailed plugin output
#                                       (implies verbose)
#                -V, verbose, --verbose Show plugin output during the test
#
# Logic:
#   - Checks for munin-run command.
#   - Parses options for dry run, verbose, and trace modes.
#   - If not dry run, runs munin-run config and fetch for each plugin.
#   - In verbose/trace mode, prints plugin output and errors.
#   - In dry run, checks symlinks exist for each plugin.
#
# Output:
#   - Prints status and success/error messages.
#   - Returns non-zero on error.
###############################################################################

pihole_munin_test() {
    # Check for munin-run command
    if ! command -v munin-run >/dev/null 2>&1; then
        printf "%s\n" "  [❌] 'munin-run' command not found." >&2
        exit 1
    fi
    pihole_munin_header
    dry_run="0"
    verbose="0"
    trace="0"
    # Parse options
    for option in "$@"; do
        case "${option}" in
            "-D"|"dry"|"--dry-run") dry_run="1" ;;
            "-T"|"trace"|"--trace")
                trace="1"
                verbose="1"
                ;;
            "-V"|"verbose"|"--verbose") verbose="1" ;;
        esac
    done
    printf "\n  %s Testing pihole_munin_ plugins …\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[🧪]" || printf "[🧪] (DRY RUN)")"
    if [ "${dry_run}" -eq 0 ]; then
        # Actually run munin-run for each plugin
        for plugin in $(pihole_munin_valid_plugins); do
            if [ "${verbose}" -eq 1 ]; then
                munin_run_cmd="munin-run pihole_munin_${plugin}"
                [ "${trace}" -eq 1 ] && munin_run_cmd="$munin_run_cmd --debug"
                if ! eval "$munin_run_cmd config"; then
                    printf "%s\n" "  [❌] 'config' failed for plugin '${plugin}'."
                    exit 1
                fi
                if ! eval "$munin_run_cmd fetch"; then
                    printf "%s\n" "  [❌] 'fetch' failed for plugin '${plugin}'."
                    exit 1
                fi
            else
                if ! munin-run pihole_munin_"${plugin}" config >/dev/null 2>&1; then
                    printf "%s\n" "  [❌] 'config' failed for plugin '${plugin}'."
                    exit 1
                fi
                if ! munin-run pihole_munin_"${plugin}" fetch >/dev/null 2>&1; then
                    printf "%s\n" "  [❌] 'fetch' failed for plugin '${plugin}'."
                    exit 1
                fi
            fi
            printf "%s\n" "       ${plugin}"
        done
    else
        # Dry run: just check symlinks exist
        for plugin in $(pihole_munin_valid_plugins); do
            [ -L "${pihole_munin_path}${plugin}" ] || {
                printf "%s\n" "  [❌] Plugin '${plugin}' not found in '${plugins_available}'." >&2
                exit 1
            }
            printf "%s\n" "       ${plugin}"
        done
    fi
    printf "\n  %s Success.\n" \
        "$( [ "${dry_run}" -eq 0 ] && printf "[✅]" || printf "[✅] (DRY RUN)" )"
}

###############################################################################
# Help Function
###############################################################################
# Usage:
#   pihole_munin_help <command> [<subcommand>]
#
# Description:
#   Prints detailed help and usage information for pihole_munin_ commands and
#   subcommands. Handles admin, install, uninstall, update, config, fetch,
#   flush, test, version, and other commands. Provides examples, option lists,
#   and notes for each supported command. If no command is given, prints
#   general help. If an unknown command or subcommand is given, prints a
#   warning and general help.
#
# Arguments:
#   <command>     - Main command or help topic (e.g. admin, install, fetch)
#   <subcommand>  - Subcommand for admin (e.g. add, list, remove, update)
#
# Logic:
#   - Matches command and subcommand to print relevant help text.
#   - Prints usage, description, options, examples, and notes.
#   - If unknown topic, prints warning and general help.
#
# Output:
#   - Prints formatted help and usage information to stdout.
###############################################################################

pihole_munin_help() {
    case "${1}" in
        "-a"|"admin"|"--admin")
            case "${2}" in
                "-A"|"add"|"--add")
                    printf "%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n\n%s\n%s\n%s\n" \
                        "  [❓] ${script_path} ${1} ${2} <var> [<val>]" \
                        "       Add or update a plugin configuration variable." \
                        "       Variables SHOULD be entered without the env. prefix, and values SHOULD be" \
                        "       without encapsulating quotation." \
                        "  [ℹ️] You will be prompted to enter the value securely if it is sensitive" \
                        "       (e.g. app_password or pihole_password)." \
                        "  Examples:" \
                        "    ${script_path} ${1} ${2} host 192.168.1.10" \
                        "    ${script_path} ${1} ${2} user pihole"
                    ;;
                "-i"|"install"|"--install")
                    printf "%s\n\n%s\n\n%s\n\n%s\n\n%s\n\n%s\n%s\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n" \
                        "  [❓] ${script_path} ${1} ${2} [<plugin> …] [<option>]" \
                        "       Install pihole_munin_ and enable plugins." \
                        "  [ℹ️] This command will install pihole_munin_ and enable the specified plugins." \
                        "       If no plugins are specified, the default plugins will be enabled." \
                        "       If 'all' is specified as a plugin, all available plugins will be enabled." \
                        "  Options:" \
                        "    -D, dry, --dry-run     Show what would be done, without making any changes." \
                        "    -P, path, --plugins-path <dir> " \
                        "                           Specify a custom path for pihole_munin_" \
                        "                           (default: /usr/share/munin/plugins)" \
                        "  Examples:" \
                        "    ${script_path} ${1} ${2} all" \
                        "    ${script_path} ${1} ${2} --dry-run" \
                        "    ${script_path} ${1} ${2} cache clients" \
                        "    ${script_path} ${1} ${2} cache clients --dry-run" \
                        "    ${script_path} ${1} ${2} path /usr/local/share/munin/plugins" \
                        "    ${script_path} ${1} ${2} cache --plugins-path /opt/munin/plugins"
                    ;;
                "-l"|"list"|"--list")
                    printf "%s\n\n%s\n\n%s\n" \
                        "  [❓] ${script_path} ${1} ${2}" \
                        "       List all configured plugin variables." \
                        "  [ℹ️] Sensitive variables (e.g. passwords) will be masked."
                    ;;
                "-p"|"password"|"--password")
                    printf "%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n%s\n" \
                        "  [❓] ${script_path} ${1} ${2} [<password>]" \
                        "       Set the Pi-hole password." \
                        "  [ℹ️] This command will add or update the pihole_password variable in the" \
                        "       plugin configuration file." \
                        "  Examples:" \
                        "    ${script_path} ${1} ${2} mysecretpassword" \
                        "    ${script_path} ${1} ${2} nopassword"
                    ;;
                "-r"|"remove"|"--remove")
                    printf "%s\n\n%s\n\n%s\n%s\n%s\n" \
                        "  [❓] ${script_path} ${1} ${2} <var>" \
                        "       Remove a variable from the plugin configuration." \
                        "  Examples:" \
                        "    ${script_path} ${1} ${2} host" \
                        "    ${script_path} ${1} ${2} user"
                    ;;
                "-u"|"uninstall"|"--uninstall")
                    printf "%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n%s\n%s\n" \
                        "  [❓] ${script_path} ${1} ${2} [<plugin> …] [<option>]" \
                        "       Disable plugins and uninstall pihole_munin_." \
                        "  [ℹ️] This command will remove the specified plugins from the Munin node." \
                        "       If no plugins are specified pihole_munin_ will be uninstalled." \
                        "  Options:" \
                        "    -D, dry, --dry-run     Show what would be done, without making any changes." \
                        "    -P, path, --plugins-path <dir> " \
                        "                           Specify a custom path for pihole_munin_" \
                        "                           (default: /usr/share/munin/plugins)" \
                        "  Examples:" \
                        "    ${script_path} ${1} ${2} --dry-run" \
                        "    ${script_path} ${1} ${2} cache clients" \
                        "    ${script_path} ${1} ${2} cache clients --dry-run" \
                        "    ${script_path} ${1} ${2} path /usr/local/share/munin/plugins" \
                        "    ${script_path} ${1} ${2} cache --plugins-path /opt/munin/plugins"
                    ;;
                "-U"|"update"|"--update")
                    printf "%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n\n%s\n%s\n" \
                        "  [❓] ${script_path} ${1} ${2} [<option>]" \
                        "       Update pihole_munin_ to the latest version." \
                        "  [ℹ️] This command will download the latest version from the GitHub repository" \
                        "       and replace the current script." \
                        "  Options:" \
                        "    -D, dry, --dry-run     Show what would be done, without making any changes." \
                        "  Example:" \
                        "    ${script_path} ${1} ${2} --dry-run"
                    ;;
                "" )
                    printf "%s\n\n%s\n\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
                        "  [❓] ${script_path} ${1} <subcommand>" \
                        "       Manage plugin configuration and installation." \
                        "  Subcommands:" \
                        "    -A, add                    Add or update a plugin configuration variable." \
                        "    -i, install, --install     Install pihole_munin_ and enable all plugins." \
                        "    -l, list                   List all configured plugin variables." \
                        "    -p, password               Set the Pi-hole password." \
                        "    -r, remove                 Remove a variable from the plugin config." \
                        "    -u, uninstall, --uninstall Disable all plugins and uninstall pihole_munin_." \
                        "    -U, update                 Update pihole_munin_ to the latest version." \
                        "  [ℹ️] Run '${script_path} help admin <subcommand>' for more information on a subcommand."
                    ;;
                * )
                    printf "%s\n\n%s\n" \
                        "  [⚠️] Unknown ${1} subcommand '${2}'" \
                        "  [ℹ️] Run '${script_path} help admin' for a list of available subcommands."
                    ;;
            esac
            ;;
        "autoconf")
            printf "%s\n\n%s\n%s\n%s\n\n%s\n%s\n\n%s\n\n%s\n%s\n%s\n" \
                "  [❓] ${script_path} ${1}" \
                "       A plugin with a capabilities=autoconf magic marker will first be invoked" \
                "       with autoconf as the sole argument. When invoked thus the plugin should" \
                "       do one of these two:" \
                "       1. Print 'yes' to signal that the plugin thinks it can be useful on this" \
                "          host" \
                "       2. Print 'no' to signal that the plugin does not think so." \
                "       The plugin should always exit 0, even if the response is 'no'." \
                "       If the answer was 'yes' and it's not a wildcard plugin, the plugin will" \
                "       be linked into the plugins catalog of munin-node."
            ;;
        "config")
            printf "%s\n\n%s\n\n%s\n\n%s\n" \
                "  [❓] ${script_path} ${1}" \
                "       The config output describes the plugin and the graph it creates." \
                "       The full set of attributes you can use is found in the config reference." \
                "       https://guide.munin-monitoring.org/en/master/reference/plugin.html" \
            ;;
        "fetch")
            printf "%s\n\n%s\n%s\n\n%s\n%s\n%s\n\n%s\n\n%s\n" \
                "  [❓] ${script_path} ${1}" \
                "       Synonymous with \"\" (no arguments), this is the normal invocation" \
                "       of the plugin." \
                "       When the node receives a fetch command for a plugin, the plugin is" \
                "       invoked without any arguments on the command line and is expected to" \
                "       emit one or more 'field.value' attribute values." \
                "       One for each thing the plugin observes as defined by the config output." \
                "       Plotting of graphs may be disabled by the config output."
            ;;
        "-f"|"flush"|"--flush-state")
            printf "%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n\n%s\n%s\n" \
                "  [❓] ${script_path} ${1} [<option>]" \
                "       Flush the plugin state files." \
                "       This command will remove all cached data for the plugin, forcing a fresh" \
                "       fetch on the next run." \
                "  Options:" \
                        "    -D, dry, --dry-run     Show what would be done, without making any changes." \
                "  Example:" \
                "    ${script_path} ${1} --dry-run"
            ;;
        "-h"|"help"|"--help")
            printf "%s\n\n%s\n\n%s\n%s\n" \
                "  [❓] ${script_path} ${1} <command> [<subcommand>]" \
                "       Displays general or detailed help for commands and subcommands." \
                "  Example:" \
                "    ${script_path} ${1} admin add"
            ;;
        "setpassword")
            printf "%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n%s\n" \
                "  [❓] ${script_path} ${1} [<password>]" \
                "       Shortcut to set the Pi-hole password." \
                "  [ℹ️] This command will add or update the pihole_password variable in the" \
                "       plugin configuration file." \
                "  Examples:" \
                "    ${script_path} ${1} mysecretpassword" \
                "    ${script_path} ${1} nopassword"
            ;;
        "suggest")
            printf "%s\n\n%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n\n%s\n" \
                "  [❓] ${script_path} ${1}" \
                "       Munin creates one graph per plugin." \
                "       To create many graphs from one plugin, you can write a wildcard plugin." \
                "       These plugins take one or more bits of configuration from the file name" \
                "       it is run as." \
                "       The plugin is stored as one file in the directory for available plugins," \
                "       but is linked as multiple files in the directory for enabled plugins." \
                "       This creates one graph per link name, using just one plugin as source."
            ;;
        "-t"|"test"|"--test-plugins")
            printf "%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n%s\n%s\n\n%s\n%s\n\n%s\n%s\n%s\n%s\n" \
                "  [❓] ${script_path} ${1}" \
                "       Test all pihole_munin_ plugins." \
                "       This will run the config and fetch commands for each plugin, and report" \
                "       any errors encountered during the process." \
                "  Options:" \
                "    -D, dry, --dry-run     Show what would be done, without making any changes." \
                "    -T, trace, --trace     Show detailed plugin output during the test." \
                "    -V, verbose, --verbose Show plugin output during the test." \
                "  Note:" \
                "    Use of '--trace' implies '--verbose' and passes '--debug' to 'munin-run'." \
                "  Examples:" \
                "    ${script_path} ${1} --dry-run" \
                "    ${script_path} ${1} --trace" \
                "    ${script_path} ${1} --verbose"
            ;;
        "-v"|"version"|"--version")
            printf "%s\n\n%s\n\n%s\n%s\n\n%s\n%s\n\n%s\n%s\n%s\n" \
                "  [❓] ${script_path} ${1} [<option>]" \
                "       Display the plugin version string." \
                "  [ℹ️] If not skipped, a check for a newer version will be performed using a" \
                "       remote DNS TXT record located at the pihole-munin.sainternet.xyz domain." \
                "  Options:" \
                "    -S, skip, --skip-version-check     Skip remote plugin version check." \
                "  Examples:" \
                "    ${script_path} ${1}" \
                "    ${script_path} ${1} --skip-version-check"
            ;;
        "")
            printf "%s\n\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n%s\n" \
                "  [❓] ${script_path} <command>" \
                "  Commands:" \
                "    -a, admin, --admin         Manage plugin configuration and installation." \
                "    autoconf                   Check if the plugin can be useful on this host." \
                "    config                     Generate the plugin configuration." \
                "    fetch                      Fetch and format the data for Munin to process." \
                "    -f, flush, --flush-state   Flush the plugin state files." \
                "    -h, help, --help           Show detailed help information." \
                "    setpassword                Shortcut to set the Pi-hole password." \
                "    suggest                    List available plugins." \
                "    -t, test, --test-plugins   Test all pihole_munin_ plugins." \
                "    -v, version, --version     Display the plugin version string." \
                "  [ℹ️] Run '${script_path} help <command>' for more information on a command."
            ;;
        * )
            printf "\n%s\n\n" "  [⚠️] Unknown help topic '$*'."
            pihole_munin_help
            ;;
    esac
}

###############################################################################
# Argument Parsing and Command Dispatch
###############################################################################

# Check for help flag anywhere in arguments
for argument in "$@"; do
    case "${argument}" in
        "-h"|"help"|"--help")
            help_flag="${argument}"
            break
            ;;
    esac
done

# If help flag is present but not first, move it to the front
if [ -n "${help_flag}" ] && [ "${1}" != "${help_flag}" ]; then
    new_arguments=""
    first="1"
    for argument; do
        if [ "${first}" -eq 1 ] && [ "${argument}" = "${help_flag}" ]; then
            first="0"
            continue
        fi
        new_arguments="${new_arguments:+${new_arguments} }$(printf '%s\n' "${argument}" | sed "s/'/'\\\\''/g; s/^/'/; s/\$/'/")"
    done
    eval "set -- '${help_flag}' ${new_arguments}"
fi

###############################################################################
# Redeploy and Dispatch as Root User (if needed)
###############################################################################

case "${1}" in
    "-a"|"admin"|"--admin")
        case "${2}" in
            "-A"|"add"|"--add"|"-l"|"list"|"--list"|"-p"|"password"|"--password"|"-r"|"remove"|"--remove")
                pihole_munin_root "$@"
                ;;
            "-i"|"install"|"--install") pihole_munin_root "$@" ;;
            "-u"|"uninstall"|"--uninstall") pihole_munin_root "$@" ;;
            "-U"|"update"|"--update") pihole_munin_root "$@" ;;
        esac
        ;;
    "setpassword"|"-t"|"test"|"--test-plugins")
        pihole_munin_root "$@"
        ;;
esac

###############################################################################
# Main Command Dispatch
###############################################################################

case "${1}" in
    "-a"|"admin"|"--admin")
        case "${2}" in
            "-A"|"add"|"--add")
                shift 2
                pihole_munin_configure "add" "$@"
                ;;
            "-i"|"install"|"--install") pihole_munin_install "$@" ;;
            "-l"|"list"|"--list") pihole_munin_configure "list" ;;
            "-p"|"password"|"--password")
                shift 2
                pihole_munin_configure "add" "pihole_password" "$@"
                ;;
            "-r"|"remove"|"--remove")
                shift 2
                pihole_munin_configure "remove" "$@"
                ;;
            "-u"|"uninstall"|"--uninstall") pihole_munin_uninstall "$@" ;;
            "-U"|"update"|"--update") pihole_munin_update "$@" ;;
            "") pihole_munin_help "${1}" ;;
            *) pihole_munin_help "${1}" "${2}" ;;
        esac
        ;;
    "autoconf") pihole_munin_autoconf ;;
    "config")
        pihole_munin_config_handler
        if [ "${MUNIN_CAP_DIRTYCONFIG}" = "1" ]; then
            pihole_munin_fetch_handler
        fi
        ;;
    "fetch") pihole_munin_fetch_handler ;;
    "-f"|"flush"|"--flush-state") pihole_munin_flush "$@" ;;
    "-h"|"help"|"--help")
        case "${2}" in
            "") pihole_munin_help ;;
            "-a"|"admin"|"--admin") pihole_munin_help "${2}" "${3:-}" ;;
            "autoconf"|"config"|"fetch"|"-f"|"flush"|"--flush-state"|"setpassword"|"suggest"|"-t"|"test"|"--test-plugins"|"-v"|"version"|"--version")
                pihole_munin_help "${2}"
                ;;
            *)
                printf "  [⚠️] Unknown help topic '%s'\n\n" "${2}"
                pihole_munin_help
                ;;
        esac
        ;;
    "suggest") pihole_munin_suggest ;;
    "setpassword") pihole_munin_configure "add" "pihole_password" "${2:-}" ;;
    "-t"|"test"|"--test-plugins") pihole_munin_test "$@" ;;
    "-v"|"version"|"--version")
        shift
        pihole_munin_version "$@"
        ;;
    "") pihole_munin_fetch_handler ;;
    *) pihole_munin_help ;;
esac

#    /\_/\  
#   ( O.O ) 
#    > ^ < ((
#   /     \ ))
#   \\ | / \/
#   ((_|_) _)

exit 0
